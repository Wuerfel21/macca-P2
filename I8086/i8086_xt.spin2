{
    INTEL 8086 XT Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Memory Map:

        00000-3FFFF ram (256k)
        B8000-BBFFF cga (16k)
        FE000-FFFFF rom (8k)
}
CON

    _CLKFREQ = 250_000_000

    VGA_PIN = 48
    USB_BASE_PIN = 40

DAT             ' Startup
                org     $000

                asmclk
                drvl    #56
                drvl    #57

                coginit #3, ##@video_driver
                coginit #1, ##@usb_host_start
                waitx   ##_CLKFREQ * 1
                coginit #0, ##@i8086
                jmp     #$

                orgh

int_io_A0       byte    $00

                ' 8255 I/O
ppa_io_60       byte    %00000000   ' I=Keyboard scancode O=Diagnostic output
ppa_io_61       byte    %00000000   ' Output
ppa_io_62       byte    %00001100   ' I
                '            |||+--- Loop on POST
                '            ||+---- 1=Co-processor installed
                '            |+----- planar ram size 00=64k, 01=128k, 10=192k, 11=256k
                '            +------ planar ram size
                '
                '
                '
                '
ppa_io_63       byte    %00000000   ' Command / Mode register

kbd_head        byte    $00
kbd_tail        byte    $00
kbd_buffer      byte    $00[8]

                ' CGA I/O registers
cga_io_03D0     byte    $00
cga_io_03D1     byte    $00
cga_io_03D2     byte    $00
cga_io_03D3     byte    $00
cga_io_03D4     byte    $00         ' MC6845 Address
cga_io_03D5     byte    $00         ' MC6845 Data
cga_io_03D6     byte    $00
cga_io_03D7     byte    $00
cga_io_03D8     byte    %00000000   ' Mode Select Register (BIOS keeps current value at 40:0065)
                                    '   0: width (text modes): 0=40 clms; 1=80 clms
                                    '   1: 1=enable graphics modes; 0=text modes
                                    '   2: 1=disable color burst on composite monitor
                                    '   3: 1=enable video signal; 0=disable (all black)
                                    '   4: dot resolutn: 0=320 2-bit dots; 1=640 1-bit dots
                                    '   5: enable blink: 1=text attribute bit 7 blinks fgnd
                                    '                    0=attr bit 7 is bkgd intensity
cga_io_03D9     byte    %00000000   ' Write: Color Select Register
                                    '   0-3: color. Text modes: IRGB of border
                                    '               Graphics modes: IRGB of background
                                    '   4: intensity. Text: bkgd intensity
                                    '                 Mid-res graphics: pixel intensity
                                    '   5: blue. Select grafx palette 0 or 1 (1 adds blue)
cga_io_03DA     byte    %00000000   ' Read: Status Register
                                    '   0: retrace.  1=display in vert or horiz retrace.
                                    '   1: 1=light pen trigger is triggered; 0=armed
                                    '   2: 1=light pen switch is open; 0=closed
                                    '   3: 1=vertical sync pulse is occurring.  Display is
                                    '                 in vertical retrace--access won't cause "snow"
cga_io_03DB     byte    $00         ' Read/Write: Light Pen Latch Reset.  Any OUT clears light pen latch.
cga_io_03DC     byte    $00         ' Read/Write: Light Pen Latch Set.  Any OUT sets the light pen latch.
cga_io_03DD     byte    $00
cga_io_03DE     byte    $00
cga_io_03DF     byte    $00

                ' MC6845 registers
cga_io_mc6845                   '         Unit        R/W         Name                  Size    40x25   80x25   Graphics
                byte    $00     ' R0      Char        Write       Hor. Total            8       38      71      38
                byte    $00     ' R1      Char        Write       Hor. Disp.            8       28      50      28
                byte    $00     ' R2      Char        Write       Hor. Sync Pos.        8       2D      5A      2D
                byte    $00     ' R3      Char        Write       Hor. Sync Width       4       0A      0A      0A
                byte    $00     ' R4      Char Row    Write       Vert. Total           7       1F      1F      7F
                byte    $00     ' R5      Scan Line   Write       Vert. Total Adj.      5       06      06      06
                byte    $00     ' R6      Char Row    Write       Vert. Disp.           7       19      19      64
                byte    $00     ' R7      Char Row    Write       Vert. Sync Pos.       7       1C      1C      70
                byte    $00     ' R8                  Write       Interlace Mode        2       02      02      02
                byte    $00     ' R9      Scan Line   Write       Max Scan Line Addr.   5       07      07      01
                byte    $00     ' R10     Scan Line   Write       Cursor Start          7 (5)   06      06      06
                byte    $07     ' R11     Scan Line   Write       Cursor End            5       07      07      07
                byte    $00     ' R12                 Write       Start Add. (H)        6       00      00      00
                byte    $00     ' R13                 Write       Start Add. (L)        8       00      00      00
                byte    $00     ' R14                 Read/Write  Cursor Add. (H)       6       XX      XX      XX
                byte    $00     ' R15                 Read/Write  Cursor Add. (L)       8       XX      XX      XX
                byte    $00     ' R16                 Read        Light Pen (H)         6       XX      XX      XX
                byte    $00     ' R17                 Read        Light Pen (L)         8       XX      XX      XX
                alignl

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                add     ptrb, ##@hlut_start - @usb_host_start
                setq2   #512-1
                rdlong  0, ptrb

                jmp     #\usb_host_init

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup
' */
' /* txn_in
'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                and     frame, ##$7ff
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                mov     usb_err_code, retval            ' Save the error code for the client interface
                'wxpin   #USB_ERROR, usb_event_pin       ' Signal the client an error has occurred
                mov     hrep, #5
.spin
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    drvl    host_error_led
        if_z    jmp     #host_reset                     ' See if it works...
                drvnot  host_error_led
                mov     hctwait, _100ms_                ' Blink the error LED
                call    #poll_waitx
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #.spin
                djnz    hrep, #.spin
        if_c    drvl    host_error_led                  ' Clear the error LED
        if_c    ret                             wc      ' Handle disconnect?
                mov     hrep, #5
                jmp     #.spin

'------------------------------------------------------------------------------
' Post interrupt IN transactions at configured intervals.
'------------------------------------------------------------------------------
poll_kbd
                getct   hct3
                addct3  hct3, _8ms_                     ' Set the timer for next poll interval
                jmp     #\hget_kbd_in_report

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
host_active_led long    57                  ' Client defines the LED pin# for host bus activity
host_error_led  long    56                  ' Client defines the LED pin# to light on error
kb_cur_report_p long    @kb_cur_report
kb_pre_report_p long    @kb_pre_report
urx_buff_p      long    @urx_buff
dev_desc_buff_p long    @dev_desc_buff
con_desc_buff_p long    @con_desc_buff
cache_start_p   long    @usb_cache_start
cache_end_p     long    @usb_cache_end

hdev_init_start
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_next_datax   long    0
kb_max_index    long    0
kb_led_states   long    0
hdev_init_end

hidr_start
hidr_id         long    0
hidr_axis       long    0[3]
hidr_buttons    long    0
hidr_hats       long    0
hidr_flags      long    0
hidr_state      long    0
hidr_size       long    0
hidr_count      long    0
hidr_offset     long    0
hidr_usage      long    0
hidr_usage_idx  long    0
hidr_lminmax    long    0
hidr_pminmax    long    0
hidr_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
poll_target     long    0         ' Address of a subroutine that polls an interrupt IN endpoint
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_ready      long    0         ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_repeat     long    0         ' Key auto-repeat delay threshold
hkbd_scancode   long    0         ' Key scancode
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, #1 << 8            ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    ret
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                ret

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm
                waitx   _21ms_                          ' Hold to let the idle state get settled
                mov     pa, #hreg_init_start            ' Reset all host common registers to startup values
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.regloop
discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
set_poll_target
                mov     poll_target, #0                 ' If unknown device, no interrupt targets
                cmp     hkbd_ep_addr, #0        wz
        if_nz   mov     poll_target, #poll_kbd
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                cmp     poll_target, #0         wz
        if_z    jmp     #.nopoll
                pollct3                         wc
        if_c    call    poll_target                     ' Call the current poll/wait subroutine
.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                'wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
                mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
                jmp     #set_poll_target                ' This addr configs a USB poll transaction and falls thru to hidle

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvh    htmp                            ' Enable the port
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                call    #init_kbdm_data                 ' Reset device data area to start-up values

                mov     ptrb, dev_desc_buff_p
                rdword  htmp, ptrb[4]       ' idVendor
                rdword  hdev_id, ptrb[5]    ' idProduct
                setword hdev_id, htmp, #1
                rdword  hdev_bcd, ptrb[6]   ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                'debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
  if_z_and_c    jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
.keyboard
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.next_intf                     ' No Keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                getbyte kb_in_max_pkt, hr2, #0
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),udec(kb_in_max_pkt,kb_interval))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
'                mov     hkbd_ep_addr, #0                ' DEBUG
'                mov     hmouse_ep_addr, #0              ' DEBUG
                mov     htmp2, #DEV_UNKNOWN
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No boot keyboard or mouse interface
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No keyboard
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hkbd_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     hkbd_repeat, #KBD_REPEAT_DELAY
                mov     htmp2, #KB_READY                ' Keyboard interface configured
.notify_client
        _ret_   mov     hdev_ready, htmp2               ' Save device ready
        '_ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop
        _ret_   mov     kb_next_datax, #PID_DATA0   ' Reset interrupt IN datax sequence PIDs

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, kb_cur_report_p
                setword hpar3, kb_next_datax, #0
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
' The NAK count is used to determine when key auto-repeat kicks in.
                add     hkbd_poll_cnt, #1
                cmp     hkbd_poll_cnt, hkbd_repeat wcz
        if_b    ret                                     ' No auto-repeat action
'                cmp     hkbd_poll_cnt, #KBD_REPEAT_DELAY wz
'        if_z    drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                mov     hpar1, hkbd_scancode    wz      ' Peek at the last key-down scancode
        if_z    mov     hkbd_repeat, #KBD_REPEAT_DELAY  ' Key repeat delay reset on KEY_NO_KEY
        if_z    mov     hkbd_poll_cnt, #0
        if_z    ret
                add     hkbd_repeat, #KBD_REPEAT_RATE   ' Set the next repeat interval
                modc    _clr                    wc      ' Signal key pressed
                rdbyte  hpar2, kb_cur_report_p
                jmp     #\hkbd_translate                ' Repeat the key being held down and return to caller
.data
                drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet
                mov     hpar1, kb_next_datax
                cmp     hpar1, #PID_DATA0       wz
        if_z    mov     hpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     hpar1, #PID_DATA0
                mov     kb_next_datax, hpar1
                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hctrl_ep_addr
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #host_error                     ' FIXME: on !ACK try to recover instead of fatal error
                ret

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, kb_cur_report_p
                mov     ptrb, kb_pre_report_p
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                mov     hkbd_repeat, #KBD_REPEAT_DELAY  ' Report was different than last,
                mov     hkbd_poll_cnt, #0               ' so reset auto-repeat

                mov     hpar1, #0
                rdbyte  hpar2, kb_cur_report_p
                rdbyte  hpar3, kb_pre_report_p
                cmp     hpar2, hpar3    wz
        if_nz   call    #hkbd_translate

.release        modc    _set    wc
                mov     ptra, kb_pre_report_p
                add     ptra, #2
                mov     pa, #6
.rl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.rl3
                mov     ptrb, kb_cur_report_p
                add     ptrb, #2
                mov     pb, #6
.rl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.rl3
                djnz    pb, #.rl2
                mov     hkbd_scancode, #0
                call    #\hkbd_translate
.rl3            djnz    pa, #.rl1

                mov     hpar3, #0
                bith    hpar3, #31

.press          modc    _clr    wc
                mov     ptra, kb_cur_report_p
                add     ptra, #2
                mov     pa, #6
.pl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.pl3
                mov     ptrb, kb_pre_report_p
                add     ptrb, #2
                mov     pb, #6
.pl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.pl3
                djnz    pb, #.pl2
                mov     hkbd_scancode, hpar1
                call    #\hkbd_translate
.pl3            djnz    pa, #.pl1

.copy           mov     ptra, kb_cur_report_p
                mov     ptrb, kb_pre_report_p
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                ret

'------------------------------------------------------------------------------
' Translate keyboard scancode
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - usb scancode
'   hpar2 - key modifiers state
'       c - pressed (0) or released (1) flag
'------------------------------------------------------------------------------
hkbd_translate
                testb   hpar2, #LEFT_SHIFTB wz
        if_x1   mov     htmp, #$2A
        if_x1   jmp     #\hkbd_out_char

                testb   hpar2, #RIGHT_SHIFTB wz
        if_x1   mov     htmp, #$36
        if_x1   jmp     #\hkbd_out_char

                testb   hpar2, #LEFT_CTRLB  wz
                testb   hpar2, #RIGHT_CTRLB orz
        if_x1   mov     htmp, #$1D
        if_x1   jmp     #\hkbd_out_char

                testb   hpar2, #LEFT_ALTB  wz
                testb   hpar2, #RIGHT_ALTB orz
        if_x1   mov     htmp, #$38
        if_x1   jmp     #\hkbd_out_char

                mov     htmp, hpar1
                add     htmp, ##@kbd_table
                rdbyte  htmp, htmp      wz
        if_z    ret

hkbd_out_char
                'debug(uhex_byte(hpar1),ubin_byte(hpar2),uhex_byte(htmp))
                bitc    htmp, #7
                rdbyte  pa, #@kbd_head
                add     pa, #@kbd_buffer
                wrbyte  htmp, pa
                sub     pa, #@kbd_buffer
                incmod  pa, #7
        _ret_   wrbyte  pa, #@kbd_head

kbd_table ' Index is the key scan code
          {$00} byte    $00, $00, $00, $00                      ' $03
          {$04} byte    $1E, $30, $2E, $20                      ' $07: a b c d
          {$08} byte    $12, $21, $22, $23, $17, $24, $25, $26  ' $0f: e f g h i j k l
          {$10} byte    $32, $31, $18, $19, $10, $13, $1F, $14  ' $17: m n o p q r s t
          {$18} byte    $16, $2F, $11, $2D, $15, $2C, $02, $03  ' $1f: u v w x y z 1 2
          {$20} byte    $04, $05, $06, $07, $08, $09, $0A, $0B  ' $27: 3 4 5 6 7 8 9 0
          {$28} byte    $1C, $01, $0E, $0F, $39, $0C, $0D, $1A  ' $2f: Enter Esc BkSpc Tab Spc - = [
          {$30} byte    $1B, $00, $2B, $27, $28, $29, $33, $34  ' $37: ] \ # ; ' ` , .
          {$38} byte    $35, $3A, $3B, $3C, $3D, $3E, $3F, $40  ' $3f: / CapsLock F1 F2 F3 F4 F5 F6
          {$40} byte    $41, $42, $43, $44, $00, $00, $37, $46  ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
          {$48} byte    $00, $52, $47, $49, $53, $4F, $51, $4D  ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
          {$50} byte    $4B, $50, $4C, $45, $35, $00, $4A, $4E  ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
          {$58} byte    $1C, $00, $00, $00, $00, $4C, $00, $00  ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
          {$60} byte    $00, $00, $00, $00, $56, $00            ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' Keyboard report buffers
kb_cur_report   byte    0[KBD_IN_RPT_LEN]
kb_pre_report   byte    0[KBD_IN_RPT_LEN]

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, GP_READY
    XINPUT_READY, PS3_READY, DEV_DISCONNECT, DBG_DATA, K_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
    #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
    LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
    LED_NUMLKF   = decod(LED_NUMLKB)
    LED_CAPSLKF  = decod(LED_CAPSLKB)
    LED_SCRLKF   = decod(LED_SCRLKB)
    LED_COMPOSEF = decod(LED_COMPOSEB)
    LED_KANAF    = decod(LED_KANAB)
    LED_CONST0F  = decod(LED_CONST0B)
    LED_CONST1F  = decod(LED_CONST1B)
    LED_CONST2F  = decod(LED_CONST2B)
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' Keyboard and mouse constants:
'------------------------------------------------------------------------------
' Keyboard interrupt endpoint poll interval and auto-repeat timing. Since the
' interrupt IN transactions are executed on a timed basis, use that to
' calculate auto-repeat initial delay and repeat rate.
'------------------------------------------------------------------------------
'    KBD_POLL_INTERVAL = _1ms * 8            ' Interrupt IN txn timespan
    KBD_REPEAT_DELAY  = 62                  ' 62 * 8ms = 496ms initial delay
    KBD_REPEAT_RATE   = 10                  ' 10 * 8ms = 80ms repeat rate
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' HID Report Items from HID 1.11 Section 6.2.2
    HID_USAGE_PAGE      = $04
    HID_USAGE           = $08
    HID_COLLECTION      = $A0
    HID_END_COLLECTION  = $C0
    HID_REPORT_COUNT    = $94
    HID_REPORT_SIZE     = $74
    HID_USAGE_MIN       = $18
    HID_USAGE_MAX       = $28
    HID_LOGICAL_MIN     = $14
    HID_LOGICAL_MAX     = $24
    HID_PHYSICAL_MIN    = $34
    HID_PHYSICAL_MAX    = $44
    HID_INPUT           = $80
    HID_REPORT_ID       = $84
    HID_OUTPUT          = $90

' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
    HID_USAGE_PAGE_GENERIC_DESKTOP = $01
    HID_USAGE_PAGE_KEY_CODES       = $07
    HID_USAGE_PAGE_LEDS            = $08
    HID_USAGE_PAGE_BUTTONS         = $09

' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
    HID_USAGE_POINTER   = $01
    HID_USAGE_MOUSE     = $02
    HID_USAGE_JOYSTICK  = $04
    HID_USAGE_GAMEPAD   = $05
    HID_USAGE_KEYBOARD  = $06
    HID_USAGE_X         = $30
    HID_USAGE_Y         = $31
    HID_USAGE_Z         = $32
    HID_USAGE_RX        = $33
    HID_USAGE_RY        = $34
    HID_USAGE_RZ        = $35
    HID_USAGE_SLIDER    = $36
    HID_USAGE_WHEEL     = $38
    HID_USAGE_HATSWITCH = $39

' HID Report Collection Types from HID 1.12 6.2.2.6
    HID_COLLECTION_PHYSICAL    = 0
    HID_COLLECTION_APPLICATION = 1

' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
    HID_ITEM_CONSTANT = $1
    HID_ITEM_VARIABLE = $2
    HID_ITEM_RELATIVE = $4

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
' Gamepad report and descriptor data buffer lengths:
    HID_IN_RPT_LEN   = 256
    HID_DESCR_LEN    = 256

' Gamepad axes flag bits
    HID_AXIS_X   = 16+0
    HID_AXIS_Y   = 16+1
    HID_AXIS_Z   = 16+2
    HID_AXIS_RX  = 16+3
    HID_AXIS_RY  = 16+4
    HID_AXIS_RZ  = 16+5

DAT             ' CGA
                org     $000

video_driver
                setcmod #%01_0_000_1            ' enable colorspace conversion
                '                  ^------------- horizontal polarity (1=negative, 0=positive)
                setcy   ##CGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##CGA_INTENSITY << 16   ' g
                setcq   ##CGA_INTENSITY << 08   ' b
                setxfrq cga_xf                  ' set transfer frequency

                cogid   pa                      ' insert cogid into dac modes
                setnib  cga_dacmode_s, pa, #2
                setnib  cga_dacmode_c, pa, #2

                wrpin   cga_dacmode_s, cga_pin_base ' enable 123-ohm 3.3V dac mode in pin +0

                xor     cga_pin_base, #2 << 6 | 1   ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   cga_dacmode_c, cga_pin_base

                xor     cga_pin_base, #3 << 6 ^ (2 << 6 | 1) ' make pins +0..3 outputs
                drvl    cga_pin_base

                xor     cga_pin_base, #4 | (3 << 6) ' leave av_base pointing to pin +4 (vertical sync)
                drvl    cga_pin_base                ' vertical polarity (drvh=negative, drvl=positive)

.frame_loop
                rdbyte  cga_03D8, #@cga_io_03D8 ' Mode Select Register
                rdbyte  cga_03D9, #@cga_io_03D9 ' Color Select Register

                testb   cga_03D8, #CGA_MODE_ENABLE  wz
        if_x0   setword cga_flags, #cga_blank, #0
        if_x0   jmp     #.end_config

                testb   cga_03D8, #CGA_MODE_GRAPH   wz
        if_x0   jmp     #.text_mode

                getnib  cga_lut0, cga_03D9, #0
                altd    cga_lut0, #cga_palette
                wrlut   0-0, #0 ' Background

                testb   cga_03D8, #CGA_MODE_640     wz
        if_x1   jmp     #.graphics_640x200

                testb   cga_03D9, #CGA_COLOR_BLUE   wz
        if_x0   mov     cga_lut1, cga_palette + %0010 ' Green
        if_x0   mov     cga_lut2, cga_palette + %0100 ' Red
        if_x0   mov     cga_lut3, cga_palette + %0110 ' Brown
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0101 ' Light Magenta
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White
                testb   cga_03D8, #CGA_MODE_CBURST  wz
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0100 ' Light Red
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White

                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x1   add     cga_lut1, #%1000
        if_x1   add     cga_lut2, #%1000
        if_x1   add     cga_lut3, #%1000
                wrlut   cga_lut1, #1
                wrlut   cga_lut2, #2
                wrlut   cga_lut3, #3

                setword cga_flags, #cga_graphics_320x200, #0

                jmp     #.end_config

.graphics_640x200
                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x0   wrlut   cga_palette + %0111, #1 ' White
        if_x1   wrlut   cga_palette + %1111, #1 ' White

                setword cga_flags, #cga_graphics_640x200, #0

                jmp     #.end_config

.text_mode
                rdbyte  cga_mc6845_10, #@cga_io_mc6845 + 10 ' cursor start scanline
                rdbyte  cga_mc6845_11, #@cga_io_mc6845 + 11 ' cursor end scanline

                testb   cga_03D8, #CGA_MODE_80COL   wz
        if_x0   setword cga_flags, #cga_text_40x25, #0
        if_x1   setword cga_flags, #cga_text_80x25, #0

.end_config
                incmod  cga_bcnt, #32       wc
        if_c    bitnot  cga_flags, #CGA_BLINK1_ON

                testb   cga_mc6845_10, #5   wz
        if_x0   incmod  cga_ccnt, #16 - 1   wc
        if_x1   incmod  cga_ccnt, #32 - 1   wc
        if_c    bitnot  cga_flags, #CGA_BLINK2_ON
                testb   cga_mc6845_10, #6   wc
        if_0x   bitnz   cga_flags, #CGA_BLINK2_ON

                and     cga_mc6845_10, #%000_11111
                and     cga_mc6845_11, #%000_11111

                rdword  cga_ramptr, #@cga_io_mc6845 + 12 ' start of displayed page
                movbyts cga_ramptr, #%%3301
                and     cga_ramptr, ##%00_111111_11111111
                add     cga_ramptr, cga_ram_p

                rdword  cga_cpos, #@cga_io_mc6845 + 14  ' cursor offset address in vid mem
                movbyts cga_cpos, #%%3301
                and     cga_cpos, ##%00_111111_11111111

                mov     cga_cptr, #0
                mov     cga_lcnt, #200

.line_loop
                bith    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_10 wcz
        if_b    bitl    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_11 wcz
        if_a    bitl    cga_flags, #CGA_CURSOR_SCANLINE

                call    cga_flags
                djnz    cga_lcnt, #.line_loop

                bith    cga_03DA, #3
                wrbyte  cga_03DA, #@cga_io_03DA
                callpa  #12, #.blank                ' front porch

                drvnot  cga_pin_base                ' vertical sync on
                callpa  #2, #.blank
                drvnot  cga_pin_base                ' vertical sync off

                callpa  #35, #.blank                ' back porch
                bitl    cga_03DA, #3
                wrbyte  cga_03DA, #@cga_io_03DA

                jmp     #.frame_loop

.blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line
        _ret_   djnz    pa, #.blank                 ' loop if more blanks needed

' Blank Screen

cga_blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
        _ret_   xcont   cga_db, #0                  ' do visible part of scan line

' Text 80x25

cga_text_80x25
                call    #cga_emit_line80
                sub     cga_cptr, #80
                call    #cga_emit_line80
                sub     cga_cptr, #80

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1   wc
        if_c    add     cga_cptr, #80
        if_c    add     cga_ramptr, #80 * 2
        if_c    sub     cga_chr_p, #8

                ret

cga_emit_line80
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #80 / 4
.loop
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv8, #%0000, #4

                rep     @.reploop, #4

                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0
                rev     cga_bmp
                shr     cga_bmp, #24

                bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0 - 0, cga_lut0             '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0 - 0, cga_lut1    '
                xcont   cga_dv8, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv8, ##$1_0000
.reploop
        _ret_   djnz    pa, #.loop

' Text 40x25

cga_text_40x25
                call    #cga_emit_line40
                sub     cga_cptr, #40
                call    #cga_emit_line40
                sub     cga_cptr, #40

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1    wc
        if_c    add     cga_cptr, #40
        if_c    add     cga_ramptr, #40 * 2
        if_c    sub     cga_chr_p, #8

                ret

cga_emit_line40
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #40 / 4
.loop
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv16, #%0000, #4

                rep     @.reploop, #4

                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0
                rev     cga_bmp
                shr     cga_bmp, #24

                bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                setword cga_bmp, cga_bmp, #1
                mergew  cga_bmp

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut0               '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut1               '
                xcont   cga_dv16, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv16, ##$1_0000
.reploop
        _ret_   djnz    pa, #.loop

' Graphics 320x200x2bpp

cga_graphics_320x200
                mov     pb, #2
.loop2
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #320 / 4
.loop1
                rfbyte  cga_tmp0
                testb   cga_tmp0, #7  wc
                testb   cga_tmp0, #6  wz
                muxc    cga_bmp, cga_muxc00
                muxz    cga_bmp, cga_muxz00

                testb   cga_tmp0, #5  wc
                testb   cga_tmp0, #4  wz
                muxc    cga_bmp, cga_muxc11
                muxz    cga_bmp, cga_muxz11

                testb   cga_tmp0, #3  wc
                testb   cga_tmp0, #2  wz
                muxc    cga_bmp, cga_muxc22
                muxz    cga_bmp, cga_muxz22

                testb   cga_tmp0, #1  wc
                testb   cga_tmp0, #0  wz
                muxc    cga_bmp, cga_muxc33
                muxz    cga_bmp, cga_muxz33

                xcont   cga_dv8b, cga_bmp
                djnz    pa, #.loop1

                djnz    pb, #.loop2

        _ret_   add     cga_ramptr, #320 / 4

cga_muxc00      long    %0000__0000__0000__1010
cga_muxz00      long    %0000__0000__0000__0101
cga_muxc11      long    %0000__0000__1010__0000
cga_muxz11      long    %0000__0000__0101__0000
cga_muxc22      long    %0000__1010__0000__0000
cga_muxz22      long    %0000__0101__0000__0000
cga_muxc33      long    %1010__0000__0000__0000
cga_muxz33      long    %0101__0000__0000__0000

' Graphics 640x200x1bpp

cga_graphics_640x200
                mov     pb, #2
.loop2
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #640 / 8
.loop1
                rfbyte  cga_bmp
                rev     cga_bmp
                shr     cga_bmp, #24
                xcont   cga_dv8, cga_bmp
                djnz    pa, #.loop1

                djnz    pb, #.loop2

        _ret_   add     cga_ramptr, #640 / 8

cga_reg_p       long    0
cga_ram_p       long    @ram_00000 + RAM_SIZE
cga_chr_p       long    @cga_charrom

cga_03D8        long    0
cga_03D9        long    0
cga_03DA        long    0

cga_mc6845_10   long    0
cga_mc6845_11   long    0

cga_palette
                                    ' h rgb
                long    $000000_00  ' 0 000     0
                long    $0000AA_00  ' 0 001     1
                long    $00AA00_00  ' 0 010     2
                long    $00AAAA_00  ' 0 011     3
                long    $AA0000_00  ' 0 100     4
                long    $AA00AA_00  ' 0 101     5
                long    $AA5500_00  ' 0 110     6
                long    $AAAAAA_00  ' 0 111     7
                long    $555555_00  ' 1 000     8
                long    $5555FF_00  ' 1 001     9
                long    $55FF55_00  ' 1 010     A
                long    $55FFFF_00  ' 1 011     B
                long    $FF5555_00  ' 1 100     C
                long    $FF55FF_00  ' 1 101     D
                long    $FFFF55_00  ' 1 110     E
                long    $FFFFFF_00  ' 1 111     F

cga_pin_base    long    VGA_PIN & $38                    ' base pin
cga_dacmode_s   long    P_DAC_124R_3V + P_CHANNEL        ' hsync is 123-ohm, 3.3V
cga_dacmode_c   long    P_DAC_75R_2V + P_CHANNEL         ' R/G/B are 75-ohm, 2.0V

cga_xf          long    (CGA_FPIX frac _CLKFREQ) >> 1           ' streamer frequency setting
cga_bs          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  16 ' streamer command: before-sync
cga_ds          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  96 ' streamer command: during-sync
cga_as          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  48 ' streamer command: after sync
cga_db          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 640 ' streamer command: during-blank

cga_dv8         long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv8b        long    X_IMM_16X2_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv16        long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 16 ' streamer command: during visible

cga_cpos        long    0               ' cursor position (from MC6845)
cga_flags       long    cga_blank       ' 31..20 flags
                                        '  19..0 line handler routine

cga_cptr        long    0
cga_ramptr      long    0

cga_chattr      long    0
cga_bmp         long    0
cga_lut0        long    0
cga_lut1        long    0
cga_lut2        long    0
cga_lut3        long    0

cga_bcnt        long    0
cga_ccnt        long    0
cga_lcnt        long    0
cga_lofs        long    0

cga_tmp0        res     1

CON ' CGA constants

    CGA_FPIX = 25_175_000
    CGA_INTENSITY = 80      '0..128

    CGA_BLINK1_ON = 31
    CGA_BLINK2_ON = 30
    CGA_CURSOR_SCANLINE = 29

    CGA_MODE_80COL  = 0
    CGA_MODE_GRAPH  = 1
    CGA_MODE_CBURST = 2
    CGA_MODE_ENABLE = 3
    CGA_MODE_640    = 4
    CGA_MODE_BLINK  = 5

    CGA_COLOR_BG    = %00_001111
    CGA_COLOR_HIGH  = 4
    CGA_COLOR_BLUE  = 5

DAT             ' 8086
                org     $000

i8086
                add     ptrb, ##@i8086_lut - @i8086
                setq2   #(@i8086_lut_end - @i8086_lut) / 4 -1
                rdlong  0, ptrb

                call    #\system_init

i_nextop
                mov     i_cycles, #0
                mov     i_override, #0

                call    #\system_run

                testb   i_flags, #I_TF_BIT      wz
        if_x1   mov     i_temp0, #1
        if_x1   jmp     #\i_trap

i_next
                call    #\i_readop
                push    #i_nextop
                execf   i_opimpl

i_readop
                call    #\i_readcodeb
                mov     i_opcode, i_tmpb
                shl     i_tmpb, #2
                add     i_tmpb, i_optable
        _ret_   rdlong  i_opimpl, i_tmpb

i_seg_cs        mov     i_override, i_cs        ' a         a:cs %001110
i_seg_ds        mov     i_override, i_ds        ' | b       b:ds %00110_
i_seg_es        mov     i_override, i_es        ' | | c     c:es %0010__
i_seg_ss        mov     i_override, i_ss        ' | | | d   d:ss %000___
                bith    i_override, #31         ' a b c d
                jmp     #\i_next                ' a b c d

i_repne
                call    #\i_readop
                mov     i_rep_cnt, i_cx     wz
        if_z    ret
                cmp     i_opcode, #$A6      wz
        if_nz   cmp     i_opcode, #$A7      wz
        if_nz   cmp     i_opcode, #$AE      wz
        if_nz   cmp     i_opcode, #$AF      wz
        if_nz   jmp     #\i_rep_loop
i_repne_loop
.loop           push    #.ret
                execf   i_opimpl
.ret            testb   i_flags, #I_ZF_BIT  wz
        if_x0   djnz    i_rep_cnt, #.loop
        _ret_   getword i_cx, i_rep_cnt, #0

i_repe
                call    #\i_readop
                mov     i_rep_cnt, i_cx     wz
        if_z    ret
                cmp     i_opcode, #$A6      wz
        if_nz   cmp     i_opcode, #$A7      wz
        if_nz   cmp     i_opcode, #$AE      wz
        if_nz   cmp     i_opcode, #$AF      wz
        if_nz   jmp     #\i_rep_loop
i_repe_loop
.loop           push    #.ret
                execf   i_opimpl
.ret            testb   i_flags, #I_ZF_BIT  wz
        if_x1   djnz    i_rep_cnt, #.loop
        _ret_   getword i_cx, i_rep_cnt, #0

i_rep_loop
.loop           push    #.ret
                execf   i_opimpl
.ret            djnz    i_rep_cnt, #.loop
        _ret_   getword i_cx, i_rep_cnt, #0

i_branch_rmod
                call    #\i_setupea             '         e f g h   e:jmp_ip    %01_1_1111_11_11_11000
                call    #\i_readw               '         e f g h   f:jmp_csip  %00_1_1111_11_11_00000
                getword i_data0, i_data, #0     '         e f g h   g:call_ip   %01_1_0011_11_11_11000
                call    #\i_readw               '         | f | h   h:call_csip %00_1_0000_11_11_00000
                getword i_data1, i_data, #0     '         | f | h
i_branch
                call    #\i_readimmw            ' a b c d | | | |   a:jmp_far   %00_1_1111_00_00
                getword i_data0, i_data, #0     ' a b c d | | | |   b:jmp_ofs   %01_0_1111_11_00
                                                '                   c:call_far  %00_1_0000_00_00
                call    #\i_readimmw            ' a | c | | | | |   d:call_ofs  %01_0_0011_11_00
                getword i_data1, i_data, #0     ' a | c | | | | |

                getword i_data, i_cs, #0        ' | | c | | | | h
                call    #\i_push                ' | | c | | | | h
                getword i_data, i_ip, #0        ' | | c d | | g h
                call    #\i_push                ' | | c d | | g h

                add     i_data0, i_ip           ' | b | d | | | |

                getword i_cs, i_data1, #0       ' a | c | | f | h
        _ret_   getword i_ip, i_data0, #0       ' a b c d e f g h

i_ret_d16
                call    #\i_readimmw            '   b   d
                mov     i_data0, i_data         '   b   d
i_ret                                           '
                call    #\i_pop                 ' a b c d e     a:ret      %01_11_11_00
                getword i_ip, i_data, #0        ' a b c d e     b:ret_d16  %00_11_11_00_00
                                                '               c:retf     %01_11_00_00
                call    #\i_pop                 ' | | c d e     d:retf_d16 %00_11_00_00_00
                getword i_cs, i_data, #0        ' | | c d e     e:iret     %01_00_00_00

                call    #\i_pop                 ' | | | | e
                setword i_flags, i_data, #0     ' | | | | e

                add     i_sp, i_data0           ' | b | d |
                getword i_sp, i_sp, #0          ' a b c d e
                jmp     #\i_next

i_jmp_d8
                call    #\i_readcodeb               ' a b c d e f g h i j k l m n o p q  a=jmp
                signx   i_tmpb, #7                  ' a b c d e f g h i j k l m n o p q  b=jo   (OF)
                modz    _set                wz      ' a | | | | | | | | | | | | | | | |  c=jno  (!OF)
                testb   i_flags, #I_OF_BIT  wz      ' | b c | | | | | | | | | | | | | |  d=jc   (CF)
                testb   i_flags, #I_CF_BIT  wz      ' | | | d e | | h i | | | | | | | |  e=jnc  (!CF)
                testb   i_flags, #I_ZF_BIT  wz      ' | | | | | f g | | | | | | | | | |  f=jz   (ZF)
                testb   i_flags, #I_SF_BIT  wz      ' | | | | | | | | | j k | | n o p q  g=jnz  (!ZF)
                testb   i_flags, #I_PF_BIT  wz      ' | | | | | | | | | | | l m | | | |  h=jce  (CF | ZF)
                testb   i_flags, #I_OF_BIT  wc      ' | | | | | | | | | | | | | n o p q  i=jnce (!(CF | ZF))
                modz    _z_ne_c             wz      ' | | | | | | | | | | | | | n | p |  j=js   (SF)
                modz    _z_eq_c             wz      ' | | | | | | | | | | | | | | o | q  k=jns  (!SF)
                testb   i_flags, #I_ZF_BIT  orz     ' | | | | | | | h i | | | | | | p |  l=jp   (PF)
                testbn  i_flags, #I_ZF_BIT  orz     ' | | | | | | | | | | | | | | | | |  m=jnp  (!PF)
                testbn  i_flags, #I_ZF_BIT  andz    ' | | | | | | | | | | | | | n | | q  n=jl   ((SF!=OF)&&(!ZF))
                modz    _nz                 wz      ' | | c | e | g | i | k | m | | | |  o=jnl  (SF==OF)
        if_x1   add     i_ip, i_tmpb                ' a b c d e f g h i j k l m n o p q  p=jle  ((ZF)||(SF!=OF))
        _ret_   getword i_ip, i_ip, #0              '                                    q=jnle ((SF==OF)&&(!ZF))

i_readcodeb
                getword i_ea, i_cs, #0
                shl     i_ea, #4
                add     i_ea, i_ip
                incmod  i_ip, i_ffffh
                jmp     #\i_readmemb

i_readimmw
                call    #\i_readcodeb
                getbyte i_data, i_tmpb, #0
                call    #\i_readcodeb
        _ret_   setbyte i_data, i_tmpb, #1

i_rotshift
                call    #\i_setupmodrm               ' a b c d  a:roshiftb     %00_0010000_10_10_0
                                                     '          b:roshiftbcl   %00_0010000_10_01_0
                mov     i_rep_cnt, #1                ' a | c |  c:roshiftw   %0011_0001000_01_10_0
                getbyte i_rep_cnt, i_cx, #0          ' | b | d  d:roshiftwcl %0011_0001000_01_01_0
                                                     '
                call    #\i_readopb                  ' a b | |
                call    #\i_readopw                  ' | | c d

                mov     pa, i_modrm                  ' a b c d
                shr     pa, #3                       ' a b c d
                and     pa, #7                       ' a b c d
                add     pa, #i_rotshift8_tbl - $200  ' a b | |
                add     pa, #i_rotshift16_tbl - $200 ' | | c d
                rdlut   i_opimpl, pa                 ' a b c d
                call    #\i_rep_opimpl               ' a b c d

                call    #\i_writeopb                 ' a b | |
                jmp     #\i_flags8                   ' a b | |
                call    #\i_writeopw                 '     c d
                jmp     #\i_flags16                  '     c d

i_rep_opimpl
.loop           push    #.ret
                execf   i_opimpl
.ret    _ret_   djnz    i_rep_cnt, #.loop

i_math_pre
                call    #\i_setupmodrm          ' a b c d   a:80pre   %00000_11100_10_0
                ' dst(r)                        ' a b c d   b:81pre %0011000_10000_01_0
                call    #\i_readopb             ' a | c |   c:82pre   %00000_01100_10_0
                call    #\i_readopw             ' | b | d   d:83pre %0011000_01100_01_0
                ' src(r)                        '
                call    #\i_readcodeb           ' a b c d
                getbyte i_data1, i_tmpb, #0     ' a b c d
                call    #\i_readcodeb           ' | b | |
                setbyte i_data1, i_tmpb, #1     ' | b | |
                signx   i_data1, #7             ' | | c d
                ' operation
                mov     pb, i_modrm             ' a b c d
                shr     pb, #3                  ' a b c d
                and     pb, #7                  ' a b c d
                altd    pb, #i_math8_pre_tbl    ' a | c |
                execf   0-0                     ' a | c |
                altd    pb, #i_math16_pre_tbl   '   b   d
                execf   0-0                     '   b   d
i_math8_pre_tbl
                long    i_mathop8_op   |     %001_11111010_0 << 10 ' ADD
                long    i_mathop8_op   |     %001_11011111_0 << 10 ' OR
                long    i_mathop8_op   |     %001_11111001_0 << 10 ' ADC
                long    i_mathop8_op   |     %001_11110101_0 << 10 ' SBB
                long    i_mathop8_op   |     %001_11101111_0 << 10 ' AND
                long    i_mathop8_op   |     %001_11110110_0 << 10 ' SUB
                long    i_mathop8_op   |     %001_10111111_0 << 10 ' XOR
                long    i_mathop8_op   |     %011_11110110_0 << 10 ' CMP
i_math16_pre_tbl
                long    i_mathop16_op  |     %001_11111010_0 << 10 ' ADD
                long    i_mathop16_op  |     %001_11011111_0 << 10 ' OR
                long    i_mathop16_op  |     %001_11111001_0 << 10 ' ADC
                long    i_mathop16_op  |     %001_11110101_0 << 10 ' SBB
                long    i_mathop16_op  |     %001_11101111_0 << 10 ' AND
                long    i_mathop16_op  |     %001_11110110_0 << 10 ' SUB
                long    i_mathop16_op  |     %001_10111111_0 << 10 ' XOR
                long    i_mathop16_op  |     %011_11110110_0 << 10 ' CMP

i_loop
                call    #\i_readcodeb               ' a b c   a = loop    %00_11_000
                signx   i_tmpb, #7                  ' a b c   b = loope   %00_10_000
                decmod  i_cx, i_ffffh       wz      ' a b c   c = loopne  %00_01_000
                testb   i_flags, #I_ZF_BIT  andz    ' | b |
                testbn  i_flags, #I_ZF_BIT  andz    ' | | c
        if_nz   add     i_ip, i_tmpb                ' a b c
        _ret_   getword i_ip, i_ip, #0              ' a b c

i_jcxz
                call    #\i_readcodeb
                signx   i_tmpb, #7
                cmp     i_cx, #0            wz
        if_z    add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_lea
                call    #\i_setupmodrm
                getword i_data, i_offset, #0
                jmp     #\i_setmodr16

i_ff_impl
                call    #\i_readopw             ' a b c   a:inc_rm16  %000_100_1_00
                getword i_data0, i_data, #0     ' a b |   b:dec_rm16  %000_010_1_00
                                                '         c:push_rm16         %0_10
                jmp     #\i_push                ' | | c

                mov     i_data1, #1             ' a b
                add     i_data, i_data1         ' a |
                sub     i_data, i_data1         ' | b

                sub     i_ea, #2                ' a a
                call    #\i_writeopw            ' a b
                jmp     #\i_flags16             ' a b

i_movsb
                push    #.ret
                execf   i_movsb_impl
.ret            execf   i_movsb_impl+1

i_movsb_impl    long    i_lods | %0010_11_10_00000 << 10
                long    i_stos | %0010_10_11_000   << 10

i_movsw
                push    #.ret
                execf   i_movsw_impl
.ret            execf   i_movsw_impl+1

i_movsw_impl    long    i_lods | %0000_11_01_00000 << 10
                long    i_stos | %0000_01_11_000__ << 10

' +-----+---------------+------------------+-------------------+---------+---------+
' | mod |      00       |       01         |        10         |   11    |         |
' +-----+---------------+------------------+-------------------+---------+---------+
' | r/m |               |                  |                   |         |   reg   |
' +-----+---------------+------------------+-------------------+---------+----+----+
' | 000 | [DS:BX+SI]    | [DS:BX+SI+disp8] | [DS:BX+SI+disp16] | [DS:AX] | AL | AX |
' | 001 | [DS:BX+DI]    | [DS:BX+DI+disp8] | [DS:BX+DI+disp16] | [DS:CX] | CL | CX |
' | 010 | [SS:BP+SI]    | [SS:BP+SI+disp8] | [SS:BP+SI+disp16] | [DS:DX] | DL | DX |
' | 011 | [SS:BP+DI]    | [SS:BP+DI+disp8] | [SS:BP+DI+disp16] | [DS:BX] | BL | BX |
' | 100 | [DS:SI]       | [DS:SI+disp8]    | [DS:SI+disp16]    | [DS:SP] | AH | SP |
' | 101 | [DS:DI]       | [DS:DI+disp8]    | [DS:DI+disp16]    | [DS:BP] | CH | BP |
' | 110 | [DS:disp16]   | [SS:BP+disp8]    | [SS:BP+disp16]    | [DS:SI] | DH | SI |
' | 111 | [DS:BX]       | [DS:BX+disp8]    | [DS:BX+disp16]    | [DS:DI] | BH | DI |
' +-----+---------------+------------------+-------------------+---------+----+----+

'   setup i_ea based on i_modrm bits

i_setupmodrm
                call    #\i_readcodeb
                mov     i_modrm, i_tmpb
                getword i_segment, i_ds, #0
                mov     i_offset, #0
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
                mov     i_modrm0, i_modrm
                and     i_modrm0, #%00_000_111
        if_00   call    #\_mod00
        if_01   call    #\_mod01
        if_10   call    #\_mod10
        if_11   call    #\_mod11
        _ret_   getword i_offset, i_offset, #0

i_setupea
                cmp     i_override, #0      wz
        if_nz   getword i_ea, i_override, #0
        if_z    getword i_ea, i_segment, #0
                shl     i_ea, #4
        _ret_   add     i_ea, i_offset

_mod00
                altgw   i_modrm0, #i_modrm_00
                getword i_modrm0
                jmp     i_modrm0
_mod01
                call    #\i_readcodeb
                signx   i_tmpb, #7
                add     i_offset, i_tmpb
                jmp     #_modxx
_mod10
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
                add     i_offset, i_temp0
_modxx
                altgw   i_modrm0, #i_modrm_xx
                getword i_modrm0
                jmp     i_modrm0
_mod11
                jmprel  i_modrm0
        _ret_   getword i_offset, i_ax, #0
        _ret_   getword i_offset, i_cx, #0
        _ret_   getword i_offset, i_dx, #0
        _ret_   getword i_offset, i_bx, #0
        _ret_   getword i_offset, i_sp, #0
        _ret_   getword i_offset, i_bp, #0
        _ret_   getword i_offset, i_si, #0
        _ret_   getword i_offset, i_di, #0

i_modrm_00      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_00_xxx_110, i_modrm_00_xxx_111

i_modrm_xx      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_xx_xxx_110, i_modrm_00_xxx_111

i_modrm_00_xxx_000
                add     i_offset, i_bx
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_001
                add     i_offset, i_bx
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_010
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_011
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_100
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_101
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_110
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
        _ret_   add     i_offset, i_temp0
i_modrm_00_xxx_111
        _ret_   add     i_offset, i_bx

i_modrm_xx_xxx_110
                getword i_segment, i_ss, #0
        _ret_   add     i_offset, i_bp

' get 8-bit register based on i_modrm bits 5..3

i_getmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_getr8
                and     pa, #7
                jmprel  pa
        _ret_   getbyte i_data, i_ax, #0
        _ret_   getbyte i_data, i_cx, #0
        _ret_   getbyte i_data, i_dx, #0
        _ret_   getbyte i_data, i_bx, #0
        _ret_   getbyte i_data, i_ax, #1
        _ret_   getbyte i_data, i_cx, #1
        _ret_   getbyte i_data, i_dx, #1
        _ret_   getbyte i_data, i_bx, #1

' get 16-bit register based on i_modrm bits 5..3

i_getmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_getr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_data, i_ax, #0
        _ret_   getword i_data, i_cx, #0
        _ret_   getword i_data, i_dx, #0
        _ret_   getword i_data, i_bx, #0
        _ret_   getword i_data, i_sp, #0
        _ret_   getword i_data, i_bp, #0
        _ret_   getword i_data, i_si, #0
        _ret_   getword i_data, i_di, #0


' set 8-bit register based on i_modrm bits 5..3

i_setmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_setr8
                and     pa, #7
                jmprel  pa
        _ret_   setbyte i_ax, i_data, #0
        _ret_   setbyte i_cx, i_data, #0
        _ret_   setbyte i_dx, i_data, #0
        _ret_   setbyte i_bx, i_data, #0
        _ret_   setbyte i_ax, i_data, #1
        _ret_   setbyte i_cx, i_data, #1
        _ret_   setbyte i_dx, i_data, #1
        _ret_   setbyte i_bx, i_data, #1

' set 16-bit register based on i_modrm bits 5..3

i_setmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_setr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_ax, i_data, #0
        _ret_   getword i_cx, i_data, #0
        _ret_   getword i_dx, i_data, #0
        _ret_   getword i_bx, i_data, #0
        _ret_   getword i_sp, i_data, #0
        _ret_   getword i_bp, i_data, #0
        _ret_   getword i_si, i_data, #0
        _ret_   getword i_di, i_data, #0

' get segment register based on i_modrm bits 5..3

i_getmodsreg
                mov     pb, i_modrm
                shr     pb, #3
                and     pb, #3
                jmprel  pb
        _ret_   getword i_data, i_es, #0
        _ret_   getword i_data, i_cs, #0
        _ret_   getword i_data, i_ss, #0
        _ret_   getword i_data, i_ds, #0

' set segment register based on i_modrm bits 5..3

i_setmodsreg
                mov     pb, i_modrm
                shr     pb, #3
                and     pb, #3
                jmprel  pb
        _ret_   getword i_es, i_data, #0
        _ret_   getword i_cs, i_data, #0
        _ret_   getword i_ss, i_data, #0
        _ret_   getword i_ds, i_data, #0

i_mov_sreg
                call    #\i_setupmodrm          ' a b   a:mov sreg, [rm]     %000_0000
                testb   i_modrm, #7         wc  ' a b   b:mov [rm], sreg %000_111_0000
                testb   i_modrm, #6         wz  ' a b
                mov     pa, i_modrm             ' a b

        if_11   call    #\i_getr16              ' a |
    if_not_11   call    #\i_readopw             ' a |
                jmp     #\i_setmodsreg          ' a |

                call    #\i_getmodsreg          '   b
        if_11   jmp     #\i_setr16              '   b
                jmp     #\i_writeopw            '   b

' --------------------------------------------------------------------

i_readopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr8
                call    #\i_setupea
                call    #\i_readmemb
        _ret_   getbyte i_data, i_tmpb, #0

i_writeopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr8
                call    #\i_setupea
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

' --------------------------------------------------------------------

i_readopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr16
                call    #\i_setupea
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readmemb
        _ret_   setbyte i_data, i_tmpb, #1

i_writeopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr16
                call    #\i_setupea
                getbyte i_tmpb, i_data, #0
                call    #\i_writememb
                add     i_ea, #1
                getbyte i_tmpb, i_data, #1
                jmp     #\i_writememb

' --------------------------------------------------------------------

i_cmc   _ret_   bitnot  i_flags, #I_CF_BIT
i_clc   _ret_   bitl    i_flags, #I_CF_BIT
i_stc   _ret_   bith    i_flags, #I_CF_BIT
i_cli   _ret_   bitl    i_flags, #I_IF_BIT
i_sti   _ret_   bith    i_flags, #I_IF_BIT
i_cld   _ret_   bitl    i_flags, #I_DF_BIT
i_std   _ret_   bith    i_flags, #I_DF_BIT

i_cbw
                signx   i_ax, #7
        _ret_   getword i_ax, i_ax, #0

i_cwd
                testb   i_ax, #15           wc
        _ret_   muxc    i_dx, i_ffffh

i_salc
                testb   i_flags, #I_CF_BIT  wc
        _ret_   muxc    i_ax, #$FF

i_sahf
                getbyte i_data, i_ax, #1
                and     i_data, #$D5
        _ret_   setbyte i_flags, i_data, #0

i_lahf
                getbyte i_data, i_flags, #0
        _ret_   setbyte i_ax, i_data, #1

i_cmps
                getword i_ea, i_es, #0          ' a b   a:cmpsb  %0_0010010_0_10000_010000
                shl     i_ea, #4                ' a b   b:cmpsw %01_0000000_0_01000_001000
                add     i_ea, i_di              ' a b
                call    #\i_readb               ' a |
                call    #\i_readw               ' | b
                mov     i_data0, i_data         ' a b

                getword i_ea, i_ds, #0          ' a b
                shl     i_ea, #4                ' a b
                add     i_ea, i_si              ' a b
                call    #\i_readb               ' a |
                call    #\i_readw               ' | b

                sub     i_data, i_data0         ' a b

                testb   i_flags, #I_DF_BIT  wz  ' a b
                sumz    i_di, #1                ' | b
                sumz    i_di, #1                ' a b
                getword i_di, i_di, #0          ' a b
                sumz    i_si, #1                ' | b
                sumz    i_si, #1                ' a b
                getword i_si, i_si, #0          ' a b

                jmp     #\i_flags8              ' a |
                jmp     #\i_flags16             '   b

i_prefixed_op
                call    #\i_setupmodrm              ' a b c a:i_f6  %0_110_0000
                mov     pa, i_modrm                 ' a b c b:i_f6  %0_101_0000
                shr     pa, #3                      ' a b c c:i_ff  %0_011_0000
                and     pa, #7                      ' a b c

                add     pa, #i_f6_pre_tbl - $200    ' a | |
                add     pa, #i_f7_pre_tbl - $200    ' | b |
                add     pa, #i_ff_pre_tbl - $200    ' | | c

                rdlut   i_opimpl, pa                ' a b c
                execf   i_opimpl

i_int3          mov     i_tmpb, #3
i_int           call    #\i_readcodeb
                mov     i_temp0, i_tmpb
i_trap          getword i_data, i_flags, #0
                call    #\i_push
                getword i_data, i_cs, #0
                call    #\i_push
                getword i_data, i_ip, #0
                call    #\i_push
                bitl    i_flags, #I_TF_BIT
                bitl    i_flags, #I_IF_BIT
                mov     i_ea, i_temp0
                shl     i_ea, #2
                call    #\i_readw
                getword i_ip, i_data, #0
                call    #\i_readw
                getword i_cs, i_data, #0
                jmp     #\i_nextop

i_into
                testb   i_flags, #I_OF_BIT  wz
        if_x1   mov     i_temp0, #4
        if_x1   jmp     #\i_trap
                ret

i_lock
                bith    i_flags, #I_LOCK_BIT
        _ret_   bith    i_flags, #I_NO_INT_BIT

i_readb
                call    #\i_readmemb
        _ret_   getbyte i_data, i_tmpb, #0

i_writeb
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_readw
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   add     i_ea, #1

i_writew
                getbyte i_tmpb, i_data, #0
                call    #\i_writememb
                add     i_ea, #1
                getbyte i_tmpb, i_data, #1
                jmp     #\i_writememb

i_esc_op
                jmp     #\i_readcodeb

i_ax            long    $0000
i_bx            long    $0000
i_cx            long    $0000
i_dx            long    $0000

i_sp            long    $0000
i_bp            long    $0000
i_si            long    $0000
i_di            long    $0000

i_cs            long    $F000
i_ds            long    $0000
i_es            long    $0000
i_ss            long    $0000

i_flags         long    $0000
i_ip            long    $FFF0

i_3fffh         long    $3FFF
i_ffffh         long    $FFFF
i_eamask        long    $FFFFF
i_optable       long    @i8086_optable

i_rambase       long    @ram_00000
i_cgabase       long    @ram_00000 + RAM_SIZE
i_rombase       long    @rom_FE000

pic_icw         long    $00_00_00_00    ' byte 0=ICW1, 1=ICW2, 2=ICW3, 3=ICW4
pic_ocw         long    $00_00_00_00    ' byte 0=OCW1, 1=OCW2, 2=OCW3
                                        '  nib 6=IS
                                        ' bit 31..27 internal state
pic_irq         long    $00_00_00_00

i_opcode        res     1
i_modrm         res     1
i_modrm0        res     1

i_override      res     1
i_segment       res     1
i_offset        res     1
i_ea            res     1

i_tmpb          res     1
i_data          res     1
i_data0         res     1
i_data1         res     1

i_temp0         res     1
i_temp1         res     1
'i_temp2         res     1
i_cycles        res     1
i_opimpl        res     1
i_rep_cnt       res     1

DAT             ' 8086 LUT
                org     $200
i8086_lut

i_rotshift8_tbl
          {000} long    i_rotshift_impl | (%0_111_110_10_11_0101_1 << 10) ' ROL
          {001} long    i_rotshift_impl | (%0_111_101_01_11_0110_1 << 10) ' ROR
          {010} long    i_rotshift_impl | (%0_110_111_10_11_0101_0 << 10) ' ROLC
          {011} long    i_rotshift_impl | (%0_101_111_01_11_0110_0 << 10) ' RORC
          {100} long    i_rotshift_impl | (%0_111_111_10_11_1111_1 << 10) ' SHL
          {101} long    i_rotshift_impl | (%0_111_111_01_11_1111_1 << 10) ' SHR
          {110} long    i_nop           | (%0 << 10)
          {111} long    i_rotshift_impl | (%0_111_111_01_10_0110_1 << 10) ' SHRA

i_rotshift16_tbl
          {000} long    i_rotshift_impl | (%0_111_110_10_11_0011_1 << 10) ' ROL
          {001} long    i_rotshift_impl | (%0_111_011_01_11_0110_1 << 10) ' ROR
          {010} long    i_rotshift_impl | (%0_110_111_10_11_0011_0 << 10) ' ROLC
          {011} long    i_rotshift_impl | (%0_011_111_01_11_0110_0 << 10) ' RORC
          {100} long    i_rotshift_impl | (%0_111_111_10_11_1111_1 << 10) ' SHL
          {101} long    i_rotshift_impl | (%0_111_111_01_11_1111_1 << 10) ' SHR
          {110} long    i_nop           | (%0 << 10)
          {111} long    i_rotshift_impl | (%0_111_111_01_10_0110_1 << 10) ' SHRA

i_rotshift_impl
                testb   i_flags, #I_CF_BIT  wc  ' | | c d | | |   a=rol_rm8
                                                '                 b=ror_rm8
                testb   i_data, #0          wz  ' | b | d | | g   c=rolc_rm8
                testb   i_data, #7          wz  ' a | c | | | |   d=rorc_rm8
                testb   i_data, #15         wz  ' | | | | | | |   e=shl_rm8
                bitz    i_flags, #I_CF_BIT      ' a b c d | | g   f=shr_rm8
                                                '                 g=shra_rm8
                signx   i_data, #7              ' | | | | | | g
                signx   i_data, #15             ' | | | | | | |

                shl     i_data, #1              ' a | c | e | |
                shr     i_data, #1              ' | b | d | f g

                bitz    i_data, #0              ' a | | | | | |
                bitz    i_data, #7              ' | b | | | | |
                bitz    i_data, #15             ' | | | | | | |

                bitc    i_data, #0              ' | | c | | | |
                bitc    i_data, #7              ' | | | d | | |
                bitc    i_data, #15             ' | | | | | | |

                ret                             ' a b c d e f g

i_f6_pre_tbl
          {000} long    i_f6f7_mathb    |      %01_110_1100_010 << 10 ' TEST
          {001} long    i_f6f7_mathb    |      %01_110_1100_010 << 10 ' TEST (alias)
          {010} long    i_f6f7_mathb    |      %00_101_1111_010 << 10 ' NOT
          {011} long    i_f6f7_mathb    |      %00_011_1111_010 << 10 ' NEG
          {100} long    i_mul8          | %00100_100_1110_11010 << 10 ' MUL
          {101} long    i_mul8          | %00100_100_1100_10010 << 10 ' IMUL
          {110} long    i_div8          | %0011000_1110_1110000 << 10 ' DIV
          {111} long    i_div8          | %0000000_0000_0000000 << 10 ' IDIV

i_f7_pre_tbl
          {000} long    i_f6f7_mathw    |     %0111_110_0000_00 << 10 ' TEST
          {001} long    i_f6f7_mathw    |     %0111_110_0000_00 << 10 ' TEST (alias)
          {010} long    i_f6f7_mathw    |     %0011_101_1111_00 << 10 ' NOT
          {011} long    i_f6f7_mathw    |     %0011_011_1111_00 << 10 ' NEG
          {100} long    i_mul16         | %00010_000_1011_1100_ << 10 ' MUL
          {101} long    i_mul16         | %00010_000_0011_0100_ << 10 ' IMUL
          {110} long    i_div16         | %0011000_1110_1110000 << 10 ' DIV
          {111} long    i_div16         | %0000000_0000_0000000 << 10 ' IDIV

i_ff_pre_tbl
          {000} long    i_ff_impl       | %000_100_1_00 << 10 ' INC
          {001} long    i_ff_impl       | %000_010_1_00 << 10 ' DEC
          {010} long    i_branch_rmod   | %01_1_0011_11_11_11000 << 10 ' CALL
          {011} long    i_branch_rmod   | %00_1_0000_11_11_00000 << 10 ' CALL_FAR
          {100} long    i_branch_rmod   | %01_1_1111_11_11_11000 << 10 ' JMP
          {101} long    i_branch_rmod   | %00_1_1111_11_11_00000 << 10 ' JMP_FAR
          {110} long    i_ff_impl       | %0_10 << 10 ' PUSH
          {111} long    i_ff_impl       | %0_10 << 10 ' PUSH

i_f6f7_mathb
                'dst(r)
                call    #\i_readopb             ' a b c         a:test8    %01_110_1100_010
i_f6f7_mathw                                    '               b:not8     %00_101_1111_010
                call    #\i_readopw             '       d e f   c:neg8     %00_011_1111_010
                mov     i_data0, i_data         ' a b c d e f
                ' src(r)                        '               d:test16 %0111_110_0000_00
                call    #\i_readcodeb           ' a | | d | |   e:not16  %0011_101_1111_00
                getbyte i_data1, i_tmpb, #0     ' a | | d | |   f:neg16  %0011_011_1111_00
                call    #\i_readcodeb           ' | | | d | |
                setbyte i_data1, i_tmpb, #1     ' | | | d | |
                ' operations
                and     i_data, i_data1         ' a | | d | |
                not     i_data                  ' | b | | e |
                neg     i_data                  ' | | c | | f
                ' dst(w)
                call    #\i_writeopb            ' | b c | | |
                jmp     #\i_flags8              ' a b c | | |
                call    #\i_writeopw            '       | e f
                jmp     #\i_flags16             '       d e f

i_aam
                call    #\i_readcodeb
                getbyte i_data, i_ax, #0
                qdiv    i_data, i_tmpb
                getqx   i_temp0
                getqy   i_temp1
                setbyte i_ax, i_temp0, #1
                setbyte i_ax, i_temp1, #0
                getword i_data, i_ax, #0
                jmp     #\i_flags16

i_aad
                call    #\i_readcodeb
                getbyte i_data, i_ax, #1
                mul     i_data, i_tmpb
                getbyte i_temp0, i_ax, #0
                add     i_data, i_temp0
                getbyte i_ax, i_data, #0
                getword i_data, i_ax, #0
                jmp     #\i_flags16

i_lseg_reg
                call    #\i_setupmodrm      ' a b   a: lds [rm]  %00_00_00
                call    #\i_setupea         ' a b   b: les [rm] %010_00_00

                call    #\i_readw           ' a b
                call    #\i_setmodr16       ' a b

                call    #\i_readw           ' a b
        _ret_   mov     i_ds, i_data        ' a |
        _ret_   mov     i_es, i_data        '   b

i_mul8
                                                    ' a b c d   a:mul8   %00100_100_1110_11010
                ' src                                           b:mul16  %00010_000_1011_1100_
                call    #\i_readopb                 ' a | c |   c:imul8  %00100_100_1100_10010
i_mul16
                call    #\i_readopw                 ' | b | d   d:mul16  %00010_000_0011_0100_
                mov     i_data1, i_data             ' a b c d
                signx   i_data1, #7                 ' | | c |
                signx   i_data1, #15                ' | | | d
                ' dst
                getbyte i_data, i_ax, #0            ' a | c |
                signx   i_data, #7                  ' | | c |
                getword i_data, i_ax, #0            ' | b | d
                signx   i_data, #15                 ' | | | d
                ' operation
                muls    i_data, i_data1         wz  ' a b c d
                getword i_ax, i_data, #0            ' a b c d
                getword i_dx, i_data, #1            ' | b | d

                bitz    i_flags, #I_ZF_BIT          ' a b c d
                getbyte i_temp0, i_ax, #0           ' a | c |
                getword i_temp0, i_dx, #0           ' | b | d
                cmp     i_temp0, #0             wz  ' a b c d
        _ret_   bitnz   i_flags, #I_CF_BIT          ' a b c d

i_div8
                ' src
                call    #\i_readopb                 ' a b   a:div8  %0011000_1110_1110000
                mov     i_data1, i_data         wz  ' a b   b:div16 %0000000_0000_0000000
        if_z    mov     i_temp0, #0                 ' a b
        if_z    execf   #i_trap                     ' a b
                signx   i_data1, #7                 ' | b
                testb   i_data1, #31            wc  ' | b
        if_c    abs     i_data1                     ' | b
                ' dst
                getbyte i_data, i_ax, #0            ' a b
                signx   i_data, #7                  ' | b
                testb   i_data, #31             wz  ' | b
        if_z    abs     i_data                      ' | b
                ' operation
                qdiv    i_data, i_data1             ' a b
                getqx   i_temp0                     ' a b
                getqy   i_temp1                     ' a b
    if_c_ne_z   neg     i_temp0                     ' | b
    if_c_ne_z   neg     i_temp1                     ' | b
                setbyte i_ax, i_temp0, #0           ' a b
        _ret_   setbyte i_ax, i_temp1, #1           ' a b

i_div16
                ' src
                call    #\i_readopw                 ' a b   a:div8  %0011000_1110_1110000
                mov     i_data1, i_data         wz  ' a b   b:div16 %0000000_0000_0000000
        if_z    mov     i_temp0, #0                 ' a b
        if_z    execf   #i_trap                     ' a b
                signx   i_data1, #15                ' | b
                testb   i_data1, #31            wc  ' | b
        if_c    abs     i_data1                     ' | b
                ' dst
                getword i_data, i_ax, #0            ' a b
                signx   i_data, #15                 ' | b
                testb   i_data, #31             wz  ' | b
        if_z    abs     i_data                      ' | b
                ' operation
                qdiv    i_data, i_data1             ' a b
                getqx   i_temp0                     ' a b
                getqy   i_temp1                     ' a b
    if_c_ne_z   neg     i_temp0                     ' | b
    if_c_ne_z   neg     i_temp1                     ' | b
                getword i_ax, i_temp0, #0           ' a b
        _ret_   getword i_dx, i_temp1, #0           ' a b

i_mov_imm
                call    #\i_readcodeb           ' a b   a:mov_r8_nn  %00_1100
                getbyte i_data, i_tmpb, #0      ' a b   b:mov_16_nn %010_0000
                call    #\i_readcodeb           ' | b
                setbyte i_data, i_tmpb, #1      ' | b

                mov     pa, i_opcode            ' a b
                jmp     #\i_setr8               ' a |
                jmp     #\i_setr16              '   b

i_mov_rmod_imm
                call    #\i_setupmodrm          ' a b   a:mov_byte_rm_imm    %0_1100_0
                                                '       b:mov_word_rm_imm   %01_0000_0
                call    #\i_readcodeb           ' a b
                getbyte i_data, i_tmpb, #0      ' a b
                call    #\i_readcodeb           ' | b
                setbyte i_data, i_tmpb, #1      ' | b

                jmp     #\i_writeopb            ' a |
                jmp     #\i_writeopw            '   b

i_mov_acc_offs
                call    #\i_readimmw            ' a b c d   a:mov_al_disp %0_1111_1100_00000_0
                                                '           b_mov_ax_disp %0_1111_0011_00000_0
                cmp     i_override, #0      wz  ' a b c d   c:mov_disp_al %0_1100_1111_00000_0
        if_nz   getword i_ea, i_override, #0    ' a b c d   d:mov_disp_ax %0_0011_1111_00000_0
        if_z    getword i_ea, i_ds, #0          ' a b c d
                shl     i_ea, #4                ' a b c d
                add     i_ea, i_data            ' a b c d

                call    #\i_readb               ' a | | |
                setbyte i_ax, i_data, #0        ' a | | |
                call    #\i_readw               ' | b | |
                getword i_ax, i_data, #0        ' | b | |

                getbyte i_data, i_ax, #0        ' | | c |
                call    #\i_writeb              ' | | c |
                getword i_data, i_ax, #0        ' | | | d
                call    #\i_writew              ' | | | d

                ret                             ' a b c d

i_mathop_acc
                ' src(r)
                call    #\i_readcodeb           ' a b c d e f g h i j k l m n o p   a:add_al_rm    %010_1111010_010_1100
                getbyte i_data1, i_tmpb, #0     ' a b c d e f g h i j k l m n o p   b:adc_al_rm    %010_1111001_010_1100
                call    #\i_readcodeb           ' | | | | | | | | i j k l m n o p   c:sub_al_rm    %010_1110110_010_1100
                setbyte i_data1, i_tmpb, #1     ' | | | | | | | | i j k l m n o p   d:sbb_al_rm    %010_1110101_010_1100
                ' dst(r)                        '                                   e:and_al_rm   %0110_1101111_010_1100
                getbyte i_data, i_ax, #0        ' a b c d e f g h | | | | | | | |   f: or_al_rm   %0110_1011111_010_1100
                getword i_data, i_ax, #0        ' | | | | | | | | i j k l m n o p   g:xor_al_rm   %0110_0111111_010_1100
                mov     i_data0, i_data         ' a b c f e f g h i j k l m n o p   h:cmp_al_rm    %011_1110110_010_1100
                ' operation                     '
                modc    _clr                wc  ' a | c | | | | h i | k | | | | p   i:add_al_rm  %01101_1111010_001_0000
                testb   i_flags, #I_CF_BIT  wc  ' | b | d | | | | | j | l | | | |   j:adc_al_rm  %01101_1111001_001_0000
                addx    i_data, i_data1         ' a b | | | | | | i j | | | | | |   k:sub_al_rm  %01101_1110110_001_0000
                subx    i_data, i_data1         ' | | c d | | | h | | k l | | | p   l:sbb_al_rm  %01101_1110101_001_0000
                and     i_data, i_data1         ' | | | | e | | | | | | | m | | |   m:and_al_rm %011101_1101111_001_0000
                or      i_data, i_data1         ' | | | | | f | | | | | | | n | |   n: or_al_rm %011101_1011111_001_0000
                xor     i_data, i_data1         ' | | | | | | g | | | | | | | o |   o:xor_al_rm %011101_0111111_001_0000
                ' dst(w)                        '                                   p:cmp_al_rm  %01111_1110110_001_0000
                setbyte i_ax, i_data, #0        ' a b c d e f g | | | | | | | | |
                getword i_ax, i_data, #0        ' | | | | | | | | i j k l m n o |
                jmp     #\i_flags8              ' a b c d | | | h | | | | | | | |
                jmp     #\i_flags8              '         e f g   | | | | | | | |
                jmp     #\i_flags16             '                 i j k l | | | p
                jmp     #\i_flags16             '                         m n o

i_mathop8
                call    #\i_setupmodrm          ' a b c d e f g h i j k l m n o p q r   a:add_r8_rm    %010_11111010_110_010_0
                ' src(r)                                                                b:adc_r8_rm    %010_11111001_110_010_0
                call    #\i_readopb             ' a b c d e f g h | | | | | | | | q |   c:sub_r8_rm    %010_11110110_110_010_0
                call    #\i_getmodr8            ' | | | | | | | | i j k l m n o p | r   d:sbb_r8_rm    %010_11110101_110_010_0
                mov     i_data1, i_data         ' a b c d e f g h i j k l m n o p q r   e:and_r8_rm    %010_11101111_110_010_0
                ' dst(r)                                                                f: or_r8_rm    %010_11011111_110_010_0
                call    #\i_getmodr8            ' a b c d e f g h | | | | | | | | q |   g:xor_r8_rm    %010_10111111_110_010_0
                call    #\i_readopb             ' | | | | | | | | i j k l m n o p | |   h:cmp_r8_rm    %011_11110110_110_010_0
i_mathop8_op    mov     i_data0, i_data         ' a b c d e f g h i j k l m n o p q r
                ' operation                                                             i:add_rm_r8    %001_11111010_101_001_0
                modc    _clr                wc  ' a | c | | | | h i | k | | | | p | |   j:adc_rm_r8    %001_11111001_101_001_0
                testb   i_flags, #I_CF_BIT  wc  ' | b | d | | | | | j | l | | | | | |   k:sub_rm_r8    %001_11110110_101_001_0
                addx    i_data, i_data1         ' a b | | | | | | i j | | | | | | | |   l:sbb_rm_r8    %001_11110101_101_001_0
                subx    i_data, i_data1         ' | | c d | | | h | | k l | | | p | |   m:and_rm_r8    %001_11101111_101_001_0
                and     i_data, i_data1         ' | | | | e | | | | | | | m | | | | |   n: or_rm_r8    %001_11011111_101_001_0
                or      i_data, i_data1         ' | | | | | f | | | | | | | n | | | |   o:xor_rm_r8    %001_10111111_101_001_0
                xor     i_data, i_data1         ' | | | | | | g | | | | | | | o | | |   p:cmp_rm_r8    %011_11110110_101_001_0
                mov     i_data, i_data1         ' | | | | | | | | | | | | | | | | q r
                ' dst(w)                                                                q:mov_r8_rm   %0110_01111111_110_010_0
                call    #\i_setmodr8            ' a b c d e f g | | | | | | | | | q |   r:mov_rm_r8   %0101_01111111_011_001_0
                call    #\i_writeopb            ' | | | | | | | | i j k l m n o | | r
                jmp     #\i_flags8              ' a b c d e f g h i j k l m n o p | |
                ret                             '                                 q r

i_mathop16
                call    #\i_setupmodrm          ' a b c d e f g h i j k l m n o p q r   a:add_r16_rm   %010_11111010_110_010_0
i_mathop16_pre  ' src(r)                                                                b:adc_r16_rm   %010_11111001_110_010_0
                call    #\i_readopw             ' a b c d e f g h | | | | | | | | q |   c:sub_r16_rm   %010_11110110_110_010_0
                call    #\i_getmodr16           ' | | | | | | | | i j k l m n o p | r   d:sbb_r16_rm   %010_11110101_110_010_0
                mov     i_data1, i_data         ' a b c d e f g h i j k l m n o p q r   e:and_r16_rm   %010_11101111_110_010_0
                ' dst(r)                                                                f: or_r16_rm   %010_11011111_110_010_0
                call    #\i_getmodr16           ' a b c d e f g h | | | | | | | | q |   g:xor_r16_rm   %010_10111111_110_010_0
                call    #\i_readopw             ' | | | | | | | | i j k l m n o p | r   h:cmp_r16_rm   %011_11110110_110_010_0
i_mathop16_op   mov     i_data0, i_data         ' a b c d e f g h i j k l m n o p q r
                ' operation                                                             i:add_rm_r16   %001_11111010_101_001_0
                modc    _clr                wc  ' a | c | | | | h i | k | | | | p | |   j:adc_rm_r16   %001_11111001_101_001_0
                testb   i_flags, #I_CF_BIT  wc  ' | b | d | | | | | j | l | | | | | |   k:sub_rm_r16   %001_11110110_101_001_0
                addx    i_data, i_data1         ' a b | | | | | | i j | | | | | | | |   l:sbb_rm_r16   %001_11110101_101_001_0
                subx    i_data, i_data1         ' | | c d | | | h | | k l | | | p | |   m:and_rm_r16   %001_11101111_101_001_0
                and     i_data, i_data1         ' | | | | e | | | | | | | m | | | | |   n: or_rm_r16   %001_11011111_101_001_0
                or      i_data, i_data1         ' | | | | | f | | | | | | | n | | | |   o:xor_rm_r16   %001_10111111_101_001_0
                xor     i_data, i_data1         ' | | | | | | g | | | | | | | o | | |   p:cmp_rm_r16   %011_11110110_101_001_0
                mov     i_data, i_data1         ' | | | | | | | | | | | | | | | | q r
                ' dst(w)                                                                q:mov_r16_rm  %0110_01111111_110_010_0
                call    #\i_setmodr16           ' a b c d e f g | | | | | | | | | q |   r:mov_rm_r16  %0101_01111111_011_001_0
                call    #\i_writeopw            ' | | | | | | | | i j k l m n o | | r
                jmp     #\i_flags16             ' a b c d e f g h i j k l m n o p | |
                ret                             '                                 q r

i_incdec
                mov     pa, i_opcode            ' a b c d   a:inc_r8      %00_100_0100
                call    #\i_getr8               ' a | c |   b:inc_r16   %0011_100_0010
                call    #\i_getr16              ' | b | d   c:dec_r8      %00_010_0100
                mov     i_data0, i_data         ' a b c d   d:dec_16    %0011_010_0010
                                                '
                mov     i_data1, #1             ' a b c d
                add     i_data, i_data1         ' a b | |
                sub     i_data, i_data1         ' | | c d
                                                '
                call    #\i_setr8               ' a | c |
                jmp     #\i_flags8              ' a | c |
                call    #\i_setr16              '   b   d
                jmp     #\i_flags16             '   b   d

i_fe_pre
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data

                mov     i_data1, #1
                mov     i_temp0, i_modrm
                and     i_temp0, #$38       wz
        if_z    add     i_data, i_data1
                cmp     i_temp0, #$08       wz
        if_z    sub     i_data, i_data1

                call    #\i_writeopb
                jmp     #\i_flags8

i_push_es       getword i_data, i_es, #0        '     c         a=push r16
i_push_cs       getword i_data, i_cs, #0        '     | d       b=pushf
i_push_ss       getword i_data, i_ss, #0        '     | | e     c=push es
i_push_ds       getword i_data, i_ds, #0        '     | | | f   d=push cs
i_pushf         getword i_data, i_flags, #0     '   b | | | |   e=push ss
i_push_r16      mov     pa, i_opcode            ' a | | | | |   f=push ds
                call    #\i_getr16              ' a | | | | |
i_push          decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #1
                call    #\i_writememb
                decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_pop_r16
                call    #\i_pop                 ' a b c d e f   a:pop r16      %00_0
                mov     pa, i_opcode            ' a | | | | |   b:popf       %0_11_0
                jmp     #\i_setr16              ' a | | | | |   c:pop_es    %01_11_0
        _ret_   getword i_flags, i_data, #0     '   b | | | |   d:pop_cs   %011_11_0
        _ret_   getword i_es, i_data, #0        '     c | | |   e:pop_ss  %0111_11_0
        _ret_   getword i_cs, i_data, #0        '       d | |   f:pop_ds %01111_11_0
        _ret_   getword i_ss, i_data, #0        '         e |
        _ret_   getword i_ds, i_data, #0        '           f

i_pop_rmod
                call    #\i_setupmodrm
                call    #\i_pop
                jmp     #\i_writeopw

i_pop
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                incmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   incmod  i_sp, i_ffffh

i_daas
                getbyte i_data, i_ax, #0
                mov     i_data0, i_data
                mov     i_temp0, #$00
                cmpr    i_data, #$99        wc
                testb   i_flags, #I_CF_BIT  orc
        if_c    add     i_temp0, #$60
                bitc    i_flags, #I_CF_BIT
                getnib  i_temp1, i_data, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc
        if_c    add     i_temp0, #$06
                testb   i_opcode, #3        wz
                sumz    i_data, i_temp0
                setbyte i_ax, i_data, #0
                jmp     #i_flags8

i_aaas
                getnib  i_temp1, i_ax, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc

                testb   i_opcode, #3        wz
                getbyte i_data, i_ax, #0
        if_c    sumz    i_data, #6
        if_c    setnib  i_data, #0, #1
                setbyte i_ax, i_data, #0

                getbyte i_data, i_ax, #1
        if_c    sumz    i_data, #1
                setbyte i_ax, i_data, #1

                bitc    i_flags, #I_CF_BIT
        _ret_   bitc    i_flags, #I_AF_BIT

i_lods
                cmp     i_override, #0      wz  ' a b   a=lodsb %0010_10_10_00000
        if_nz   getword i_ea, i_override, #0    ' a b   b=lodsw %0000_01_01_00000
        if_z    getword i_ea, i_ds, #0          ' a b
                shl     i_ea, #4                ' a b
                add     i_ea, i_si              ' a b

                call    #\i_readb               ' a |
                call    #\i_readw               ' | b

                setbyte i_ax, i_data, #0        ' a |
                getword i_ax, i_data, #0        ' | b

                testb   i_flags, #I_DF_BIT  wz  ' a b
                sumz    i_si, #1                ' | b
                sumz    i_si, #1                ' a b
        _ret_   getword i_si, i_si, #0          ' a b

i_stos
                getword i_ea, i_es, #0          ' a b   a=stosb %0010_10_10_000
                shl     i_ea, #4                ' a b   a=stosw %0000_01_01_000
                add     i_ea, i_di              ' a b

                getbyte i_data, i_ax, #0        ' a |
                getword i_data, i_ax, #0        ' | b

                call    #\i_writeb              ' a |
                call    #\i_writew              ' | b

                testb   i_flags, #I_DF_BIT  wz  ' a b
                sumz    i_di, #1                ' | b
                sumz    i_di, #1                ' a b
        _ret_   getword i_di, i_di, #0          ' a b

i_scas
                getword i_ea, i_es, #0          ' a b   a:scasb  %0_0100_0_010_010_000
                shl     i_ea, #4                ' a b   b:scasw %01_0000_0_001_001_000
                add     i_ea, i_di              ' a b

                call    #\i_readb               ' a |
                call    #\i_readw               ' | b
                mov     i_data1, i_data         ' a b

                getbyte i_data, i_ax, #0        ' a |
                getword i_data, i_ax, #0        ' | b
                mov     i_data0, i_data         ' a b

                sub     i_data, i_data1         ' a b

                testb   i_flags, #I_DF_BIT  wz  ' a b
                sumz    i_di, #1                ' a b
                sumz    i_di, #1                ' | b
                getword i_di, i_di, #0          ' a b

                jmp     #\i_flags8              ' a |
                jmp     #\i_flags16             '   b

i_xlatb
                getbyte i_temp0, i_ax, #0
                add     i_temp0, i_bx
                getword i_temp0, i_temp0, #0
                cmp     i_override, #0      wz
        if_nz   getword i_ea, i_override, #0
        if_z    getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_temp0
                call    #\i_readmemb
        _ret_   setbyte i_ax, i_tmpb, #0

i_xchg
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                getword i_data, i_ax, #0
                getword i_ax, i_data0, #0
                jmp     #\i_setr16

i_xchg_rmod
                call    #\i_setupmodrm          ' a b   a:xchg_r8_rm   %00100_010_010_0
                                                '       b:xchg_r16_rm %010010_001_001_0
                call    #\i_readopb             ' a |
                call    #\i_readopw             ' | b
                mov     i_data1, i_data         ' a b

                call    #\i_getmodr8            ' a |
                call    #\i_getmodr16           ' | b
                mov     i_data0, i_data         ' a b

                mov     i_data, i_data1         ' a b
                call    #\i_setmodr8            ' a |
                call    #\i_setmodr16           ' | b
                mov     i_data, i_data0         ' a b
                jmp     #\i_writeopb            ' a |
                jmp     #\i_writeopw            '   b

i_inout
                call    #\i_readcodeb           ' a b c d           a:in al, [pp]   %0_11111_11100_1_00
                getbyte i_ea, i_tmpb, #0        ' a b c d           b:in ax, [pp]   %0_11111_00000_1_00
i_inoutdx                                       '                   c:out [pp], al  %0_11100_11111_1_00
                getword i_ea, i_dx, #0          ' | | | | e f g h   d:out [pp], ax  %0_00000_11111_1_00

                call    #\i_readiob             ' a b | | e f | |   e:in al, [dx]   %0_11111_11100_0
                setbyte i_ax, i_tmpb, #0        ' a b | | e f | |   f:in ax, [pp]   %0_11111_00000_0
                add     i_ea, #1                ' | b | | | f | |   g:out [pp], al  %0_11100_11111_0
                call    #\i_readiob             ' | b | | | f | |   h:out [pp], ax  %0_00000_11111_0
                setbyte i_ax, i_tmpb, #1        ' | b | | | f | |

                getbyte i_tmpb, i_ax, #0        ' | | c d | | g h
                call    #\i_writeiob            ' | | c d | | g h
                add     i_ea, #1                ' | | | d | | | h
                getbyte i_tmpb, i_ax, #1        ' | | | d | | | h
                call    #\i_writeiob            ' | | | d | | | h
i_nop
                ret                             ' a b c d e f g h

i_hlt
        _ret_   decmod  i_ip, i_ffffh

i_flags8
                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                testb   i_data, #8          wz
                bitz    i_flags, #I_CF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                bitl    i_flags, #I_OF_BIT
                testb   i_data, #7          wz

                testb   i_data0, #7         wc
                testb   i_data1, #7         andc
        if_1x   bitnz   i_flags, #I_OF_BIT
        if_1x   ret
                testb   i_data0, #7         wc
                testb   i_data1, #7         orc
        if_0x   bitz    i_flags, #I_OF_BIT
        if_0x   ret

                testb   i_data0, #7         wz
                testb   i_data, #7          xorz
        if_x1   testb   i_flags, #I_ZF_BIT  xorz
        _ret_   bitz    i_flags, #I_OF_BIT

i_flags16
                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                testb   i_data, #16         wz
                bitz    i_flags, #I_CF_BIT
                and     i_data, i_ffffh     wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data0, #15        wc
                testb   i_data1, #15        andc
        if_1x   bitnz   i_flags, #I_OF_BIT
        if_1x   ret
                testb   i_data0, #15        wc
                testb   i_data1, #15        orc
        if_0x   bitz    i_flags, #I_OF_BIT
        if_0x   ret

                testb   i_data0, #15        wz
                testb   i_data, #15         xorz
        if_x1   testb   i_flags, #I_ZF_BIT  xorz
        _ret_   bitz    i_flags, #I_OF_BIT

' --------------------------------------------------------------------

i_readmemb
                ' i_ea   = address
                ' i_tmpb = data
                and     i_ea, i_eamask
                mov     i_tmpb, #$FF
                mov     pa, i_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_b    ret     wcz                 ' |
                cmp     pa, #$BC        wcz ' BBFFF video ram (16k)
        if_b    jmp     #.cga
                cmp     pa, #$FE        wcz ' FE000
        if_ae   jmp     #.rom               ' FFFFF rom (8k)
                ret     wcz
.ram
                mov     pa, i_ea
                add     pa, i_rambase
                rdbyte  i_tmpb, pa
                ret     wcz
.cga
                mov     pb, i_ea
                and     pb, i_3fffh
                add     pb, i_cgabase
                rdbyte  i_tmpb, pb
                ret     wcz
.rom
                mov     pa, i_ea
                and     pa, ##$1FFF
                add     pa, i_rombase
                rdbyte  i_tmpb, pa
                ret     wcz

i_writememb
                ' i_ea   = address
                ' i_tmpb = data
                and     i_ea, i_eamask
                mov     pa, i_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_b    ret     wcz                 ' |
                cmp     pa, #$BC        wcz ' BBFFF video ram (16k)
        if_b    jmp     #.cga
                ret     wcz
.ram
                mov     pa, i_ea
                add     pa, i_rambase
                wrbyte  i_tmpb, pa
                ret     wcz
.cga
                mov     pb, i_ea
                and     pb, i_3fffh
                add     pb, i_cgabase
                wrbyte  i_tmpb, pb
                ret     wcz

i8086_lut_end

DAT             ' 8086 Opcode Table
                orgh

i8086_optable
'
' instruction           snippet                          skip pattern         encoding
'----------------------------------------------------------------------------------------------------
                long    i_mathop8      |      %001_11111010_101_001_0 << 10 ' 00 rm    add [rm], r8
                long    i_mathop16     |      %001_11111010_101_001_0 << 10 ' 01 rm    add [rm], r16
                long    i_mathop8      |      %010_11111010_110_010_0 << 10 ' 02 rm    add r8, [rm]
                long    i_mathop16     |      %010_11111010_110_010_0 << 10 ' 03 rm    add r16, [rm]
                long    i_mathop_acc   |        %010_1111010_010_1100 << 10 ' 04 nn    add al, nn
                long    i_mathop_acc   |      %01101_1111010_001_0000 << 10 ' 05 ll hh add ax, hhll
                long    i_push_es      |                    %111111_0 << 10 ' 06       push es
                long    i_pop_r16      |                       %01110 << 10 ' 07       pop es
                long    i_mathop8      |      %001_11011111_101_001_0 << 10 ' 08 rm    or [rm], r8
                long    i_mathop16     |      %001_11011111_101_001_0 << 10 ' 09 rm    or [rm], r16
                long    i_mathop8      |      %010_11011111_110_010_0 << 10 ' 0A rm    or r8, [rm]
                long    i_mathop16     |      %010_11011111_110_010_0 << 10 ' 0B rm    or r16, [rm]
                long    i_mathop_acc   |       %0110_1011111_010_1100 << 10 ' 0C nn    or al, nn
                long    i_mathop_acc   |     %011101_1011111_001_0000 << 10 ' 0D ll hh or ax, hhll
                long    i_push_cs      |                     %11111_0 << 10 ' 0E       push cs
                long    i_pop_r16      |                      %011110 << 10 ' 0F       pop cs

                long    i_mathop8      |      %001_11111001_101_001_0 << 10 ' 10 rm    adc [rm], r8
                long    i_mathop16     |      %001_11111001_101_001_0 << 10 ' 11 rm    adc [rm], r16
                long    i_mathop8      |      %010_11111001_110_010_0 << 10 ' 12 rm    adc r8, [rm]
                long    i_mathop16     |      %010_11111001_110_010_0 << 10 ' 13 rm    adc r16, [rm]
                long    i_mathop_acc   |        %010_1111001_010_1100 << 10 ' 14 nn    adc al nn
                long    i_mathop_acc   |      %01101_1111001_001_0000 << 10 ' 15 ll hh adc ax, hhll
                long    i_push_ss      |                      %1111_0 << 10 ' 16       push ss
                long    i_pop_r16      |                     %0111110 << 10 ' 17       pop ss
                long    i_mathop8      |      %001_11110101_101_001_0 << 10 ' 18 rm    sbb [rm], r8
                long    i_mathop16     |      %001_11110101_101_001_0 << 10 ' 19 rm    sbb [rm], r16
                long    i_mathop8      |      %010_11110101_110_010_0 << 10 ' 1A rm    sbb r8, [rm]
                long    i_mathop16     |      %010_11110101_110_010_0 << 10 ' 1B rm    sbb r16, [rm]
                long    i_mathop_acc   |        %010_1110101_010_1100 << 10 ' 1C nn    sbb al, nn
                long    i_mathop_acc   |      %01101_1110101_001_0000 << 10 ' 1D ll hh sbb ax, hhll
                long    i_push_ds      |                       %111_0 << 10 ' 1E       push ds
                long    i_pop_r16      |                    %01111110 << 10 ' 1F       pop ds

                long    i_mathop8      |      %001_11101111_101_001_0 << 10 ' 20 rm    and [rm], r8
                long    i_mathop16     |      %001_11101111_101_001_0 << 10 ' 21 rm    and [rm], r16
                long    i_mathop8      |      %010_11101111_110_010_0 << 10 ' 22 rm    and r8, [rm]
                long    i_mathop16     |      %010_11101111_110_010_0 << 10 ' 23 rm    and r16, [rm]
                long    i_mathop_acc   |       %0110_1101111_010_1100 << 10 ' 24 nn    and al, nn
                long    i_mathop_acc   |     %011101_1101111_001_0000 << 10 ' 25 ll hh and ax, hhll
                long    i_seg_es       |                      %0010__ << 10 ' 26       es:
                long    i_daas         |                           %0 << 10 ' 27       daa
                long    i_mathop8      |      %001_11110110_101_001_0 << 10 ' 28 rm    sub [rm], r8
                long    i_mathop16     |      %001_11110110_101_001_0 << 10 ' 29 rm    sub [rm], r16
                long    i_mathop8      |      %010_11110110_110_010_0 << 10 ' 2A rm    sub r8, [rm]
                long    i_mathop16     |      %010_11110110_110_010_0 << 10 ' 2B rm    sub r16, [rm]
                long    i_mathop_acc   |        %010_1110110_010_1100 << 10 ' 2C nn    sub al, nn
                long    i_mathop_acc   |      %01101_1110110_001_0000 << 10 ' 2D ll hh sub ax, hhll
                long    i_seg_cs       |                      %001110 << 10 ' 2E       cs:
                long    i_daas         |                           %0 << 10 ' 2F       das

                long    i_mathop8      |      %001_10111111_101_001_0 << 10 ' 30 rm    xor [rm], r8
                long    i_mathop16     |      %001_10111111_101_001_0 << 10 ' 31 rm    xor [rm], r16
                long    i_mathop8      |      %010_10111111_110_010_0 << 10 ' 32 rm    xor r8, [rm]
                long    i_mathop16     |      %010_10111111_110_010_0 << 10 ' 33 rm    xor r16, [rm]
                long    i_mathop_acc   |       %0110_0111111_010_1100 << 10 ' 34 nn    xor al, nn
                long    i_mathop_acc   |     %011101_0111111_001_0000 << 10 ' 35 ll hh xor ax, hhll
                long    i_seg_ss       |                      %000___ << 10 ' 36       ss:
                long    i_aaas         |                           %0 << 10 ' 37       aaa
                long    i_mathop8      |      %011_11110110_101_001_0 << 10 ' 38 rm    cmp [rm], r8
                long    i_mathop16     |      %011_11110110_101_001_0 << 10 ' 39 rm    cmp [rm], r16
                long    i_mathop8      |      %011_11110110_110_010_0 << 10 ' 3A rm    cmp r8, [rm]
                long    i_mathop16     |      %011_11110110_110_010_0 << 10 ' 3B rm    cmp r16, [rm]
                long    i_mathop_acc   |        %011_1110110_010_1100 << 10 ' 3C nn    cmp al, nn
                long    i_mathop_acc   |      %01111_1110110_001_0000 << 10 ' 3D ll hh cmp ax, hhll
                long    i_seg_ds       |                      %00110_ << 10 ' 3E       ds:
                long    i_aaas         |                           %0 << 10 ' 3F       aas

                long    i_incdec       |               %0011_100_0010 << 10 ' 40       inc ax
                long    i_incdec       |               %0011_100_0010 << 10 ' 41       inc cx
                long    i_incdec       |               %0011_100_0010 << 10 ' 42       inc dx
                long    i_incdec       |               %0011_100_0010 << 10 ' 43       inc bx
                long    i_incdec       |               %0011_100_0010 << 10 ' 44       inc sp
                long    i_incdec       |               %0011_100_0010 << 10 ' 45       inc bp
                long    i_incdec       |               %0011_100_0010 << 10 ' 46       inc si
                long    i_incdec       |               %0011_100_0010 << 10 ' 47       inc di
                long    i_incdec       |               %0011_010_0010 << 10 ' 48       dec ax
                long    i_incdec       |               %0011_010_0010 << 10 ' 49       dec cx
                long    i_incdec       |               %0011_010_0010 << 10 ' 4A       dec dx
                long    i_incdec       |               %0011_010_0010 << 10 ' 4B       dec bx
                long    i_incdec       |               %0011_010_0010 << 10 ' 4C       dec sp
                long    i_incdec       |               %0011_010_0010 << 10 ' 4D       dec bp
                long    i_incdec       |               %0011_010_0010 << 10 ' 4E       dec si
                long    i_incdec       |               %0011_010_0010 << 10 ' 4F       dec di

                long    i_push_r16     |                           %0 << 10 ' 50       push ax
                long    i_push_r16     |                           %0 << 10 ' 51       push cx
                long    i_push_r16     |                           %0 << 10 ' 52       push dx
                long    i_push_r16     |                           %0 << 10 ' 53       push bx
                long    i_push_r16     |                           %0 << 10 ' 54       push sp
                long    i_push_r16     |                           %0 << 10 ' 55       push bp
                long    i_push_r16     |                           %0 << 10 ' 56       push si
                long    i_push_r16     |                           %0 << 10 ' 57       push di
                long    i_pop_r16      |                           %0 << 10 ' 58       pop ax
                long    i_pop_r16      |                           %0 << 10 ' 59       pop cx
                long    i_pop_r16      |                           %0 << 10 ' 5A       pop dx
                long    i_pop_r16      |                           %0 << 10 ' 5B       pop bx
                long    i_pop_r16      |                           %0 << 10 ' 5C       pop sp
                long    i_pop_r16      |                           %0 << 10 ' 5D       pop bp
                long    i_pop_r16      |                           %0 << 10 ' 5E       pop si
                long    i_pop_r16      |                           %0 << 10 ' 5F       pop di

                long    i_jmp_d8       |           %1_111111111101_00 << 10 ' 60 dd          jo dd   60 - 6F are aliases to 70 - 7F
                long    i_jmp_d8       |           %0_111111111101_00 << 10 ' 61 dd          jno dd
                long    i_jmp_d8       |           %1_111111111011_00 << 10 ' 62 dd          jc dd
                long    i_jmp_d8       |           %0_111111111011_00 << 10 ' 63 dd          jnc dd
                long    i_jmp_d8       |           %1_111111110111_00 << 10 ' 64 dd          jz dd
                long    i_jmp_d8       |           %0_111111110111_00 << 10 ' 65 dd          jnz dd
                long    i_jmp_d8       |           %1_110111111011_00 << 10 ' 66 dd          jce dd
                long    i_jmp_d8       |           %0_110111111011_00 << 10 ' 67 dd          jnce dd
                long    i_jmp_d8       |           %1_111111101111_00 << 10 ' 68 dd          js dd
                long    i_jmp_d8       |           %0_111111101111_00 << 10 ' 69 dd          jns dd
                long    i_jmp_d8       |           %1_111111011111_00 << 10 ' 6A dd          jp dd
                long    i_jmp_d8       |           %0_111111011111_00 << 10 ' 6B dd          jnp dd
                long    i_jmp_d8       |           %1_011100101111_00 << 10 ' 6C dd          jl dd
                long    i_jmp_d8       |           %1_111010101111_00 << 10 ' 6D dd          jnl dd
                long    i_jmp_d8       |           %1_110100101111_00 << 10 ' 6E dd          jle dd
                long    i_jmp_d8       |           %1_011010101111_00 << 10 ' 6F dd          jnle dd

                long    i_jmp_d8       |           %1_111111111101_00 << 10 ' 70 dd          jo dd
                long    i_jmp_d8       |           %0_111111111101_00 << 10 ' 71 dd          jno dd
                long    i_jmp_d8       |           %1_111111111011_00 << 10 ' 72 dd          jc dd
                long    i_jmp_d8       |           %0_111111111011_00 << 10 ' 73 dd          jnc dd
                long    i_jmp_d8       |           %1_111111110111_00 << 10 ' 74 dd          jz dd
                long    i_jmp_d8       |           %0_111111110111_00 << 10 ' 75 dd          jnz dd
                long    i_jmp_d8       |           %1_110111111011_00 << 10 ' 76 dd          jce dd
                long    i_jmp_d8       |           %0_110111111011_00 << 10 ' 77 dd          jnce dd
                long    i_jmp_d8       |           %1_111111101111_00 << 10 ' 78 dd          js dd
                long    i_jmp_d8       |           %0_111111101111_00 << 10 ' 79 dd          jns dd
                long    i_jmp_d8       |           %1_111111011111_00 << 10 ' 7A dd          jp dd
                long    i_jmp_d8       |           %0_111111011111_00 << 10 ' 7B dd          jnp dd
                long    i_jmp_d8       |           %1_011100101111_00 << 10 ' 7C dd          jl dd
                long    i_jmp_d8       |           %1_111010101111_00 << 10 ' 7D dd          jnl dd
                long    i_jmp_d8       |           %1_110100101111_00 << 10 ' 7E dd          jle dd
                long    i_jmp_d8       |           %1_011010101111_00 << 10 ' 7F dd          jnle dd

                long    i_math_pre     |            %00000_11100_10_0 << 10 ' 80 rm nn       add/or/adc/sbb/and/sub(xor/cmp [rm8], nn
                long    i_math_pre     |          %0011000_10000_01_0 << 10 ' 81 rm ll hh    add/or/adc/sbb/and/sub(xor/cmp [rm16], hhll
                long    i_math_pre     |            %00000_01100_10_0 << 10 ' 82 rm sn       add/or/adc/sbb/and/sub(xor/cmp [rm8], sn
                long    i_math_pre     |          %0011000_01100_01_0 << 10 ' 83 rm sn       add/or/adc/sbb/and/sub(xor/cmp [rm16], sn
                long    i_mathop8      |      %011_11101111_110_010_0 << 10 ' 84 rm          test r8, [mm]
                long    i_mathop16     |      %011_11101111_110_010_0 << 10 ' 85 rm          test r16, [mm]
                long    i_xchg_rmod    |             %00100_010_010_0 << 10 ' 86 rm          xchg r8, [mm]
                long    i_xchg_rmod    |            %010010_001_001_0 << 10 ' 87 rm          xchg r16, [mm]
                long    i_mathop8      |     %0101_01111111_011_001_0 << 10 ' 88 rm          mov [rm], r8
                long    i_mathop16     |     %0101_01111111_011_001_0 << 10 ' 89 rm          mov [rm], r16
                long    i_mathop8      |     %0110_01111111_110_010_0 << 10 ' 8A rm          mov r8, [rm]
                long    i_mathop16     |     %0110_01111111_110_010_0 << 10 ' 8B rm          mov r16, [rm]
                long    i_mov_sreg     |                %000_111_0000 << 10 ' 8C mm          mov [rm], sreg
                long    i_lea          |                           %0 << 10 ' 8D mm          lea r16, ofs
                long    i_mov_sreg     |                    %000_0000 << 10 ' 8E mm          mov sregs, [rm]
                long    i_pop_rmod     |                           %0 << 10 ' 8F mm          pop [rm]

                long    i_xchg         |                           %0 << 10 ' 90             xchg ax, cx
                long    i_xchg         |                           %0 << 10 ' 91             xchg ax, cx
                long    i_xchg         |                           %0 << 10 ' 92             xchg ax, dx
                long    i_xchg         |                           %0 << 10 ' 93             xchg ax, bx
                long    i_xchg         |                           %0 << 10 ' 94             xchg ax, sp
                long    i_xchg         |                           %0 << 10 ' 95             xchg ax, bp
                long    i_xchg         |                           %0 << 10 ' 96             xchg ax, si
                long    i_xchg         |                           %0 << 10 ' 97             xchg ax, di
                long    i_cbw          |                           %0 << 10 ' 98             cbw
                long    i_cwd          |                           %0 << 10 ' 99             cwd
                long    i_branch       |             %00_1_0000_00_00 << 10 ' 9A ol oh sl sh call shsl:ohol
                long    i_nop          |                           %0 << 10 ' 9B             wait
                long    i_pushf        |                           %0 << 10 ' 9C             pushf
                long    i_pop_r16      |                        %0110 << 10 ' 9D             popf
                long    i_sahf         |                           %0 << 10 ' 9E             sahf
                long    i_lahf         |                           %0 << 10 ' 9F             lahf

                long    i_mov_acc_offs |         %0_1111_1100_00000_0 << 10 ' A0 ol oh       mov al, [DS:ohol]
                long    i_mov_acc_offs |         %0_1111_0011_00000_0 << 10 ' A1 ol oh       mov ax, [DS:ohol]
                long    i_mov_acc_offs |         %0_1100_1111_00000_0 << 10 ' A2 ol oh       mov [DS:ohol], al
                long    i_mov_acc_offs |         %0_0011_1111_00000_0 << 10 ' A3 ol oh       mov [DS:ohol], ax
                long    i_movsb        |                           %0 << 10 ' A4             movsb
                long    i_movsw        |                           %0 << 10 ' A5             movsw
                long    i_cmps         |    %0_0010010_0_10000_010000 << 10 ' A6             cmpsb
                long    i_cmps         |   %01_0000000_0_01000_001000 << 10 ' A7             cmpsw
                long    i_mathop_acc   |       %0111_1101111_010_1100 << 10 ' A8 nn          test al, nn
                long    i_mathop_acc   |     %011111_1101111_001_0000 << 10 ' A9 ll hh       test ax, hhll
                long    i_stos         |              %0010_10_10_000 << 10 ' AA             stosb
                long    i_stos         |              %0000_01_01_000 << 10 ' AB             stosw
                long    i_lods         |            %0010_10_10_00000 << 10 ' AC             lodsb
                long    i_lods         |            %0000_01_01_00000 << 10 ' AD             lodsw
                long    i_scas         |        %0_0100_0_010_010_000 << 10 ' AE             scasb
                long    i_scas         |       %01_0000_0_001_001_000 << 10 ' AF             scasw

                long    i_mov_imm      |                     %00_1100 << 10 ' B0 nn          mov al, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B1 nn          mov cl, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B2 nn          mov dl, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B3 nn          mov bl, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B4 nn          mov ah, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B5 nn          mov ch, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B6 nn          mov dh, nn
                long    i_mov_imm      |                     %00_1100 << 10 ' B7 nn          mov bh, nn
                long    i_mov_imm      |                    %010_0000 << 10 ' B8 ll hh       mov ax, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' B9 ll hh       mov cx, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BA ll hh       mov dx, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BB ll hh       mov bx, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BC ll hh       mov sp, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BD ll hh       mov bp, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BE ll hh       mov si, hhll
                long    i_mov_imm      |                    %010_0000 << 10 ' BF ll hh       mov di, hhll

                long    i_ret_d16      |              %00_11_11_00_00 << 10 ' C0 dl dh       ret (SP+dhdl)
                long    i_ret          |                 %01_11_11_00 << 10 ' C1             ret
                long    i_ret_d16      |              %00_11_11_00_00 << 10 ' C2 dl dh       ret (SP+dhdl)
                long    i_ret          |                 %01_11_11_00 << 10 ' C3             ret
                long    i_lseg_reg     |                   %010_00_00 << 10 ' C4 rm          les [rm]
                long    i_lseg_reg     |                    %00_00_00 << 10 ' C5 rm          lds [rm]
                long    i_mov_rmod_imm |                    %0_1100_0 << 10 ' C6 rm nn       mov byte [rmod], nn
                long    i_mov_rmod_imm |                   %01_0000_0 << 10 ' C7 rm ll hh    mov word [rmod], hhll
                long    i_ret_d16      |              %00_11_00_00_00 << 10 ' C8 dl dh       retf (SP+dhdl)
                long    i_ret          |                 %01_11_00_00 << 10 ' C9             retf
                long    i_ret_d16      |              %00_11_00_00_00 << 10 ' CA dl dh       retf (SP+dhdl)
                long    i_ret          |                 %01_11_00_00 << 10 ' CB             retf
                long    i_int3         |                          %10 << 10 ' CC             int3
                long    i_int          |                           %0 << 10 ' CD             int
                long    i_into         |                           %0 << 10 ' CE             into
                long    i_ret          |                 %01_00_00_00 << 10 ' CF             iret

                long    i_rotshift     |          %00_0010000_10_10_0 << 10 ' D0 rm          rol/ror/rolc/rorc/shl/shr/shrab
                long    i_rotshift     |        %0011_0001000_01_10_0 << 10 ' D1 rm          rol/ror/rolc/rorc/shl/shr/shraw
                long    i_rotshift     |          %00_0010000_10_01_0 << 10 ' D2 rm          rol/ror/rolc/rorc/shl/shr/shrab cl
                long    i_rotshift     |        %0011_0001000_01_01_0 << 10 ' D3 rm          rol/ror/rolc/rorc/shl/shr/shraw cl
                long    i_aam          |                           %0 << 10 ' D4             aam
                long    i_aad          |                           %0 << 10 ' D5             aad
                long    i_salc         |                           %0 << 10 ' D6             salc
                long    i_xlatb        |                           %0 << 10 ' D7             xlatb
                long    i_esc_op       |                           %0 << 10 ' D8 rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' D9 rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DA rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DB rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DC rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DD rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DE rm          esc rm
                long    i_esc_op       |                           %0 << 10 ' DF rm          esc rm

                long    i_loop         |                   %00_01_000 << 10 ' E0 dd          loopne dd
                long    i_loop         |                   %00_10_000 << 10 ' E1 dd          loope dd
                long    i_loop         |                   %00_11_000 << 10 ' E2 dd          loop dd
                long    i_jcxz         |                           %0 << 10 ' E3 dd          jcxz dd
                long    i_inout        |          %0_11111_11100_1_00 << 10 ' E4 pp          in al, [pp]
                long    i_inout        |          %0_11111_00000_1_00 << 10 ' E5 pp          in ax, [pp]
                long    i_inout        |          %0_11100_11111_1_00 << 10 ' E6 pp          out al, [pp]
                long    i_inout        |          %0_00000_11111_1_00 << 10 ' E7 pp          out ax, [pp]
                long    i_branch       |             %01_0_0011_11_00 << 10 ' E8 ol oh       call +ohol
                long    i_branch       |             %01_0_1111_11_00 << 10 ' E9 ol oh       jmp +ohol
                long    i_branch       |             %00_1_1111_00_00 << 10 ' EA ol oh sl sh jmp shsl:ohol
                long    i_jmp_d8       |        %00_1_111111111110_00 << 10 ' EB oo          jmp +oo
                long    i_inoutdx      |             %0_11111_11100_0 << 10 ' EC             in al, [dx]
                long    i_inoutdx      |             %0_11111_00000_0 << 10 ' ED             in ax, [dx]
                long    i_inoutdx      |             %0_11100_11111_0 << 10 ' EE             out al, [dx]
                long    i_inoutdx      |             %0_00000_11111_0 << 10 ' EF             out ax, [dx]

                long    i_lock         |                           %0 << 10 ' F0             lock
                long    i_lock         |                           %0 << 10 ' F1             lock
                long    i_repne        |                           %0 << 10 ' F2             repne
                long    i_repe         |                           %0 << 10 ' F3             repe
                long    i_hlt          |                           %0 << 10 ' F4             hlt
                long    i_cmc          |                           %0 << 10 ' F5             cmc
                long    i_prefixed_op  |                  %0_110_0000 << 10 ' F6
                long    i_prefixed_op  |                  %0_101_0000 << 10 ' F7
                long    i_clc          |                           %0 << 10 ' F8             clc
                long    i_stc          |                           %0 << 10 ' F9             stc
                long    i_cli          |                           %0 << 10 ' FA             cli
                long    i_sti          |                           %0 << 10 ' FB             sti
                long    i_cld          |                           %0 << 10 ' FC             cld
                long    i_std          |                           %0 << 10 ' FD             std
                long    i_fe_pre       |                           %0 << 10 ' FE             inc/dec [rm]
                long    i_prefixed_op  |                  %0_011_0000 << 10 ' FF             inc/dec/call/call far/jmp/jmp far/push/cmp [rm]

CON             ' 8086 Constants

    I_CF_BIT = 0    ' Carry
    I_PF_BIT = 2    ' Parity
    I_AF_BIT = 4    ' Aux. Carry
    I_ZF_BIT = 6    ' Zero
    I_SF_BIT = 7    ' Sign
    I_TF_BIT = 8    ' Trap
    I_IF_BIT = 9    ' Interrupt
    I_DF_BIT = 10   ' Direction
    I_OF_BIT = 11   ' Overflow

    I_LOCK_BIT   = 30
    I_NO_INT_BIT = 31

DAT ' System
                orgh

system_init
                getct   i_temp1
                addct1  i_temp1, ##trunc(_CLKFREQ / 18.2)
                ret

system_run

                ' irq7 - printer

                ' irq6 - floppy

                ' irq5 - hard disk

                ' irq4 - serial interface 1

                ' irq3 - serial interface 2

                ' irq1 - keyboard
                rdbyte  pa, #@kbd_tail
                rdbyte  pb, #@kbd_head
                cmp     pa, pb          wz
        if_nz   bith    pic_irq, #1         ' signal irq

                ' irq0 - timer
                pollct1                 wc
        if_c    getct   i_temp1
        if_c    addct1  i_temp1, ##trunc(_CLKFREQ / 18.2)
        if_c    bith    pic_irq, #0         ' signal irq

                testb   pic_ocw, #28        wc
                testb   i_flags, #I_IF_BIT  wz
   if_not_01    ret

                getbyte i_temp0, pic_icw, #1

                getbyte i_temp0, pic_icw, #1
                mov     i_temp1, #7
                rep     @.irq_loop, #8
                testb   pic_irq, i_temp1    wc
                testb   pic_ocw, i_temp1    wz
        if_10   bith    pic_ocw, #28        ' signal interrupt
        if_10   setnib  pic_ocw, i_temp1, #6' set interrupt served
        if_10   add     i_temp0, i_temp1
        if_10   jmp     #\i_trap
                sub     i_temp1, #1
.irq_loop

                ret

i_readiob
                ' i_ea   = address
                ' i_tmpb = data
                mov     i_tmpb, #$FF

                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_command_rd
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_data_rd

                cmp     i_ea, #$A0      wcz
        if_ae   cmpr    i_ea, #$AF      wcz
        if_ae   jmp     #\nmi_mask_rd

                cmp     i_ea, #$60      wcz
        if_e    jmp     #\ppa_8255a_rd
                cmp     i_ea, #$61      wcz
        if_e    jmp     #\ppa_8255b_rd
                cmp     i_ea, #$62      wcz
        if_e    jmp     #\ppa_8255c_rd
                cmp     i_ea, #$63      wcz
        if_e    jmp     #\ppa_8255_rd

                cmp     i_ea, ##$03DA   wcz
        if_e    jmp     #\cga_status_rd

                ret     wcz

i_writeiob
                ' i_ea   = address
                ' i_tmpb = data
                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_command_wr
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_data_wr

                cmp     i_ea, #$A0      wcz
        if_ae   cmpr    i_ea, #$AF      wcz
        if_ae   jmp     #\nmi_mask_wr

                cmp     i_ea, #$60      wcz
        if_e    jmp     #\ppa_8255a_wr
                cmp     i_ea, #$61      wcz
        if_e    jmp     #\ppa_8255b_wr
                cmp     i_ea, #$62      wcz
        if_e    jmp     #\ppa_8255c_wr
                cmp     i_ea, #$63      wcz
        if_e    jmp     #\ppa_8255_wr

                cmp     i_ea, ##$03D0   wcz
        if_ae   cmpr    i_ea, ##$03DF   wcz
        if_ae   jmp     #\cga_write
                ret     wcz

nmi_mask_wr
                wrbyte  i_tmpb, #@int_io_A0
                ret     wcz

nmi_mask_rd
                rdbyte  i_tmpb, #@int_io_A0
                ret     wcz

cga_write
                'debug("CGA     (W) ", uhex_word(i_cs,i_ip,i_ea),uhex_byte(i_tmpb))
                mov     pa, i_ea
                sub     pa, ##$03D0
                add     pa, #@cga_io_03D0
                wrbyte  i_tmpb, pa
                cmp     i_ea, ##$03D5   wcz
        if_ne   ret     wcz
                rdbyte  pa, #@cga_io_03D4
                cmp     pa, #17         wcz
        if_a    ret     wcz
                add     pa, #@cga_io_mc6845
                wrbyte  i_tmpb, pa
                ret     wcz

cga_status_rd
        _ret_   rdbyte  i_tmpb, #@cga_io_03DA

' PPA 8255A

ppa_8255a_rd
                mov     i_tmpb, #$00
                rdbyte  pa, #@kbd_tail
                rdbyte  pb, #@kbd_head
                cmp     pa, pb      wz
        if_e    jmp     #.empty

                add     pa, #@kbd_buffer
                rdbyte  i_tmpb, pa
                sub     pa, #@kbd_buffer
                incmod  pa, #7
                wrbyte  pa, #@kbd_tail
.empty
                ret     wcz

ppa_8255a_wr
                wrbyte  i_tmpb, #@ppa_io_60
                ret     wcz

ppa_8255b_rd
                rdbyte  i_tmpb, #@ppa_io_61
                ret     wcz

ppa_8255b_wr
                wrbyte  i_tmpb, #@ppa_io_61
                ret     wcz

ppa_8255c_rd
                rdbyte  i_tmpb, #@ppa_io_61
                testb   i_tmpb, #3      wc
        if_nc   mov     i_tmpb, #%00001100 ' Low switch
        if_c    mov     i_tmpb, #%00000010 ' High switch
                ret     wcz

ppa_8255c_wr
                ret     wcz

ppa_8255_rd
                rdbyte  i_tmpb, #@ppa_io_63
                ret     wcz

ppa_8255_wr
                wrbyte  i_tmpb, #@ppa_io_63
                ret     wcz

' PIC 8259A

pic_command_wr
                testb   i_tmpb, #4      wc
                testb   i_tmpb, #3      wz
        if_1x   mov     pic_icw, #0
        if_1x   mov     pic_ocw, #0
        if_1x   mov     pic_irq, #0
        if_1x   setbyte pic_icw, i_tmpb, #0 ' ICW1
        if_00   setbyte pic_ocw, i_tmpb, #1 ' OCW2
        if_01   setbyte pic_ocw, i_tmpb, #2 ' OCW3
    if_not_00   ret     wcz
                testb   i_tmpb, #5      wz
        if_x1   getnib  i_temp1, pic_ocw, #6
        if_x1   bitl    pic_irq, i_temp1
        if_x1   bitl    pic_ocw, #28        ' acknowledge interrupt
                ret     wcz

pic_data_wr
                bith    pic_ocw, #31    wcz
        if_0x   setbyte pic_icw, i_tmpb, #1 ' ICW2
        if_0x   ret     wcz

                bith    pic_ocw, #30    wcz
                testb   pic_icw, #1     wz
        if_00   setbyte pic_icw, i_tmpb, #2 ' ICW3
        if_01   setbyte pic_icw, i_tmpb, #3 ' ICW4
        if_01   bith    pic_ocw, #29
        if_0x   ret     wcz

                bith    pic_ocw, #29    wcz
        if_0x   setbyte pic_icw, i_tmpb, #3 ' ICW4
        if_0x   ret     wcz

                setbyte pic_ocw, i_tmpb, #0 ' OCW1 (IMR)
                ret     wcz

pic_command_rd
                testb   pic_ocw, #16 + 1    wc
                testb   pic_ocw, #16 + 0    wz
        if_11   getnib  i_tmpb, pic_ocw, #6
                ret     wcz

pic_data_rd
                setbyte i_tmpb, pic_ocw, #0 ' OCW1 (IMR)
                ret     wcz

cga_charrom     file    "CGA.F08"

rom_FE000       file    "BIOS.ROM"

ram_00000
                ' space used as
CON

                RAM_SIZE = $4_0000  ' 256K RAM
                CGA_VRAM = $0_4000  ' 16K CGA video ram
