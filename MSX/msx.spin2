{
    MSX Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Based on ZiKore Z80 Emulator by Ada Gottensträter
    with modifications by Marco Maccaferri

    TMS9918 Emulator by Marco Maccaferri
    AY-3-8912 Emulator by Johannes Ahlebrand, port to P2 by Ada Gottensträter
    PS/2 Keyboard driver by Marco Maccaferri
}
CON

    _CLKFREQ = 250_000_000

    VIDEO    = PAL ' video mode VGA, NTSC or PAL
    VGA_PIN  = 8
    CVBS_PIN = 53 addpins 1 ' 53=CVBS/Y, 54=C

    PS2_DATA_PIN  = 25
    PS2_CLOCK_PIN = 24

    AUDIO_LEFT_PIN  = 48
    AUDIO_RIGHT_PIN = 49


DAT             ' Startup
                org     $000

                asmclk
                drvl    #56
                drvl    #57

                rep     @.lockmadness,#16   ' allocate all locks, to be safe...
                locknew pb
                nop
.lockmadness

sys_reset
                cogid   #3      wc          ' check if user reset
                cogstop #3

        if_nc   coginit #1, ##@tms_driver   ' start video on cog #1

                setq    #@psg_regs
                coginit #2, ##@ay_emu       ' start AY-3-8912 on cog #2

                coginit #3, ##@zk_cogbase   ' start Z80 on cog #3

                jmp     #\ps2_driver        ' cog #0 (this) PS/2 keyboard

' Shared variables

zk_nmi_mem      long    0                   ' bit 8 = NMI
'zk_irq_mem      long    0                   ' bit 8 = IRQ, 7..0 vector

                                            '     D4 D3 D2 D1 D0
                                            '
msx_keys        byte    $FF[12]

' TMS9918 registers

tms_regs        byte    $00, $00, $00, $00, $00, $00, $00, $00
tms_status      long    $00     ' 7..0 = VDP status

' AY-3-8910 registers

psg_regs        byte    $00[14]
                byte    $FF ' port A
                byte    $FF ' port B

'
' PS/2 Keyboard river
'
ps2_driver
                fltl    #PS2_DATA_PIN
                fltl    #PS2_CLOCK_PIN

                mov     ps2_data, #$F3      ' auto-repeat
                call    #ps2_transmit
                and     ps2_data, #%011_11111 ' slow 1s / 2cps
                call    #ps2_transmit

                mov     ps2_state, #%0_000  ' turn off all leds
                jmp     #ps2_locks

ps2_reset
                setq    #3-1
                wrlong  msx_keys, #@msx_keys

ps2_loop        and     ps2_state, #$07     ' keep locks state

.l1             call    #ps2_receive
                getbyte ps2_code, ps2_data, #0

                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #.l1

                cmp     ps2_data, #$E0  wz
        if_z    bith    ps2_state, #28
        if_z    jmp     #ps2_ext0
                cmp     ps2_data, #$E1  wz
        if_z    bith    ps2_state, #29
        if_z    jmp     #ps2_ext1

ps2_ext_ret     testbn  ps2_state, #29  wz
        if_nz   jmp     #ps2_loop           ' E1 codes are ignored

                testb   ps2_state, #7   wc  ' release

                cmp     ps2_code, #$14  wz  ' left control
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_CTRL

                cmp     ps2_code, #$14  wz  ' right control
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_CTRL

                cmp     ps2_code, #$12  wz  ' left shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_SHIFT
                cmp     ps2_data, #$59  wz  ' right shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_SHIFT

                cmp     ps2_code, #$11  wz  ' left alt
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_ALT

                cmp     ps2_code, #$11  wz  ' right alt
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_ALT

                cmp     ps2_code, #$1F  wz  ' left gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_GUI
                cmp     ps2_code, #$27  wz  ' right gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_GUI

                cmp     ps2_code, #$77  wz  ' num. lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #0       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$58  wz  ' caps lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #1       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$7E  wz  ' scroll lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #2       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds

                test    ps2_shift, #LEFT_GUI  wz ' check reset key combination
        if_nz   test    ps2_shift, #RIGHT_GUI wz ' |
        if_nz   andn    ps2_shift, #LEFT_GUI|RIGHT_GUI
        if_nz   jmp     #sys_reset               ' jump to system reset

                testbn  ps2_state, #28  wc      ' extended code
                rcl     ps2_code, #1            '   to bit 0
                shl     ps2_code, #1

                mov     ps2_key, ##@ps2_table
                add     ps2_key, ps2_code
                rdword  ps2_key, ps2_key    wz
        if_z    jmp     #ps2_loop

                testb   ps2_state, #7   wc      ' release

                getnib  ps2_data, ps2_key, #2
                mov     ps2_ptr, #@msx_keys
                add     ps2_ptr, ps2_data
                rdbyte  ps2_temp, ps2_ptr
                muxc    ps2_temp, ps2_key
                wrbyte  ps2_temp, ps2_ptr
                jmp     #ps2_loop

ps2_locks       mov     ps2_data, #$ED
                call    #ps2_transmit
                mov     ps2_data, #0
                testb   ps2_state, #0   wz  ' num. lock
                bitz    ps2_data, #1
                testb   ps2_state, #1   wz  ' caps lock
                bitz    ps2_data, #2
                testb   ps2_state, #2   wz  ' scroll lock
                bitz    ps2_data, #0
                call    #ps2_transmit
                jmp     #ps2_loop

ps2_ext1        call    #ps2_receive
                setbyte ps2_code, ps2_data, #1
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext1

                ' fall through

ps2_ext0        call    #ps2_receive
                setbyte ps2_code, ps2_data, #0
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext0

                jmp     #ps2_ext_ret

ps2_transmit    drvl    #PS2_CLOCK_PIN      ' pull clock low
                getct   ps2_tout            ' hold clock for 128us (must be > 100us)
                addct1  ps2_tout, ps2_us128 ' |
                jnct1   #$
                drvl    #PS2_DATA_PIN       ' pull data low
                getct   ps2_tout            ' hold data for 4us
                addct1  ps2_tout, ps2_us4   ' |
                jnct1   #$

                fltl    #PS2_CLOCK_PIN      ' release clock
                getct   ps2_tout            ' allow pin to float
                addct1  ps2_tout, ps2_us1   ' |
                jnct1   #$

                test    ps2_data, #$FF  wc  ' append parity
                muxnc   ps2_data, #$100     ' |
                bith    ps2_data, #9        ' append stop bit

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #10
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                shr     ps2_data, #1    wc  ' output data bit
                drvc    #PS2_DATA_PIN       ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit ?

                fltl    #PS2_DATA_PIN

.l3             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data low
        if_z    testpn  #PS2_DATA_PIN   wz  ' |
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l3                ' |

.l4             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data high
        if_nz   testpn  #PS2_DATA_PIN   wz  ' |
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l4                ' |

                ' Fall through to receive ack

ps2_receive     testpn  #PS2_CLOCK_PIN  wz  ' wait initial clock low
        if_nz   jmp     #ps2_receive        ' |

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #11
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                testp   #PS2_DATA_PIN   wc  ' sample data
                rcr     ps2_data, #1        ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit?

                shr     ps2_data, #22       ' align byte
                test    ps2_data, #$1FF wc  ' test parity
        if_nc   jmp     #ps2_reset          ' |
        _ret_   and     ps2_data, #$FF      ' ok


ps2_us1         long    _CLKFREQ / 1000_000 * 1     ' 1 usec.
ps2_us4         long    _CLKFREQ / 1000_000 * 4     ' 4 usec.
ps2_us128       long    _CLKFREQ / 1000_000 * 128   ' 128 usec.
ps2_us2000      long    _CLKFREQ / 1000_000 * 4000  ' 2000 usec.

ps2_bits        long    0
ps2_code        long    0
ps2_state       long    0
ps2_shift       long    0
ps2_key         long    0

ps2_data        long    0
ps2_tout        long    0
ps2_temp        long    0
ps2_ptr         long    0

                fit     $1F0

DAT             ' PS/2 Lookup table
                orgh

{
            bit 7       bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0
    row 0       7 &     6 ^     5 %     4 $     3 #     2 @     1 !     0 )
    row 1       ; :     ] }     [ {     \ ¦     = +     - _     9 (     8 *
    row 2       B       A       DEAD    / ?     . >     , <     ` ~     ' "
    row 3       J       I       H       G       F       E       D       C
    row 4       R       Q       P       O       N       M       L       K
    row 5       Z       Y       X       W       V       U       T       S
    row 6       F3      F2      F1      CODE    CAPS    GRAPH   CTRL    SHIFT
    row 7       RET     SELECT  BS      STOP    TAB     ESC     F5      F4
    row 8       →       ↓       ↑       ←       DEL     INS     HOME    SPACE
    row 9       NUM4    NUM3    NUM2    NUM1    NUM0    NUM/    NUM+    NUM*
    row 10      NUM.    NUM,    NUM-    NUM9    NUM8    NUM7    NUM6    NUM5

}

'                         ROW B7....B0    ROW B7....B0

ps2_table       word    %0000_00000000, %0000_00000000    '00
                word    %0000_00000000, %0000_00000000    '01             F9
                word    %0000_00000000, %0000_00000000    '02
                word    %0000_00000000, %0111_00000010    '03             F5
                word    %0000_00000000, %0110_10000000    '04             F3
                word    %0000_00000000, %0110_00100000    '05             F1
                word    %0000_00000000, %0110_01000000    '06             F2
                word    %0000_00000000, %0000_00000000    '07             F12
                word    %0000_00000000, %0000_00000000    '08
                word    %0000_00000000, %0000_00000000    '09             F10
                word    %0000_00000000, %0000_00000000    '0A             F8
                word    %0000_00000000, %0000_00000000    '0B             F6
                word    %0000_00000000, %0111_00000001    '0C             F4
                word    %0000_00000000, %0111_00001000    '0D             Tab
                word    %0000_00000000, %0010_00000010    '0E             `
                word    %0000_00000000, %0000_00000000    '0F
                word    %0000_00000000, %0000_00000000    '10
                word    %0110_00000100, %0110_00000100    '11     Alt-R   Alt-L
                word    %0000_00000000, %0110_00000001    '12             Shift-L
                word    %0000_00000000, %0000_00000000    '13
                word    %0110_00000010, %0110_00000010    '14     Ctrl-R  Ctrl-L
                word    %0000_00000000, %0100_01000000    '15             q
                word    %0000_00000000, %0000_00000010    '16             1
                word    %0000_00000000, %0000_00000000    '17
                word    %0000_00000000, %0000_00000000    '18
                word    %0000_00000000, %0000_00000000    '19
                word    %0000_00000000, %0101_10000000    '1A             z
                word    %0000_00000000, %0101_00000001    '1B             s
                word    %0000_00000000, %0010_01000000    '1C             a
                word    %0000_00000000, %0101_00010000    '1D             w
                word    %0000_00000000, %0000_00000100    '1E             2
                word    %0000_00000000, %0000_00000000    '1F     Win-L
                word    %0000_00000000, %0000_00000000    '20
                word    %0000_00000000, %0011_00000001    '21             c
                word    %0000_00000000, %0101_00100000    '22             x
                word    %0000_00000000, %0011_00000010    '23             d
                word    %0000_00000000, %0011_00000100    '24             e
                word    %0000_00000000, %0000_00010000    '25             4
                word    %0000_00000000, %0000_00001000    '26             3
                word    %0000_00000000, %0000_00000000    '27     Win-R
                word    %0000_00000000, %0000_00000000    '28
                word    %0000_00000000, %1000_00000001    '29             Space
                word    %0000_00000000, %0101_00001000    '2A             v
                word    %0000_00000000, %0011_00001000    '2B             f
                word    %0000_00000000, %0101_00000010    '2C             t
                word    %0000_00000000, %0100_10000000    '2D             r
                word    %0000_00000000, %0000_00100000    '2E             5
                word    %0010_00100000, %0000_00000000    '2F     Apps
                word    %0000_00000000, %0000_00000000    '30
                word    %0000_00000000, %0100_00001000    '31             n
                word    %0000_00000000, %0010_10000000    '32             b
                word    %0000_00000000, %0011_00100000    '33             h
                word    %0000_00000000, %0011_00010000    '34             g
                word    %0000_00000000, %0101_01000000    '35             y
                word    %0000_00000000, %0000_01000000    '36             6
                word    %0000_00000000, %0000_00000000    '37     Power
                word    %0000_00000000, %0000_00000000    '38
                word    %0000_00000000, %0000_00000000    '39
                word    %0000_00000000, %0100_00000100    '3A             m
                word    %0000_00000000, %0011_10000000    '3B             j
                word    %0000_00000000, %0101_00000100    '3C             u
                word    %0000_00000000, %0000_10000000    '3D             7
                word    %0000_00000000, %0001_00000001    '3E             8
                word    %0000_00000000, %0000_00000000    '3F     Sleep
                word    %0000_00000000, %0000_00000000    '40
                word    %0000_00000000, %0010_00000100    '41             ,
                word    %0000_00000000, %0100_00000001    '42             k
                word    %0000_00000000, %0011_01000000    '43             i
                word    %0000_00000000, %0100_00010000    '44             o
                word    %0000_00000000, %0000_00000001    '45             0
                word    %0000_00000000, %0001_00000010    '46             9
                word    %0000_00000000, %0000_00000000    '47
                word    %0000_00000000, %0000_00000000    '48
                word    %0000_00000000, %0010_00001000    '49             .
                word    %1001_00000100, %0010_00010000    '4A     (/)     /
                word    %0000_00000000, %0100_00000010    '4B             l
                word    %0000_00000000, %0001_10000000    '4C             ;
                word    %0000_00000000, %0100_00100000    '4D             p
                word    %0000_00000000, %0001_00000100    '4E             -
                word    %0000_00000000, %0000_00000000    '4F
                word    %0000_00000000, %0000_00000000    '50
                word    %0000_00000000, %0000_00000000    '51
                word    %0000_00000000, %0010_00000001    '52             '
                word    %0000_00000000, %0000_00000000    '53
                word    %0000_00000000, %0001_00100000    '54             [
                word    %0000_00000000, %0001_00001000    '55             =
                word    %0000_00000000, %0000_00000000    '56
                word    %0000_00000000, %0000_00000000    '57
                word    %0000_00000000, %0110_00010000    '58             CapsLock
                word    %0000_00000000, %0110_00000001    '59             Shift-R
                word    %0111_10000000, %0111_10000000    '5A     (Enter) Enter
                word    %0000_00000000, %0001_01000000    '5B             ]
                word    %0000_00000000, %0000_00000000    '5C
                word    %0000_00000000, %0001_00010000    '5D             \
                word    %0000_00000000, %0000_00000000    '5E     WakeUp
                word    %0000_00000000, %0000_00000000    '5F
                word    %0000_00000000, %0000_00000000    '60
                word    %0000_00000000, %0000_00000000    '61
                word    %0000_00000000, %0000_00000000    '62
                word    %0000_00000000, %0000_00000000    '63
                word    %0000_00000000, %0000_00000000    '64
                word    %0000_00000000, %0000_00000000    '65
                word    %0000_00000000, %0111_00100000    '66             BackSpace
                word    %0000_00000000, %0000_00000000    '67
                word    %0000_00000000, %0000_00000000    '68
                word    %0000_00000000, %1001_00010000    '69     End     (1)
                word    %0000_00000000, %0000_00000000    '6A
                word    %1000_00010000, %1001_10000000    '6B     Left    (4)
                word    %1000_00000010, %1010_00000100    '6C     Home    (7)
                word    %0000_00000000, %0000_00000000    '6D
                word    %0000_00000000, %0000_00000000    '6E
                word    %0000_00000000, %0000_00000000    '6F
                word    %1000_00000100, %1001_00001000    '70     Insert  (0)
                word    %1000_00001000, %1010_10000000    '71     Delete  (.)
                word    %1000_01000000, %1001_00100000    '72     Down    (2)
                word    %0000_00000000, %1010_00000001    '73             (5)
                word    %1000_10000000, %1010_00000010    '74     Right   (6)
                word    %1000_00100000, %1010_00001000    '75     Up      (8)
                word    %0000_00000000, %0111_00000100    '76             Esc
                word    %0000_00000000, %0000_00000000    '77             NumLock
                word    %0000_00000000, %0000_00000000    '78             F11
                word    %0000_00000000, %1001_00000010    '79             (+)
                word    %0000_00000000, %1001_01000000    '7A     PageDn  (3)
                word    %0000_00000000, %1010_00100000    '7B             (-)
                word    %0000_00000000, %1001_00000001    '7C     PrScr   (*)
                word    %0000_00000000, %1010_00010000    '7D     PageUp  (9)
                word    %0000_00000000, %0000_00000000    '7E             ScrLock
                word    %0000_00000000, %0000_00000000    '7F
                word    %0000_00000000, %0000_00000000    '80
                word    %0000_00000000, %0000_00000000    '81
                word    %0000_00000000, %0000_00000000    '82
                word    %0000_00000000, %0000_00000000    '83             F7

CON

    LEFT_CTRL   = %0000_0001
    LEFT_SHIFT  = %0000_0010
    LEFT_ALT    = %0000_0100
    LEFT_GUI    = %0000_1000
    RIGHT_CTRL  = %0001_0000
    RIGHT_SHIFT = %0010_0000
    RIGHT_ALT   = %0100_0000
    RIGHT_GUI   = %1000_0000

DAT             ' ZiKore Z80 COG resident code
                org     $000

zk_cogbase
                add     ptrb, ##@zk_lutbase - @zk_cogbase
                setq2   #511
                rdlong  0, ptrb

                mov     zk_cycles, #5
                getct   zk_lastwait

zk_nextop
                lockrel #0                      ' release lock

                mul     zk_cycles, zk_cycletime
                addct1  zk_lastwait, zk_cycles
                waitct1

                locktry #0              wc      ' acquire lock for instruction processing
    if_nc       jmp     #$-1

                mov     zk_cycles, #0

                testb   zk_nmi_ctl, #8      wc  ' C = old NMI
                rdlong  zk_nmi_ctl, #@zk_nmi_mem
                testb   zk_nmi_ctl, #8      wz  ' Z = current NMI
        if_01   jmp     #\zk_donmi              ' jump if 0 -> 1 transition

                testb   zk_irqenable,#ZK_IFF1_BIT wz   ' Z = EI
                rdlong  zk_irq_ctl, #@tms_status
                testb   zk_irq_ctl, #8          andz   ' Z = EI and IRQ
        if_x1   jmp     #\zk_doirq                     ' jump if Z=1

                mov     zk_temphl, zk_hl
                mov     zk_hlptr, #zk_hl
                mov     zk_tempidx, zk_hl
                mov     zk_prefix, #0
                incmod  zk_refresh, #127

                call    #zk_readcode
                add     zk_cycles, #1
                mov     zk_opcode, zk_tmp8
                'debug(uhex_byte(zk_opcode))
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                'debug(uhex_long(zk_opimpl))
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
                push    #zk_nextop
                execf   zk_opimpl

zk_iyprefix
                mov     zk_hlptr, #zk_iy
zk_ixprefix
                mov     zk_hlptr, #zk_ix

                mov     zk_prefix, zk_opcode
                incmod  zk_refresh, #127
                add     zk_cycles, #1

                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc   jmp     #.nodisplace
                ' handle index displacement
                mov     zk_temphl, zk_hl
                alts    zk_hlptr
                mov     zk_tempidx, 0-0
                mov     zk_hlptr, #zk_hl
                call    #zk_readcode
                signx   zk_tmp8, #7
                add     zk_tempidx, zk_tmp8
                execf   zk_opimpl

.nodisplace
                alts    zk_hlptr
                mov     zk_temphl, 0-0
                mov     zk_tempidx, zk_temphl
                execf   zk_opimpl

zk_bitprefix
                call    #\zk_readcode
                mov     zk_opcode, zk_tmp8
                add     zk_cycles, #1
                incmod  zk_refresh, #127

                cmp     zk_prefix, #0 wz
        if_z    call    #zk_getrz
        if_nz   call    #zk_read8hl

                mov     pa, zk_opcode
                shr     pa, #3
                and     pa, #7

                testb   zk_opcode, #7 wc
                testb   zk_opcode, #6 wz
        if_00   jmp     #.shift
        if_01   jmp     #.bit
                bitz    zk_tmp8, pa
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix, #0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

.bit
                decod   pa
                and     pa, zk_tmp8 wz
                muxz    zk_flags, #(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
                bitl    zk_flags, #ZK_NMODE_BIT
                bith    zk_flags, #ZK_HALF_BIT
                setq    #1<<ZK_SIGN_BIT
                muxq    zk_flags, pa
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags, zk_tmp8

.shift
                push    #.shiftdone
                altd    pa, #zk_shift_impl_tbl
                execf   0-0

.shiftdone
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix,#0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

zk_shift_impl_tbl
                long    zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
                long    zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
                long    zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
                long    zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
                long    zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
                long    zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
                long    zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
                long    zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL

zk_extprefix
                call #\zk_readcode
                mov zk_opcode,zk_tmp8
                add zk_cycles,#1
                incmod zk_refresh,#127
                'debug("extend ",uhex_byte(zk_opcode))

                cmp zk_opcode,#$A0 wc
        if_ae   jmp #.blockop
                cmp zk_opcode,#$40 wc
        if_b    ret

                mov pa,zk_opcode
                and pa,#7
                altd pa,#zk_ext_impl_tbl
                execf 0-0

.blockop
                '' The undocumented flags on these are cursed.
                test    zk_opcode,#%0100_0100 wz
        if_nz   ret     ' NOP
                rczr    zk_opcode wcz ' get operation type into cz
        if_00   add     zk_cycles,#2
        if_01   add     zk_cycles,#5
        if_1x   add     zk_cycles,#1
        if_00   skipf   ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01   skipf   ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10   skipf   ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11   skipf   ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

                getword zk_ea,zk_debc,#0 ' IN
                call    #\zk_portin ' IN
                call    #\zk_read8hl ' everything else

                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
                bith    zk_flags,#ZK_NMODE_BIT ' CP
                testb   zk_tmp8,#7 wc ' IN/OUT
                bitc    zk_flags,#ZK_NMODE_BIT ' IN/OUT

                mov     zk_optmp0,zk_accu ' LD CP
                getbyte zk_optmp0,zk_hl,#0 ' OUT
                getbyte zk_optmp0,zk_debc,#0 ' IN
                testb   zk_opcode,#1 wc ' IN
                sumc    zk_optmp0,#1 ' IN
                mov     zk_optmp1,zk_tmp8 ' CP
                xor     zk_optmp1,zk_optmp0 ' CP

                sub     zk_optmp0,zk_tmp8 ' CP only
                add     zk_optmp0,zk_tmp8 ' LD,IN,OUT

                xor     zk_optmp1,zk_optmp0 ' CP
                and     zk_optmp0,#255 wz ' CP,IN,OUT
                bitz    zk_flags,#ZK_ZERO_BIT ' CP
                testb   zk_optmp0,#7 wc ' CP
                bitc    zk_flags,#ZK_SIGN_BIT ' CP

                testb   zk_optmp1,#4 wc   ' CP
                cmpr    zk_optmp0,#255 wc  ' IN/OUT
                bitc    zk_flags,#ZK_HALF_BIT ' CP
                muxc    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c    sub     zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

                skipf   ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
                skipf   ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
                skipf   ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
                skipf   ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


                testb   zk_optmp0,#1 wc ' LD,CP
                bitc    zk_flags,#5 'LD,CP (sets YF)
                testb   zk_optmp0,#3 wc ' LD,CP
                bitc    zk_flags,#3 'LD,CP (sets XF)

                getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
                and     zk_optmp0,#7 ' IN,OUT
                xor     zk_optmp0,zk_optmp1 wc ' IN,OUT
                bitnc   zk_flags,#ZK_OVER_BIT ' IN,OUT

                mov     zk_ea,zk_hl  ' IN
                getword zk_ea,zk_debc,#1 ' LD
                call    #\zk_write8 ' LD,IN
                getword zk_ea,zk_debc,#0 ' OUT
                call    #\zk_portout ' OUT

                getword zk_optmp1,zk_debc,#0 ' LD,CP
                decmod  zk_optmp1,zk_ffffh wz ' all
                setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
                setword zk_debc,zk_optmp1,#0 ' LD,CP
                bitnz   zk_flags,#ZK_OVER_BIT ' LD,CP
                bitz    zk_flags,#ZK_ZERO_BIT ' IN,OUT
                setq    #ZK_SIGNXYMASK ' IN,OUT
                muxq    zk_flags,zk_optmp1 ' IN,OUT

                testb   zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
                testb   zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc   incmod  zk_ea,zk_ffffh    ' LD
        if_c    decmod  zk_ea,zk_ffffh    ' LD
                setword zk_debc,zk_ea,#1 ' LD

        if_nc   incmod  zk_hl,zk_ffffh
        if_c    decmod  zk_hl,zk_ffffh

                testb   zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz    sub     zk_pc,#2
 if_c_and_nz    add     zk_cycles,#5
                'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
                ret

zk_ext_impl_tbl
                long    zk_cio + (%10_11_111_000000<<10) ' IN [BCDEHL0A],(C)
                long    zk_cio + (%00_01_111_000000<<10) ' OUT (C),[BCDEHL0A]
                long    zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
                long    zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
                long    zk_neg
                long    zk_irqret
                long    zk_imode
                long    zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7

                altd    pa,#zk_extmath16_impl_tbl
                altd    pa,#zk_extld16_impl_tbl
                altd    pa,#zk_extmisc_impl_tbl

                execf   0-0

zk_extmath16_impl_tbl
                long    zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
                long    zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
                long    zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
                long    zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
                long    zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
                long    zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
                long    zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
                long    zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
                long    zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
                long    zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
                long    zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
                long    zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
                long    zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
                long    zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
                long    zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
                long    zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
                long    zk_a2i                       ' LD I,A
                long    zk_a2r                       ' LD R,A
                long    zk_i2a                       ' LD A,I
                long    zk_r2a  + (%1_000<<10)       ' LD A,R
                long    zk_rxd + (%000_111_00<<10)   ' RRD
                long    zk_rxd + (%111_000_00<<10)   ' RLD
                long    zk_nextop                    ' NOP
                long    zk_nextop                    ' NOP

zk_rxd
                call    #\zk_read8hl
                add     zk_cycles,#4
                ' RLD
                rolnib  zk_tmp8,zk_accu,#0
                getnib  pa,zk_tmp8,#2
                setnib  zk_tmp8,#0,#2
                ' RRD
                setnib  zk_tmp8,zk_accu,#2
                getnib  pa,zk_tmp8,#0
                shr     zk_tmp8,#4

                setnib  zk_accu,pa,#0
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_accu
                jmp     #\zk_write8hl

zk_a2r
                mov     zk_refresh,zk_accu
                and     zk_refresh,#$7F
        _ret_   mov     zk_refreshhi,zk_accu

zk_a2i
        _ret_   mov     zk_ivector,zk_accu

zk_r2a
                mov     zk_accu,zk_refresh
                setq    #$80
                muxq    zk_accu,zk_refreshhi
zk_i2a
                mov     zk_accu,zk_ivector

                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_irqret       '' RETI/RETN
                '' These are literally the same
                testb   zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_irqenable,#ZK_IFF1_BIT
                call    #\zk_pop16
        _ret_   mov     zk_pc,zk_tmp16


zk_imode
                cmp     zk_opcode,#$5E  wz
        if_nz   cmp     zk_opcode,#$7E  wz
                bitz    zk_irqenable,#ZK_IM2_BIT
                ret

zk_irqoff
        _ret_   andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_irqon
        _ret_   or      zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_doirq
                add     zk_cycles,#1
                test    zk_irqenable,#(1<<ZK_IM2_BIT)  wz
        if_z    skipf   ##%0_1_1111_0_000000_1111
        if_nz   skipf   ##%0_1_0000_1_000000_11

zk_donmi
                skipf   ##%0_0_1111_1_000000

                add     zk_cycles,#5
                test    zk_irqenable,#(1<<ZK_HALT_BIT)  wz
        if_nz   incmod  zk_pc,zk_ffffh
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_HALT_BIT)
                mov     zk_tmp16,zk_pc
                call    #\zk_push16

                mov     zk_pc,#$38 ' IM1/IM0

                getbyte zk_ea, zk_irq_ctl, #0 ' IM2
                setbyte zk_ea, zk_ivector, #1 ' IM2
                call    #\zk_read16 ' IM2
                mov     zk_pc, zk_tmp16 ' IM2

                mov     zk_pc,#$66 ' NMI

                jmp     #\zk_nextop

zk_jump_indir
        _ret_   mov     zk_pc,zk_temphl
zk_hl_to_sp
                add     zk_cycles,#2
        _ret_   mov     zk_sp,zk_temphl

zk_jump
                call    #\zk_readcode16
zk_condret
                add     zk_cycles,#1 ' Extra cycle in conditional RET

                testb   zk_flags,#ZK_ZERO_BIT wc
                testb   zk_flags,#ZK_CARRY_BIT wc
                testb   zk_flags,#ZK_OVER_BIT wc
                testb   zk_flags,#ZK_SIGN_BIT wc

                modc    _nc wc
        if_c    call    #\zk_nextop
zk_ret
                call    #zk_pop16
                mov     zk_optmp0,zk_tmp16 ' For every op!
zk_rst
                mov     zk_optmp0,zk_opcode
                and     zk_optmp0,#%00111000
zk_pushjmp
                mov     zk_tmp16,zk_pc
                mov     zk_pc,zk_optmp0
                jmp     #\zk_push16
                ret

zk_getrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                'debug("in zk_getrz ",uhex_byte(pa))
                add     pa,#zk_getrpa-$-1
                jmprel  pa
zk_getry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
zk_getrpa
                jmprel  pa
        _ret_   getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_   getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_   getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_   getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_   getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_   getbyte zk_tmp8,zk_temphl,#0 ' L register
                jmp     #zk_read8hl              ' (HL)
        _ret_   getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                add     pa,#zk_setrpa-$-1
                jmprel  pa
zk_setry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
                'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa       jmprel  pa
        _ret_   setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_   setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_   setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_   setbyte zk_debc,zk_tmp8,#2   ' E register
                jmp     #.seth                   ' H register
                jmp     #.setl                   ' L register
                jmp     #zk_write8hl             ' (HL)
        _ret_   setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
                setbyte zk_temphl,zk_tmp8,#1
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl
.setl
                setbyte zk_temphl,zk_tmp8,#0
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_push16
                add     zk_cycles,#1
                sub     zk_sp,#2
                setword zk_sp,#0,#1
                mov     zk_ea,zk_sp
                jmp     #zk_write16
zk_pop16
                mov     zk_ea,zk_sp
                add     zk_sp,#2
                setword zk_sp,#0,#1
                jmp     #zk_read16

zk_read16hl
                getword zk_ea,zk_tempidx,#0
zk_read16
                call    #zk_read8
                getbyte zk_tmp16,zk_tmp8,#0
                add     zk_ea,#1
                call    #zk_read8
                setbyte zk_tmp16,zk_tmp8,#1
        _ret_   sub     zk_ea,#1

zk_read8hl
                getword zk_ea,zk_tempidx,#0
                jmp     #zk_read8
zk_readcode
                mov     zk_ea,zk_pc
                incmod  zk_pc,zk_ffffh
                'setword zk_pc,#0,#1
                ' fall through
zk_read8
                add     zk_cycles, #3
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_00   jmp     #\msx_read8_0000
        if_01   jmp     #\msx_read8_4000
        if_10   jmp     #\msx_read8_8000
        if_11   jmp     #\msx_read8_C000
'                getword pa, zk_ea, #0
'                add     pa, zk_ram
'                rdbyte  zk_tmp8, pa
'                debug(uhex_word(zk_ea), uhex_byte(zk_tmp8), uhex_long(pa), dly(#500))
'                ret     wcz

zk_readcode16
                call    #zk_readcode
                getbyte zk_tmp16,zk_tmp8,#0
                call    #zk_readcode
        _ret_   setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
                getword zk_ea,zk_tempidx,#0
zk_write16
                getbyte zk_tmp8,zk_tmp16,#0
                call    #zk_write8
                add     zk_ea,#1
                getbyte zk_tmp8,zk_tmp16,#1
                call    #zk_write8
        _ret_   sub     zk_ea,#1

zk_write8hl
                getword zk_ea,zk_tempidx,#0
zk_write8
                add     zk_cycles, #3
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_00   jmp     #\msx_write8_0000
        if_01   jmp     #\msx_write8_4000
        if_10   jmp     #\msx_write8_8000
        if_11   jmp     #\msx_write8_C000
'                getword pa, zk_ea, #0
'                cmp     pa, ##$4000     wcz
'        if_ae   add     pa, zk_ram
'        if_ae   wrbyte  zk_tmp8, pa
'                ret     wcz

zk_portout
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                getbyte pa, zk_ea, #0

                cmp     pa, #$98     wcz
        if_e    jmp     #\tms_ram_wr                ' 98 = video ram write
                cmp     pa, #$99     wcz
        if_e    jmp     #\tms_ctl_wr                ' 99 = video register write

                cmp     pa, #$A0     wcz
        if_e    jmp     #\psg_reg_write             ' A0 = psg register write
                cmp     pa, #$A1     wcz
        if_e    jmp     #\psg_write                 ' A1 = psg value write

                cmp     pa, #$A8     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #0
                cmp     pa, #$A9     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #1
                cmp     pa, #$AA     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #2
                cmp     pa, #$AB     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #3

                ret     wcz

zk_portin
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                mov     zk_tmp8, #$FF
                getbyte pa, zk_ea, #0

                cmp     pa, #$98     wcz
        if_e    jmp     #\tms_ram_rd                ' 98 = video ram read
                cmp     pa, #$99     wcz
        if_e    jmp     #\tms_status_rd             ' 99 = video status read

                cmp     pa, #$A2     wcz
        if_e    jmp     #\psg_read                  ' A2 = psg value read

                cmp     pa, #$A8     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #0
                cmp     pa, #$A9     wcz            ' keyboard row read
        if_e    jmp     #\msx_kb_read
                cmp     pa, #$AA     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #2
                cmp     pa, #$AB     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #3

                ret     wcz

zk_ffffh        long    $FFFF
zk_18000h       long    $18000
zk_bit31        long    negx

zk_cycles       long    5
zk_pc           long    $0000

zk_flags        long    0
zk_accu         long    0
zk_debc         long    0
zk_sp           long    $F000
zk_hl           long    0
zk_ix           long    0
zk_iy           long    0
zk_altflags     long    0
zk_altaccu      long    0
zk_altdebc      long    0
zk_althl        long    0
zk_refresh      long    0
zk_refreshhi    long    0
zk_ivector      long    0
zk_irqenable    long    0

zk_cycletime    long    _CLKFREQ / ZK_CLOCK ' round(float(_CLKFREQ) / float(ZK_CLOCK) * 256.0)

msx_ppi         long    $00_00_00_00

msx_psg_latch   long    0

tms_flag        long    0
tms_ramptr      long    0
tms_tmp0        long    0
tms_tmp1        long    0

zk_lastwait     res     1

zk_opcode       res     1
zk_opimpl       res     1
zk_prefix       res     1
zk_temphl       res     1
zk_tempidx      res     1
zk_hlptr        res     1
zk_tmp16        res     1

zk_optmp0       res     1
zk_optmp1       res     1

zk_tmp0         res     1
zk_tmp8         res     1 ' memory read/write value
zk_ea           res     1 ' remapped EA
zk_irq_ctl      res     1
zk_nmi_ctl      res     1

                fit     $1F0

DAT             ' ZiKore Z80 LUT resident code
                org     $200
zk_lutbase

zk_rolla        mov     zk_tmp8,zk_accu
zk_shiftop
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

                bitl    zk_tmp8,#7 wcz  ' left + SRA
                bitz    zk_tmp8,#7 addbits 1 ' only SRA
                bitl    zk_tmp8,#0 wcz  ' right
                modc    _set wc ' only SLL
                modc    _clr wc ' only SLA

                testb   zk_flags,#ZK_CARRY_BIT wc' only RL/RR
                bitz    zk_flags,#ZK_CARRY_BIT

                rcl     zk_tmp8,#1 wz   ' left
                bitc    zk_tmp8,#8     ' right (not SRA/SRL)
                shr     zk_tmp8,#1 wz   ' right

                setq    #ZK_XYMASK
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

        _ret_   mov     zk_accu,zk_tmp8

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_tmp8,#$FF wc
        _ret_   bitnc   zk_flags,#ZK_OVER_BIT

zk_cio
                mov     zk_optmp1,zk_opcode
                and     zk_optmp1,#7<<3
                cmp     zk_optmp1,#6<<3 wz
                mov     zk_tmp8,#0
        if_nz   call    #\zk_getry
                getword zk_ea,zk_debc,#0
zk_immio
                call    #\zk_readcode
                mov     zk_ea,zk_tmp8
                setbyte zk_ea,zk_accu,#1

                mov     zk_tmp8,zk_accu
                jmp     #\zk_portout

                call    #\zk_portin
        _ret_   mov     zk_accu,zk_tmp8

                and     zk_tmp8,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

                cmp     zk_optmp1,#6<<3 wz
        if_z    ret
                jmp     #\zk_setry

zk_incdec8
                call    #\zk_getry
                mov     zk_optmp0,#1
zk_math8
                call    #\zk_getrz
zk_immmath
                call    #\zk_readcode
                mov     zk_optmp0,zk_tmp8
                mov     zk_tmp8,zk_accu

                modc    _clr wc
                testb   zk_flags,#ZK_CARRY_BIT wc

                ' Flag helper gunk
                mov     zk_optmp1,zk_tmp8

                addx    zk_tmp8,zk_optmp0
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_tmp8,zk_optmp0
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_tmp8
                test    zk_tmp8,#$100 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                and     zk_tmp8,#255 wz

                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8
                ' Special nonsense for CP
                setq    #ZK_XYMASK
                muxq    zk_flags,zk_optmp0

                mov     zk_accu,zk_tmp8
                call    #\zk_setry

                xor     zk_optmp1,zk_optmp0
                bitz    zk_flags,#ZK_ZERO_BIT
                testb   zk_optmp1,#4 wc
                bitc    zk_flags,#ZK_HALF_BIT
                test    zk_optmp1,#$180 wc
        _ret_   bitc    zk_flags,#ZK_OVER_BIT

zk_neg
                cmp     zk_accu,#$80 wz
                bitz    zk_flags,#ZK_OVER_BIT
                testb   zk_accu,#4 wz
                subr    zk_accu,#0 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                testb   zk_accu,#4 xorz
                bitz    zk_flags,#ZK_HALF_BIT
                and     zk_accu,#$FF wz
                bitz    zk_flags,#ZK_ZERO_BIT
                bith    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu


zk_cpl
                xor     zk_accu,#$FF
                or      zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_math16
                modc    _clr wc
zk_cmath16
                testb   zk_flags,#ZK_CARRY_BIT wc

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                mov     zk_optmp1,zk_temphl
                xor     zk_optmp1,zk_tmp16

                addx    zk_temphl,zk_tmp16
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_temphl,zk_tmp16
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_temphl
                and     zk_temphl,zk_ffffh wz

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_optmp1,zk_18000h wc
                bitc    zk_flags,#ZK_OVER_BIT

                getbyte pa,zk_temphl,#1
                setq    #ZK_SIGNXYMASK
                setq    #ZK_XYMASK
                muxq    zk_flags,pa

                testb   zk_optmp1,#12 wc
                bitc    zk_flags,#ZK_HALF_BIT
                testb   zk_optmp1,#16 wc
                bitc    zk_flags,#ZK_CARRY_BIT

                add     zk_cycles,#7

                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_daa
                mov     zk_optmp0,#$00
                mov     zk_tmp8,zk_accu
                cmpr    zk_tmp8,#$99 wc
                testb   zk_flags,#ZK_CARRY_BIT orc
        if_c    add     zk_optmp0,#$60
                bitc    zk_flags,#ZK_CARRY_BIT
                getnib  zk_optmp1,zk_tmp8,#0
                cmpr    zk_optmp1,#$9 wc
                testb   zk_flags,#ZK_HALF_BIT orc
        if_c    add     zk_optmp0,#$06
                testb   zk_flags,#ZK_NMODE_BIT wc
                sumc    zk_accu,zk_optmp0
                and     zk_accu,#255 wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT ' Parity?
                testb   zk_accu,#4 wc
                testb   zk_tmp8,#4 xorc
                bitc    zk_flags,#ZK_HALF_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_immlogic
                call    #\zk_readcode
zk_logic
                call    #\zk_getrz

                and     zk_accu,zk_tmp8 wcz
                or      zk_accu,zk_tmp8 wcz
                xor     zk_accu,zk_tmp8 wcz

                bitnc   zk_flags,#ZK_OVER_BIT ' parity
                bitz    zk_flags,#ZK_ZERO_BIT
                andn    zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                bith    zk_flags,#ZK_HALF_BIT ' Only for AND
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_pushaf
                getbyte zk_tmp16,zk_accu,#0
                rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
                add     zk_cycles,#2
zk_pushbc       getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde       getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl       mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                jmp     #\zk_push16

                add     zk_tmp16,#1
                sub     zk_tmp16,#1

zk_loadimm16
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16   ' for LDs with (imm16)
                call    #\zk_read16     ' ^^
                jmp     #\zk_write16     ' ^^
zk_poppair
                call    #\zk_pop16

        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

                getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_   getbyte zk_flags,zk_tmp16,#0  ' set F

zk_jr           '' JR and DJNZ
                call    #\zk_readcode

                getbyte pa,zk_debc,#1
                sub     pa,#1 wz
                setbyte zk_debc,pa,#1
                add     zk_cycles,#1

                testb   zk_flags,#ZK_ZERO_BIT wz
                testb   zk_flags,#ZK_CARRY_BIT wz

                modz    _nz wz
        if_z    call    #\zk_nextop
                ' branch taken
                add     zk_cycles,#5
                signx   zk_tmp8,#7
        _ret_   add     zk_pc,zk_tmp8

zk_exx          '' EXX
                xor     zk_debc,zk_altdebc
                xor     zk_altdebc,zk_debc
                xor     zk_debc,zk_altdebc
                ' Note: not affected by IX/IY substitution
                xor     zk_hl,zk_althl
                xor     zk_althl,zk_hl
        _ret_   xor     zk_hl,zk_althl

zk_ex_dehl      '' EX DE,HL
                ' Note: not affected by IX/IY substitution
                getword zk_optmp0,zk_debc,#1
                setword zk_debc,zk_hl,#1
        _ret_   mov     zk_hl,zk_optmp0


zk_ex_hlstk     '' EX (SP),HL
                add     zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
                mov     zk_ea,zk_sp
                call    #\zk_read16
                altd    zk_hlptr
                mov     0-0,zk_tmp16
                mov     zk_tmp16,zk_temphl
                jmp     #\zk_write16

zk_ld_abs16     '' LD HL,(imm16) and LD (imm16),HL
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl ' get HL/I*
                mov     zk_tmp16,zk_sp ' get SP
                jmp     #\zk_write16

                call    #\zk_read16
        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   mov     zk_sp,zk_tmp16

zk_scf
                modc    _clr wc
zk_ccf
                testb   zk_flags,#ZK_CARRY_BIT wc
                bitnc   zk_flags,#ZK_CARRY_BIT
                bitc    zk_flags,#ZK_HALF_BIT
                bitl    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_ld_abs       '' LD A,(imm16) and LD (imm16),A
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16
zk_a_and_ptr    '' A and (BC)/(DE) ops
                getword zk_ea,zk_debc,#0 ' get BC
                getword zk_ea,zk_debc,#1 ' get DE
                call    #\zk_read8
        _ret_   mov     zk_accu,zk_tmp8
                mov     zk_tmp8,zk_accu
                jmp     #\zk_write8

zk_regmove
                push    #zk_setry
                jmp     #\zk_getrz

zk_loadimm8
                push    #zk_setry
                jmp     #\zk_readcode

zk_ex_af        '' EX AF,AF'
                xor     zk_accu,zk_altaccu
                xor     zk_altaccu,zk_accu
                xor     zk_accu,zk_altaccu
                xor     zk_flags,zk_altflags
                xor     zk_altflags,zk_flags
        _ret_   xor     zk_flags,zk_altflags

zk_halt
                or      zk_irqenable,#(1<<ZK_HALT_BIT)
        _ret_   decmod  zk_pc,zk_ffffh

'
' MSX
'
msx_read8_0000
                testb   msx_ppi, #0     wc
                testb   msx_ppi, #1     wz
                jmp     #msx_read8
msx_read8_4000
                testb   msx_ppi, #2     wc
                testb   msx_ppi, #3     wz
                jmp     #msx_read8
msx_read8_8000
                testb   msx_ppi, #4     wc
                testb   msx_ppi, #5     wz
                jmp     #msx_read8
msx_read8_C000
                testb   msx_ppi, #6     wc
                testb   msx_ppi, #7     wz
msx_read8
                getword pa, zk_ea, #0
        if_00   jmp     #\msx_slot0_read    ' 0 = 32K ROM
        if_01   jmp     #\msx_slot1_read    ' 1 = empty
        if_10   ret     wcz                 ' 2 = empty
        if_11   jmp     #\msx_slot3_read    ' 3 = 64K RAM
                ret     wcz

msx_write8_0000
                testb   msx_ppi, #0     wc
                testb   msx_ppi, #1     wz
                jmp     #msx_write8
msx_write8_4000
                testb   msx_ppi, #2     wc
                testb   msx_ppi, #3     wz
                jmp     #msx_write8
msx_write8_8000
                testb   msx_ppi, #4     wc
                testb   msx_ppi, #5     wz
                jmp     #msx_write8
msx_write8_C000
                testb   msx_ppi, #6     wc
                testb   msx_ppi, #7     wz
msx_write8
                getword pa, zk_ea, #0
        if_00   ret     wcz                 ' 0 = 32K ROM
        if_01   ret     wcz                 ' 1 = empty / ROM
        if_10   ret     wcz                 ' 2 = empty
        if_11   jmp     #\msx_slot3_write   ' 3 = 64K RAM

msx_slot0_read
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_10   ret     wcz                 ' 8000-BFFF empty
        if_11   ret     wcz                 ' C000-FFFF empty
                add     pa, ##@msx_slot0
                rdbyte  zk_tmp8, pa
                'debug(zstr("slot0r"), uhex_word(zk_ea), uhex_byte(zk_tmp8), uhex_long(pa), dly(#500))
                ret     wcz

msx_slot1_read
                mov     zk_tmp0, ##msx_slot1_end
                sub     zk_tmp0, ##msx_slot1+1
                and     pa, zk_tmp0
                add     pa, ##@msx_slot1
                rdbyte  zk_tmp8, pa
                ret     wcz

msx_slot3_read
                add     pa, ##@msx_slot3
                rdbyte  zk_tmp8, pa
                ret     wcz

msx_slot3_write
                add     pa, ##@msx_slot3
                wrbyte  zk_tmp8, pa
                ret     wcz

                fit     $400

DAT             ' ZiKore Z80 opcode table
                orgh

zk_optable      '' Opcode table
                long    zk_nextop                                           ' $00: NOP
                long    zk_loadimm16 + (%0000_1_111_0<<10)                  ' $01: LD BC,imm16
                long    zk_a_and_ptr + (%001110<<10)                        ' $02: LD (BC),A
                long    zk_incdec16+(%0000_1_1111_10_1_11100<<10)           ' $03: INC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $04: INC B
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $05: DEC B
                long    zk_loadimm8                                         ' $06: LD B,imm8
                long    zk_rolla+(%0_010_110_01_11110_00<<10)               ' $07: RLCA
                long    zk_ex_af                                            ' $08: EX AF,AF'
                long    zk_math16+(%0010_111_00_1100_00_1110_1_0<<10)       ' $09: ADD HL,BC
                long    zk_a_and_ptr + (%000010<<10)                        ' $0A: LD A,(BC)
                long    zk_incdec16+(%0000_1_1111_01_1_11100<<10)           ' $0B: DEC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $0C: INC C
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $0D: DEC C
                long    zk_loadimm8                                         ' $0E: LD C,imm8
                long    zk_rolla+(%0_010_001_01_11011_00<<10)               ' $0F: RRCA
                long    zk_jr + (%01_11_0000_0<<10)                         ' $10: DJNZ
                long    zk_loadimm16 + (%0001_1_111_0<<10)                  ' $11: LD DE,imm16
                long    zk_a_and_ptr + (%00110 <<10)+1                      ' $12: LD (DE),A
                long    zk_incdec16+(%0001_1_1111_10_1_11010<<10)           ' $13: INC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $14: INC D
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $15: DEC D
                long    zk_loadimm8                                         ' $16: LD D,imm8
                long    zk_rolla+(%0_010_110_00_11110_00<<10)               ' $17: RLA
                long    zk_jr + (%11_11_1111_0<<10)                         ' $18: JR
                long    zk_math16+(%0010_111_00_1100_00_1101_1_0<<10)       ' $19: ADD HL,DE
                long    zk_a_and_ptr + (%00000 <<10)+1                      ' $1A: LD A,(DE)
                long    zk_incdec16+(%0001_1_1111_01_1_11010<<10)           ' $1B: DEC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $1C: INC E
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $1D: DEC E
                long    zk_loadimm8                                         ' $1E: LD E,imm8
                long    zk_rolla+(%0_010_001_00_11011_00<<10)               ' $1F: RRA
                long    zk_jr + (%01_10_1111_0<<10)                         ' $20: JR NZ
                long    zk_loadimm16 + (%0011_1_111_0<<10)                  ' $21: LD HL,imm16
                long    zk_ld_abs16 + (%01011_00<<10)                       ' $22: LD (imm16),HL
                long    zk_incdec16+(%0011_1_1111_10_1_10110<<10)           ' $23: INC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $24: INC H
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $25: DEC H
                long    zk_loadimm8                                         ' $26: LD H,imm8
                long    zk_daa                                              ' $27: DAA
                long    zk_jr + (%00_10_1111_0<<10)                         ' $28: JR Z
                long    zk_math16+(%0010_111_00_1100_00_1011_1_0<<10)       ' $29: ADD HL,HL
                long    zk_ld_abs16 + (%00110_11111_00<<10)                 ' $2A: LD HL,(imm16)
                long    zk_incdec16+(%0011_1_1111_01_1_10110<<10)           ' $2B: DEC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $2C: INC L
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $2D: DEC L
                long    zk_loadimm8                                         ' $2E: LD L,imm8
                long    zk_cpl                                              ' $2F: CPL
                long    zk_jr + (%01_01_1111_0<<10)                         ' $30: JR NC
                long    zk_loadimm16 + (%0111_1_111_0<<10)                              ' $31: LD SP,imm16
                long    zk_ld_abs + (%001111_00<<10)                                    ' $32: LD (imm16),A
                long    zk_incdec16+(%0111_1_1111_10_1_01110<<10)                       ' $33: INC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP       ' $34: INC (HL)
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP       ' $35: DEC (HL)
                long    zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
                long    zk_scf + (%10 << 10)                 ' $37: SCF
                long    zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
                long    zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
                long    zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
                long    zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
                long    zk_loadimm8                          ' $3E: LD A,imm8
                long    zk_ccf                               ' $3F: CCF
                long    zk_nextop                            ' $40: LD B,B (NOP)
                long    zk_regmove                           ' $41: LD B,C
                long    zk_regmove                           ' $42: LD B,D
                long    zk_regmove                           ' $43: LD B,E
                long    zk_regmove                           ' $44: LD B,H
                long    zk_regmove                           ' $45: LD B,L
                long    zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
                long    zk_regmove                           ' $47: LD B,A
                long    zk_regmove                           ' $48: LD C,B
                long    zk_nextop                            ' $49: LD C,C (NOP)
                long    zk_regmove                           ' $4A: LD C,D
                long    zk_regmove                           ' $4B: LD C,E
                long    zk_regmove                           ' $4C: LD C,H
                long    zk_regmove                           ' $4D: LD C,L
                long    zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
                long    zk_regmove                           ' $4F: LD C,A
                long    zk_regmove                           ' $50: LD D,B
                long    zk_regmove                           ' $51: LD D,C
                long    zk_nextop                            ' $52: LD D,D (NOP)
                long    zk_regmove                           ' $53: LD D,E
                long    zk_regmove                           ' $54: LD D,H
                long    zk_regmove                           ' $55: LD D,L
                long    zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
                long    zk_regmove                           ' $57: LD D,A
                long    zk_regmove                           ' $58: LD E,B
                long    zk_regmove                           ' $59: LD E,C
                long    zk_regmove                           ' $5A: LD E,D
                long    zk_nextop                            ' $5B: LD E,E (NOP)
                long    zk_regmove                           ' $5C: LD E,H
                long    zk_regmove                           ' $5D: LD E,L
                long    zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
                long    zk_regmove                           ' $5F: LD E,A
                long    zk_regmove                           ' $60: LD H,B
                long    zk_regmove                           ' $61: LD H,C
                long    zk_regmove                           ' $62: LD H,D
                long    zk_regmove                           ' $63: LD H,E
                long    zk_nextop                            ' $64: LD H,H (NOP)
                long    zk_regmove                           ' $65: LD H,L
                long    zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
                long    zk_regmove                           ' $67: LD H,A
                long    zk_regmove                           ' $68: LD L,B
                long    zk_regmove                           ' $69: LD L,C
                long    zk_regmove                           ' $6A: LD L,D
                long    zk_regmove                           ' $6B: LD L,E
                long    zk_regmove                           ' $6C: LD L,H
                long    zk_nextop                            ' $6D: LD L,L (NOP)
                long    zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
                long    zk_regmove                           ' $6F: LD L,A
                long    zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
                long    zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
                long    zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
                long    zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
                long    zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
                long    zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
                long    zk_halt                              ' $76: HALT
                long    zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
                long    zk_regmove                           ' $78: LD A,B
                long    zk_regmove                           ' $79: LD A,C
                long    zk_regmove                           ' $7A: LD A,D
                long    zk_regmove                           ' $7B: LD A,E
                long    zk_regmove                           ' $7C: LD A,H
                long    zk_regmove                           ' $7D: LD A,L
                long    zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
                long    zk_nextop                            ' $7F: LD A,A (NOP)
                long   (zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
                long   (zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
                long   (zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
                long   (zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
                long   (zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
                long    zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
                long    zk_logic + (%000000_110_0<<10)       ' $A7: AND A
                long   (zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
                long    zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
                long    zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
                long   (zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
                long    zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
                long    zk_logic + (%001000_101_0<<10)       ' $B7: OR A
                long   (zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
                long    zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
                long    zk_poppair+(%0_0<<10)                  ' $C1: POP BC
                long    zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
                long    zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
                long    zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
                long    zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
                long    zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
                long    zk_rst                               ' $C7: RST 00h
                long    zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
                long    zk_ret + (%0101_11_00<<10)           ' $C9: RET
                long    zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
                long    zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
                long    zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
                long    zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
                long    zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
                long    zk_rst                               ' $CF: RST 08h
                long    zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
                long    zk_poppair+(%01_0<<10)                 ' $D1: POP DE
                long    zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
                long    zk_immio + (%00_000<<10)               ' $D3: OUT (imm8),A
                long    zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
                long    zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
                long    zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
                long    zk_rst                               ' $D7: RST 10h
                long    zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
                long    zk_exx                               ' $D9: EXX
                long    zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
                long    zk_immio + (%00_11_000<<10)            ' $DB: IN A,(imm8)
                long    zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
                long    zk_ixprefix                          ' $DD: IX prefix
                long    zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
                long    zk_rst                               ' $DF: RST 18h
                long    zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
                long    zk_poppair+(%0011_0<<10)               ' $E1: POP HL
                long    zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
                long    zk_ex_hlstk                          ' $E3: EX (SP),HL
                long    zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
                long    zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
                long    zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
                long    zk_rst                               ' $E7: RST 20h
                long    zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
                long    zk_jump_indir                          ' $E9: JP (HL)
                long    zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
                long    zk_ex_dehl                           ' $EB: EX DE,HL
                long    zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
                long    zk_extprefix + ZK_HLOP               ' $ED: extension prefix
                long    zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
                long    zk_rst                               ' $EF: RST 28h
                long    zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
                long    zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
                long    zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
                long    zk_irqoff                              ' $F3: DI
                long    zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
                long    zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
                long    zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
                long    zk_rst                               ' $F7: RST 30h
                long    zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
                long    zk_hl_to_sp                            ' $F9: LD SP,(HL)
                long    zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
                long    zk_irqon                               ' $FB: EI
                long    zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
                long    zk_iyprefix + (%10<<10)              ' $FD: IY prefix
                long    zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
                long    zk_rst                               ' $FF: RST 38h


CON ' ZiKore Z80 constants

    ZK_CLOCK      = 3_576_000
    ZK_HLOP       = 1 << 10

    ZK_CARRY_BIT  = 0
    ZK_NMODE_BIT  = 1
    ZK_OVER_BIT   = 2 ' also parity
    ZK_HALF_BIT   = 4
    ZK_ZERO_BIT   = 6
    ZK_SIGN_BIT   = 7

    ZK_XYMASK     = %0010_1000
    ZK_SIGNXYMASK = %1010_1000

    ZK_IFF1_BIT   = 0
    ZK_IFF2_BIT   = 1
    ZK_HALT_BIT   = 2
    ZK_IM2_BIT    = 3

DAT             ' TMS9918
                org     $000

tms_driver
                add     ptrb, ##@tms_palette - @tms_driver
                setq2   #511                    ' load video drivers into lut
                rdlong  0, ptrb

                call    #\(VIDEO == VGA ? vga_init : cvbs_init) ' start video driver

                mov     scol, #0
                xcont   #10,#0                  ' do streamer instruction to start interrupt sequence
'
'
' Main program
'
loop
                cmp     _cl, scnt           wcz
    if_z        jmp     #loop

                mov     scol, scol+1
                mov     scnt, _cl

                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192      wz
    if_ne       jmp     #.skip

                locktry #0              wc
    if_nc       jmp     #$-1
                rdlong  a, #@tms_status         ' update status byte
                or      a, #TMSVSYNC            ' vsync flag
                test    regs+1, #TMSINTEN   wz  ' interrupt enable
                bitnz   a, #8                   ' NMI
                wrlong  a, #@tms_status
                lockrel #0

.skip           setq    #1                      ' read registers into temp buffer
                rdlong  sbuf, #@tms_regs        ' |

                getnib  scol+1, sbuf+1, #6      ' border color for next line
                movbyts scol+1, #0

                getbyte regs+0, sbuf, #0
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
                getbyte regs+1, sbuf, #1
                getbyte regs+2, sbuf, #2
                shl     regs+2, #10             ' name table base address * $400
                add     regs+2, _tms_vram
                getbyte regs+3, sbuf, #3
                shl     regs+3, #6              ' color table base address * $40
    if_nz       andn    regs+3, vdp_8k_mask     ' limit color table to 8k boundaries
                add     regs+3, _tms_vram
                getbyte regs+4, sbuf+1, #0
                shl     regs+4, #11             ' pattern generator base address * $800
    if_nz       andn    regs+4, vdp_8k_mask     ' limit pattern table to 8k boundaries
                add     regs+4, _tms_vram
                getbyte regs+5, sbuf+1, #1
                shl     regs+5, #7              ' sprite attribute table base address * $80
                add     regs+5, _tms_vram
                getbyte regs+6, sbuf+1, #2
                shl     regs+6, #11             ' sprite pattern generator base address * $800
                add     regs+6, _tms_vram
                getbyte regs+7, sbuf+1, #3

                cmp     _cl, #(VIDEO == PAL ? 48 : 24)  wcz ' check if first visible line
    if_c        jmp     #loop
                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192    wc  ' check if last visible line
    if_nc       jmp     #loop

    if_z        mov     loff, #0                ' if first line reset counters...
    if_z        mov     lcnt, #0
    if_z        mov     ptrv, _tms_bitmap       ' ...and pointers

                setq    #32-1                   ' read all sprite attribute table
                rdlong  sbuf, regs+5

scanline
                mov     ptra, ptrv

                test    regs+1, #TMSBLANK   wz  ' blank
    if_z        jmp     #blank_line

                test    regs+1, #TMSMODE1   wz  ' text mode
                mov     a, lcnt
                andn    a, #$07                 ' divide and multiply by 8
                mov     b, a
                shl     a, #2                   ' multiply by 32
    if_nz       add     a, b                    ' multiply by 40
                add     regs+2, a
    if_nz       jmp     #text_mode

                test    regs+1, #TMSMODE2   wz  ' multicolor mode
    if_nz       jmp     #multicolor_mode

                jmp     #graphics_mode

text_mode
                getnib  ctmp, regs+7, #1        ' foreground color
                shl     ctmp, #8
                setnib  ctmp, regs+7, #0        ' background color

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                mov     ptrb, regs+2

                mov     ecnt, #40
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, loff
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                shr     a, #8
                mov     cbuf+1, ctmp
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++
                sub     ptra, #2

                djnz    ecnt, #.loop

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                jmp     #end_scanline

blank_line
                getnib  ctmp, regs+7, #0        ' background color
                movbyts ctmp, #0

                mov     ecnt, #256/4            ' fill line with background
.l1             wrlong  ctmp, ptra++
                djnz    ecnt, #.l1

                jmp     #end_scanline

multicolor_mode
                mov     a, lcnt
                shr     a, #2
                and     a, #$07

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3
                add     ptrc, regs+4            ' points to color table
                add     ptrc, a

                rdbyte  cbuf+0, ptrc            ' colors

                mov     cbuf+1, cbuf+0
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0
                shr     cbuf+0, #4          wz
    if_z        setnib  cbuf+0, regs+7, #0

                movbyts cbuf+0, #%%0000
                movbyts cbuf+1, #%%0000

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                jmp     #sprites

graphics_mode
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       mov     a, lcnt
    if_nz       shr     a, #6                   ' divide by 64 (8 rows by 8 pixels)
    if_nz       shl     a, #11                  ' multiply by 2048
                mov     b, loff                 ' offset into pattern table
    if_nz       add     b, a                    ' add mode II pattern table offset

                bitnz   .shlr, #21              ' patch shl(0)/shr(1)

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display

                mov     ptrd, ptrc
.shlr           shl     ptrd, #3
                add     ptrd, regs+3            ' points to color table
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       add     ptrd, b
                rdbyte  a, ptrd                 ' colors

                getnib  cbuf+0, a, #0
                and     cbuf+0, #$0F        wz
    if_z        setnib  cbuf+0, regs+7, #0
                getnib  cbuf+1, a, #1
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0

                setbyte cbuf+0, cbuf+1, #1
                mov     cbuf+1, cbuf+0

                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, b
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                movbyts cbuf+0, a
                shr     a, #8
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                ' fall through

sprites
                mov     ecnt, #9                ' clear collision buffer
.l1             altd    ecnt, #line-1           ' |
                mov     0-0, #0                 ' |
                djnz    ecnt, #.l1              ' |

                mov     b, #8                   ' calculate sprite size
                test    regs+1, #TMSSPRSIZE wz  ' |
    if_nz       shl     b, #1                   ' |
                test    regs+1, #TMSSPRMAG  wz  ' |
    if_nz       shl     b, #1                   ' b = 8/16/32

                mov     stat, #0
                mov     vcnt, #0
                mov     ccnt, #0

                mov     ecnt, #TMSSPRITES
.l2             alts    ccnt, #sbuf             ' find last sprite
                getbyte y, 0-0, #0              ' |
                cmp     y, #$D0             wz  ' |
    if_e        jmp     #.loop                  ' |
                add     y, #1                   ' |
                cmp     y, #$D0             wcz ' |
    if_a        sub     y, #$100                ' |
                                                ' |
                mov     a, lcnt                 ' | check sprite scanline visibility
                subs    a, y                wc  ' | |
    if_b        jmp     #.l3                    ' | |
                cmp     a, b                wc  ' | |
    if_ae       jmp     #.l3                    ' | |
                add     vcnt, #1                ' | vcnt = number of sprites on scanline
                                                ' |
.l3             add     ccnt, #1                ' |
                djnz    ecnt, #.l2              ' |

.loop           decmod  ccnt, #0            wc  ' loop backward to draw visible sprites
    if_c        jmp     #.end                   ' |

                alts    ccnt, #sbuf
                mov     sprt, 0-0

                getbyte y, sprt, #0
                add     y, #1
                cmp     y, #$D0             wcz
    if_a        sub     y, #$100

                mov     a, lcnt                 ' check sprite scanline visibility
                subs    a, y                wc
    if_b        jmp     #.loop
                cmp     a, b                wc
    if_ae       jmp     #.loop

                cmps    vcnt, #5            wcz
    if_e        mov     stat, ccnt              ' set 5th sprite
    if_e        or      stat, #TMS5SPRITE       ' |
                sub     vcnt, #1
'    if_ae       jmp     #.loop                  ' comment to remove sprite limit

                getbyte ptrc, sprt, #2
                test    regs+1, #TMSSPRSIZE wz
    if_nz       and     ptrc, #$FC
                shl     ptrc, #3
                add     ptrc, regs+6
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shr     a, #1
                add     ptrc, a

                getnib  ctmp, sprt, #6          'set sprite color
                shl     ctmp, #8

                getbyte x, sprt, #1
                testb   sprt, #31           wz  'TMSEARLYCLK
    if_x1       sub     x, #32
                mov     ptra, ptrv
                add     ptra, x

                test    regs+1, #TMSSPRSIZE wz
    if_z        mov     ecnt, #4
    if_nz       mov     ecnt, #8

                rdbyte  sprt, ptrc
                shl     sprt, #8
    if_nz       add     ptrc, #16
    if_nz       rdbyte  a, ptrc
    if_nz       or      sprt, a

                test    regs+1, #TMSSPRMAG  wz
    if_nz       setword sprt, sprt, #1
    if_nz       mergew  sprt
    if_z        shl     sprt, #16

                cmps    x, #0       wc          ' skip left offscreen pixels
    if_c        abs     x                       ' |
    if_c        add     ptra, x                 ' |
    if_c        sub     ecnt, x                 ' |
    if_c        cmps    x, #32      wz          ' |
    if_c_and_z  mov     sprt, #0                ' |
    if_c_and_nz shl     sprt, x                 ' |
    if_c        mov     x, #0                   ' |

                mov     cbuf, sprt
                mov     cbuf+1, cbuf

                mov     y, x                    ' check sprite collision
                sar     y, #5                   ' |
                add     y, #line                ' |
                setd    .c0, y                  ' |
                setd    .c0+1, y                ' |
                add     y, #1                   ' |
                setd    .c1, y                  ' |
                setd    .c1+1, y                ' |
                mov     a, x                    ' |
                and     a, #$1F     wz          ' |
    if_z        mov     cbuf+1, #0              ' |
                shr     cbuf, a                 ' |
.c0             test    0-0, cbuf   wz          ' |
                or      0-0, cbuf               ' |
                mov     y, #32                  ' |
                sub     y, a                    ' |
                shl     cbuf+1,y                ' |
.c1 if_z        test    0-0, cbuf+1 wz          ' |
                or      0-0, cbuf+1             ' |
    if_nz       or      stat, #%0010_0000       ' update collision flag
                mov     line+8, #0              ' clear right offscreen pixels

                rev     sprt

.draw           getnib  a, sprt, #0
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                wmlong  cbuf+0, ptra++
                add     x, #4
                cmp     x, #256     wc
                shr     sprt, #4    wz
    if_c_and_nz djnz    ecnt, #.draw

                jmp     #.loop
.end

                locktry #0              wc
    if_nc       jmp     #$-1
                rdbyte  a, #@tms_status         ' update status byte
                test    stat, #TMSCOLL      wz
    if_nz       or      a, #TMSCOLL
                test    a, #TMS5SPRITE      wz
    if_z        or      a, stat
                wrbyte  a, #@tms_status
                lockrel #0

end_scanline
                add     ptrv, #256
                incmod  loff, #7
                incmod  lcnt, #192-1

                jmp     #loop
'
'
' Data
'
dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

cx              long    0
cy              long    0

vga_xf          long   (VGA_FPIX frac _CLKFREQ) >> 1             ' streamer frequency setting
vga_bs          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +   8    ' streamer command: before-sync
vga_ds          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  48    ' streamer command: during-sync
vga_as          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  24    ' streamer command: after sync
vga_vi          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + 320    ' streamer command: visible
vga_bv          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: before visible
vga_dv          long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 + 256    ' streamer command: during visible
vga_av          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: after visible
vga_pn          long    VGA_PIN & $38       ' base pin

cvbs_cb         long    VIDEO == PAL ? PAL_CB : NTSC_CB             ' colorburst reference color
cvbs_cy         long    VIDEO == PAL ? PAL_CY : NTSC_CY             ' colorspace y coefficients
cvbs_ci         long    VIDEO == PAL ? PAL_CI : NTSC_CI             ' colorspace i coefficients
cvbs_cq         long    VIDEO == PAL ? PAL_CQ : NTSC_CQ             ' colorspace q coefficients
cvbs_ca         long    VIDEO == PAL ? PAL_CA : NTSC_CQ             ' colorspace q coefficients, alt for pal
cvbs_cf         long   (VIDEO == PAL ? PAL_CF : NTSC_CF) frac _CLKFREQ ' colorspace frequency setting
cvbs_xf         long    VIDEO == PAL ? PAL_XF : NTSC_XF             ' streamer frequency setting

cvbs_bs         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  10 :  10)    ' streamer command: before-sync
cvbs_ds         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  30 :  27)    ' streamer command: during-sync
cvbs_bc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?   6 :   4)    ' streamer command: before-colorburst
cvbs_dc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  15)    ' streamer command: during-colorburst
cvbs_ac         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  17 :   9)    ' streamer command: after-colorburst
cvbs_db         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_bv         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  28)    ' streamer command: before-visible
cvbs_dv         long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 +                    256        ' streamer command: during-visible
cvbs_av         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  29)    ' streamer command: after-visible
cvbs_vi         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_hl         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  14)    ' streamer command: high-vsync-low
cvbs_hh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 183 : 165)    ' streamer command: high-vsync-high

cvbs_ll         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 177 : 161)    ' streamer command: low-vsync-low
cvbs_lh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  21 :  18)    ' streamer command: low-vsync-high

cvbs_pn         long    CVBS_PIN            ' pin(s)

_md             long    0
_lb             long    0                   ' line buffer pointer
_cl             long    0                   ' current line
_tms_vram       long    @tms_vram
_tms_bitmap     long    @tms_bitmap

vdp_8k_mask     long    $1FFF

a               res     1
b               res     1
x               res     1
y               res     1

scnt            res     1
scol            res     2                       'backdrop/border color

lcnt            res     1
loff            res     1
ccnt            res     1
vcnt            res     1
ecnt            res     1

ctmp            res     1
cbuf            res     2
sprt            res     1

ptrc            res     1
ptrd            res     1
ptrv            res     1

stat            res     1
regs            res     8
sbuf            res     32

line            res     8+1

DAT             ' VGA / CVBS drivers
                org     $200

tms_palette
                long    $00_00_00_00
                long    $00_00_00_00
                long    $66_CC_66_00
                long    $88_EE_88_00
                long    $44_44_DD_00
                long    $77_77_FF_00
                long    $BB_55_55_00
                long    $77_DD_DD_00
                long    $DD_66_66_00
                long    $FF_77_77_00
                long    $CC_CC_55_00
                long    $EE_EE_88_00
                long    $55_AA_55_00
                long    $BB_55_BB_00
                long    $CC_CC_CC_00
                long    $EE_EE_EE_00
'
'
' VGA Driver
'
vga_init
                setcmod #%01_0_000_1            ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16   ' g
                setcq   ##VGA_INTENSITY << 08   ' b
                setxfrq vga_xf                  ' set transfer frequency

                cogid   cx                      ' insert cogid into dac modes
                setnib  dacmode_s,cx,#2
                setnib  dacmode_c,cx,#2

                wrpin   dacmode_s,vga_pn        ' enable 123-ohm 3.3V dac mode in pin +0

                xor     vga_pn,#2<<6|1          ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c,vga_pn

                xor     vga_pn,#3<<6 ^(2<<6|1)  ' make pins +0..3 outputs
                drvl    vga_pn

                xor     vga_pn,#4|(3<<6)        ' leave av_base pointing to pin +4 (vertical sync)
                drvh    vga_pn

                mov     ijmp1,##vga_field       ' set up streamer-empty interrupt
        _ret_   setint1 #10
'
'
' Field loop
'
vga_field
                mov     cy,#24                  ' before-visible blank lines
                calld   pa, #.border

                mov     _lb, _tms_bitmap

                mov     cy,#192                 ' visible lines
.line           xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1

                rdfast  #4, _lb                 ' start reading pixels into fifo
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                ' duplicate line
                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line

                add     _lb, #256
                resi1
                djnz    cy,#.line

                mov     cy,#24                  ' after-visible blank lines
                calld   pa, #.border

                mov     cy, #10
                calld   pa, #.blank

                drvnot  vga_pn                  ' vertical sync on
                mov     cy, #2
                calld   pa, #.blank
                drvnot  vga_pn                  ' vertical sync off

                mov     _cl, #0

                mov     cy, #33
                calld   pa, #.blank

                jmp     #vga_field              ' loop
'
'
' Subroutines
'
.border         xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.border
                jmp     pa

.blank          xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,#0               ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.blank              ' loop if more blanks needed
                jmp     pa
'
'
' CVBS Driver
'
cvbs_init
                setcmod #%11_1_0000             ' set colorspace converter to YIQ mode (composite)
                setcy   cvbs_cy                 ' set colorspace converter y coefficients
                setci   cvbs_ci                 ' set colorspace converter i coefficients
                setcq   cvbs_cq                 ' set colorspace converter q coefficients
                setcfrq cvbs_cf                 ' set colorspace converter frequency
                setxfrq cvbs_xf                 ' set transfer frequency

                cogid   cx                      ' install cogid into dacmode
                setnib  dacmode_c,cx,#2
                wrpin   dacmode_c,cvbs_pn       ' enable dac mode in pin(s)
                drvl    cvbs_pn                 ' enable dac output(s)

                mov     ijmp1,##cvbs_field      ' set up streamer-empty interrupt
        _ret_   setint1 #10

cvbs_field
                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' before-visible blank lines
                calld   pa, #.border            ' |

                rdfast  #0, _tms_bitmap         ' start reading pixels into fifo
                mov     cy, #192                ' visible lines

.line           xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |

                xcont   cvbs_bv, scol           ' left border
                resi1
                xcont   cvbs_dv, #0             ' visible part (from streamer)
                resi1
                xcont   cvbs_av, scol           ' right border
                resi1

                djnz    cy, #.line

                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' after-visible blank lines
                calld   pa, #.border            ' |

                mov     cy, #(VIDEO == PAL ? 8 : 2)                  ' before-visible blank lines
                calld   pa, #.blank             ' |

                mov     _cl, #0

                mov     cy, #6
                calld   pa, #.vhigh             ' initial high vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vlow              ' low vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vhigh             ' final high vertical syncs

                mov     cy, #(VIDEO == PAL ? 8 : 10)                 ' before-visible blank lines
                calld   pa, #.blank             ' |

                jmp     #cvbs_field             ' loop

.border         xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_vi, scol           ' blank line
                resi1                           ' |
                djnz    cy, #.border
                jmp     pa

.blank          xcont   cvbs_bs, #1             ' horizontal sync
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_db, #1             ' blank line
                resi1                           ' |
                djnz    cy, #.blank
                jmp     pa

.vhigh          xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_hl, #2             ' |
                resi1                           ' |
                xcont   cvbs_hh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vhigh
                jmp     pa

.vlow           xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_ll, #2             ' |
                resi1                           ' |
                xcont   cvbs_lh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vlow
                jmp     pa

                fit     $3F0

CON ' TMS9918 constants

    TMSMODE3   = %00000010      ' mode bit 3
    TMSEXTVID  = %00000001      ' external video

    ' register 1 control bits
    TMS4K16K   = %10000000      ' 4/16K RAM
    TMSBLANK   = %01000000      ' screen blank
    TMSINTEN   = %00100000      ' interrupt enable
    TMSMODE1   = %00010000      ' mode bit 1
    TMSMODE2   = %00001000      ' mode bit 2
    TMSSPRSIZE = %00000010      ' sprite size
    TMSSPRMAG  = %00000001      ' sprite magnification

    TMSVSYNC   = %10000000      ' frame sync
    TMS5SPRITE = %01000000      ' 5th sprite
    TMSCOLL    = %00100000      ' coincidence flag

    TMSSPRITES = 32

CON ' VGA constants

    VGA           = 0
    VGA_FPIX      = 12_500_000
    VGA_INTENSITY = 80    '0..128

CON ' CVBS constants

    NTSC            = 1
    NTSC_BLANK_LEV  = 40.0                                  'levels
    NTSC_BLACK_LEV  = NTSC_BLANK_LEV + 7.5
    NTSC_PEAK_LEV   = NTSC_BLANK_LEV + 140.0
    NTSC_SCALE      = 127.0 / NTSC_PEAK_LEV * 128.0
    NTSC_SCALE_COR  = NTSC_SCALE / 1.646                    'CORDIC prescale for IQ modulator

    NTSC_BLANK      = round(NTSC_SCALE * 2.0 * NTSC_BLANK_LEV / NTSC_PEAK_LEV)
    NTSC_BLACK      = round(NTSC_SCALE * 2.0 * NTSC_BLACK_LEV / NTSC_PEAK_LEV)

    NTSC_YR         = round(NTSC_SCALE     *  0.299)        'Y sums to 1
    NTSC_YG         = round(NTSC_SCALE     *  0.587)
    NTSC_YB         = round(NTSC_SCALE     *  0.114)

    NTSC_IR         = round(NTSC_SCALE_COR *  0.596)        'I sums to 0
    NTSC_IG         = round(NTSC_SCALE_COR * -0.274)
    NTSC_IB         = round(NTSC_SCALE_COR * -0.322)

    NTSC_QR         = round(NTSC_SCALE_COR *  0.212)        'Q sums to 0
    NTSC_QG         = round(NTSC_SCALE_COR * -0.523)
    NTSC_QB         = round(NTSC_SCALE_COR *  0.311)

    NTSC_CY         = (NTSC_YR & $FF) << 24 + (NTSC_YG & $FF) << 16 + (NTSC_YB & $FF) << 8 + NTSC_BLACK
    NTSC_CI         = (NTSC_IR & $FF) << 24 + (NTSC_IG & $FF) << 16 + (NTSC_IB & $FF) << 8 + NTSC_BLANK
    NTSC_CQ         = (NTSC_QR & $FF) << 24 + (NTSC_QG & $FF) << 16 + (NTSC_QB & $FF) << 8 + 128

    NTSC_CB         = $809000_01                            'colorburst reference color
    NTSC_CF         = 3_579_545                             'colorburst frequency
    NTSC_CC         = round(227.5 * 4.0)                    'color cycles per line * 4 to preserve fraction
    NTSC_X_TOTAL    = 378

    'NTSC_DOTF       = (NTSC_X_TOTAL * (NTSC_CF * 4 * 128)) / NTSC_CC
    'NTSC_I          = 31 - encod _CLKFREQ
    NTSC_XF         = $030B8EB8 ' ((NTSC_DOTF >> (7 - NTSC_I)) frac (_CLKFREQ << NTSC_I) + 1) >> 1

    PAL             = 2
    PAL_BLANK_LEV   = 43.0                                  'levels
    PAL_BLACK_LEV   = PAL_BLANK_LEV + 0.0
    PAL_PEAK_LEV    = PAL_BLANK_LEV + 140.0
    PAL_SCALE       = 127.0 / PAL_PEAK_LEV * 128.0
    PAL_SCALE_COR   = PAL_SCALE / 1.646                     'CORDIC prescale for IQ modulator

    PAL_BLANK       = round(PAL_SCALE * 2.0 * PAL_BLANK_LEV / PAL_PEAK_LEV)
    PAL_BLACK       = round(PAL_SCALE * 2.0 * PAL_BLACK_LEV / PAL_PEAK_LEV)

    PAL_YR          = round(PAL_SCALE     *  0.299)         'Y sums to 1
    PAL_YG          = round(PAL_SCALE     *  0.587)
    PAL_YB          = round(PAL_SCALE     *  0.114)

    PAL_UR          = round(PAL_SCALE_COR * -0.147)         'I sums to 0
    PAL_UG          = round(PAL_SCALE_COR * -0.289)
    PAL_UB          = round(PAL_SCALE_COR *  0.436)

    PAL_VR          = round(PAL_SCALE_COR *  0.615)         'Q sums to 0
    PAL_VG          = round(PAL_SCALE_COR * -0.515)
    PAL_VB          = round(PAL_SCALE_COR * -0.100)

    PAL_CY          = ( PAL_YR & $FF) << 24 + ( PAL_YG & $FF) << 16 + ( PAL_YB & $FF) << 8 + PAL_BLACK
    PAL_CI          = ( PAL_UR & $FF) << 24 + ( PAL_UG & $FF) << 16 + ( PAL_UB & $FF) << 8 + PAL_BLANK
    PAL_CQ          = ( PAL_VR & $FF) << 24 + ( PAL_VG & $FF) << 16 + ( PAL_VB & $FF) << 8 + 128
    PAL_CA          = (-PAL_VR & $FF) << 24 + (-PAL_VG & $FF) << 16 + (-PAL_VB & $FF) << 8 + 128

    PAL_CB          = $FFC060_01                            'colorburst reference color
    PAL_CF          = 4_433_618                             'colorburst frequency
    PAL_CC          = round(283.75 * 4.0)                   'color cycles per line * 4 to preserve fraction
    PAL_X_TOTAL     = 416

    'PAL_DOTF        = (PAL_X_TOTAL * (PAL_CF * 4 * 128)) / PAL_CC
    'PAL_I           = 31 - encod _CLKFREQ
    PAL_XF          = $0353F900 ' ((PAL_DOTF >> (7 - PAL_I)) frac (_CLKFREQ << PAL_I) + 1) >> 1

DAT ' AY-3-8912 cog code
                org     $000

ay_emu
                fltl    leftp
                fltl    rightp
                wrpin   r1,leftp
                wrpin   r1,rightp
                wxpin   sampleRate,leftp
                wxpin   sampleRate,rightp
                wypin   dac_center,leftp
                wypin   dac_center,rightp
                drvh    leftp
                drvh    rightp

' Read all AY registers from hub memory and convert
' them to more convenient representations.
mainLoop
getRegisters
                setq    #4-1
                rdlong  temp1,ptra
                getword frequency1, temp1,#0                ' reg 0+1
                shl     frequency1, #20
                getword frequency2, temp1,#1                ' reg 2+3
                shl     frequency2, #20
                getword frequency3, temp2,#0                ' reg 4+5
                shl     frequency3, #20
                getbyte noisePeriod, temp2,#2               ' reg 6
                and     noisePeriod, #$1f
                fge     noisePeriod, #2
                shl     noisePeriod, #20
                getbyte enableRegister, temp2,#3            ' reg 7
                setd    oscValues, enableRegister
                getbyte amplitude1, temp3,#0                ' reg 8
                getbyte amplitude2, temp3,#1                ' reg 9
                getbyte amplitude3, temp3,#2                ' reg 10
                getbyte envelopePeriod, temp4,#0            ' reg 12
                rolbyte envelopePeriod, temp3,#3            ' reg 11
                shl     envelopePeriod, #16             wz
        if_z    mov     envelopePeriod, half_period         ' 0 == half the period of 1
                getbyte envelopeShape, temp4,#1             ' reg 13

' Calculate AY samples channel 1-3 and store in out1-out3
                mov      mixOut, dac_center                  '  DC offset

'        Envelope shaping -> envelopeAmplitude
Envelope      sub      envCounter, envSubValue           wc ' Handle envelope incrementation
  if_c        add      envCounter, envelopePeriod
  if_c        add      envelopeValue, envelopeInc
              fle      envCounter, envelopePeriod

              test     envelopeShape, #16                wz ' Handle envelope "reset bit" ( Extra bit added by Ahle2 )
  if_z        neg      envelopeValue, #0
  if_z        mov      envelopeInc, #1
  if_z        mov      envCounter, envelopePeriod
  if_z        or       envelopeShape, #16
  if_z        wrbyte   envelopeShape, ptra[13/1]            '<-IMPORTANT, sets bit 5 ("reset bit") of envelope shape register in hub ram

              test     envelopeShape, #8                 wc ' Handle envelope continue = 0
              test     envelopeShape, #4                 wz
 if_nc_and_z  mov      envelopeShape, #9
 if_nc_and_nz mov      envelopeShape, #15

              test     envelopeShape, #2                 wz ' Sets the envelope hold level
              muxz     envHoldLevel, #15                    '

              test     envelopeValue, #16                wz ' Check if > 15
              test     envelopeShape, #1                 wc ' Check hold bit
  if_nz_and_c mov      envelopeInc, #0                      ' Hold envelope
  if_nz_and_c mov      envelopeValue, envHoldLevel          '

  if_nz       test     envelopeShape, #2                 wc ' Check and handle envelope alternation
  if_nz_and_c neg      envelopeInc, envelopeInc
  if_nz_and_c add      envelopeValue, envelopeInc

              mov      envelopeAmplitude, envelopeValue
              test     envelopeShape, #4                 wc ' Check and handle envelope invertion (attack)
  if_nc       xor      envelopeAmplitude, #15               '(Move Value or ~Value to envelopeAmplitude)


'     Waveform shaping noise -> bit 3 of oscValues
Noise1        sub      phaseAccumulatorN, noiseSubValue  wc ' Noise generator
  if_nc       jmp      #Env1
              add      phaseAccumulatorN, noisePeriod
              test     noiseValue, noiseTap              wc
              muxc     noiseValue, noiseMSB
              shr      noiseValue, #1                    wc
  if_c        xor      oscValues, #8


'            Waveform shaping channel 1 -> out1
Env1          test     amplitude1, #16                   wz ' Selects envelope or fixed amplitude
  if_nz       mov      amplitude1, envelopeAmplitude        ' depending on bit 5 of amplitude register 1

Square1       cmp      frequency1, freqRef               wc
  if_nc       sub      phaseAccumulator1, oscSubValue    wc ' Square wave generator
  if_c        add      phaseAccumulator1, frequency1        ' channel 1
  if_c        xor      oscValues, #1

              test     oscValues, mask513                wz ' Handles mixing of channel 1
  if_nz       test     oscValues, mask4104               wz
              getnib   arg1, amplitude1,#0
              alts     arg1,#amplitudeTable
              sumnz    mixOut, 0-0                          ' Tone on/off, Noise on/off
  'if_z       mov      out1, r1                             ' out1 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)

'            Waveform shaping channel 2 -> out2

Env2          test     amplitude2, #16                   wz ' Selects envelope or fixed amplitude
  if_nz       mov      amplitude2, envelopeAmplitude        ' depending on bit 5 of amplitude register 2

Square2       cmp      frequency2, freqRef               wc
  if_nc       sub      phaseAccumulator2, oscSubValue    wc ' Square wave generator
  if_c        add      phaseAccumulator2, frequency2        ' channel 2
  if_c        xor      oscValues, #2

              test     oscValues, mask1026               wz ' Handles mixing of channel 2
  if_nz       test     oscValues, mask8200               wz
              getnib   arg1, amplitude2,#0
              alts     arg1,#amplitudeTable
              sumnz    mixOut, 0-0                          ' Tone on/off, Noise on/off
  'if_z       mov      out2, r1                             ' out2 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)


'            Waveform shaping channel 3 -> out3
Env3          test     amplitude3, #16                   wz ' Selects envelope or fixed amplitude
  if_nz       mov      amplitude3, envelopeAmplitude        ' depending on bit 5 of amplitude register 3
              mov      arg1, amplitude3

Square3       cmp      frequency3, freqRef               wc
  if_nc       sub      phaseAccumulator3, oscSubValue    wc ' Square wave generator
  if_c        add      phaseAccumulator3, frequency3        ' channel 3
  if_c        xor      oscValues, #4

              test     oscValues, mask2052               wz ' Handles mixing of channel 3
  if_nz       test     oscValues, mask16392              wz
              getnib   arg1, amplitude3,#0
              alts     arg1,#amplitudeTable
              sumnz    mixOut, 0-0                          ' Tone on/off, Noise on/off
  'if_z       mov      out3, r1                             ' out3 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)

'      Mix channels and update FRQA/FRQB PWM-values
mixer
              'testp   rightp   wc
              'drvc #38 ' light LED if too slow
              testp    rightp   wc
  if_nc       jmp #$-1
              wypin    mixOut,leftp
              wypin    mixOut,rightp
              jmp      #mainLoop

'    Variables, tables, masks and reference values
amplitudeTable      long trunc(AMPLITUDE_LEVEL_0)
                    long trunc(AMPLITUDE_LEVEL_1)
                    long trunc(AMPLITUDE_LEVEL_2)
                    long trunc(AMPLITUDE_LEVEL_3)
                    long trunc(AMPLITUDE_LEVEL_4)
                    long trunc(AMPLITUDE_LEVEL_5)
                    long trunc(AMPLITUDE_LEVEL_6)
                    long trunc(AMPLITUDE_LEVEL_7)
                    long trunc(AMPLITUDE_LEVEL_8)
                    long trunc(AMPLITUDE_LEVEL_9)
                    long trunc(AMPLITUDE_LEVEL_A)
                    long trunc(AMPLITUDE_LEVEL_B)
                    long trunc(AMPLITUDE_LEVEL_C)
                    long trunc(AMPLITUDE_LEVEL_D)
                    long trunc(AMPLITUDE_LEVEL_E)
                    long trunc(AMPLITUDE_LEVEL_F)

'Masks and reference values
mask513             long 513
mask1026            long 1026
mask2052            long 2052
mask4104            long 4104
mask8200            long 8200
mask16392           long 16392
mask32bit           long $ffffffff
mask16bit           long $ffff
half_period         long $00008000
val31bit            long $80000000
noiseMSB            long 1 << NOISE_MSB
noiseTap            long NOISE_TAP
sampleRate          long _CLKFREQ / SAMPLE_RATE
freqRef             long 10<<20
dac_center          long $7F80
leftp               long AUDIO_LEFT_PIN
rightp              long AUDIO_RIGHT_PIN

'Setup and subroutine parameters
arg1                long 0
r1                  long P_DAC_75R_2V|P_OE|P_DAC_DITHER_PWM

'AY variables
noiseValue          long $ffff
envCounter          long 1
envSubValue         long ENV_CORR
oscSubValue         long OSC_CORR
noiseSubValue       long NOISE_CORR
envelopeValue       long 0
envelopeInc         long 1
envHoldLevel        res  1
oscValues           res  1
amplitude1          res  1
amplitude2          res  1
amplitude3          res  1
envelopeAmplitude   res  1
enableRegister      res  1
envelopeShape       res  1
frequency1          res  1
frequency2          res  1
frequency3          res  1
envelopePeriod      res  1
noisePeriod         res  1
phaseAccumulatorN   res  1
phaseAccumulator1   res  1
phaseAccumulator2   res  1
phaseAccumulator3   res  1
mixOut              res  1
temp1               res  1
temp2               res  1
temp3               res  1
temp4               res  1
                    fit 496

CON ' AY-3-8912 constants

    ' WARNING !!
    ' Don't alter the constants below unless you know what you are doing
    '-------------------------------------------------------------------
    PSG_FREQ    = 1_773_400.0              ' Clock frequency input on the emulated AY chip
    SAMPLE_RATE = round(PSG_FREQ/ 16.0)    ' Sample rate of AYcog (PSG_FREQ/ 16.0 is the HW-accurate value)

    OSC_CORR    = trunc(1.05 * PSG_FREQ * ((PSG_FREQ/ 16.0)/float(SAMPLE_RATE))) ' Relative oscillator frequency (Where does the 1.05 come from?)
    NOISE_CORR  = OSC_CORR>>1              ' Relative noise frequency
    ENV_CORR    = OSC_CORR>>5              ' Relative envelope timing

    NOISE_TAP = %1001                      ' LFSR noise constants
    NOISE_MSB = 17                         '

    VOLUME_CORRECTION = 0.7                ' Volume correction value
    MAX_AMPLITUDE       = float($7F7F / 4) ' maxDACvalue / numberOfChannels (this makes room for maximum "swing" on all channels)
    AMPLITUDE_DAMP_FACTOR = 0.75           ' The damp factor between each volume step

    AMPLITUDE_LEVEL_F = MAX_AMPLITUDE     * VOLUME_CORRECTION
    AMPLITUDE_LEVEL_E = AMPLITUDE_LEVEL_F * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_D = AMPLITUDE_LEVEL_E * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_C = AMPLITUDE_LEVEL_D * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_B = AMPLITUDE_LEVEL_C * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_A = AMPLITUDE_LEVEL_B * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_9 = AMPLITUDE_LEVEL_A * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_8 = AMPLITUDE_LEVEL_9 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_7 = AMPLITUDE_LEVEL_8 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_6 = AMPLITUDE_LEVEL_7 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_5 = AMPLITUDE_LEVEL_6 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_4 = AMPLITUDE_LEVEL_5 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_3 = AMPLITUDE_LEVEL_4 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_2 = AMPLITUDE_LEVEL_3 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_1 = AMPLITUDE_LEVEL_2 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_0 = 0.0

DAT             ' I/O Hub-exec code
                orgh

'
' MSX
'
msx_kb_read
                getbyte zk_tmp0, msx_ppi, #2
                and     zk_tmp0, #%00001111
                add     zk_tmp0, #@msx_keys
                rdbyte  zk_tmp8, zk_tmp0
                ret     wcz

'
' TMS9918
'
tms_ctl_wr
                testb   tms_flag, #0    wz
         if_x0  jmp     #\tms_data_wr
         if_x1  jmp     #\tms_reg_wr

tms_data_wr     bith    tms_flag, #0
                getbyte tms_tmp0, zk_tmp8, #0
                ret     wcz

tms_reg_wr      bitl    tms_flag, #0
                testb   zk_tmp8, #7     wz
        if_x0   jmp     #tms_addr_wr
                mov     tms_tmp1, zk_tmp8
                and     tms_tmp1, #$07
                cmp     tms_tmp1, #1    wz      ' Z = Reg1 (may be INT enable)
                add     tms_tmp1, #@tms_regs
                wrbyte  tms_tmp0, tms_tmp1
        if_nz   ret     wcz
                rdlong  tms_tmp1, #@tms_status
                testb   zk_tmp8, #5     wc      ' C = INT ENABLE
                testb   tms_tmp1, #5    andc    ' FSync
                bitc    tms_tmp1, #8            ' Generate NMI if INT enable and FSync
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

tms_addr_wr     mov     tms_ramptr, zk_tmp8
                and     tms_ramptr, #$3F
                shl     tms_ramptr, #8
                or      tms_ramptr, tms_tmp0
                ret     wcz

tms_rd
                testb   zk_ea, #0       wz
        if_x0   jmp     #\tms_ram_rd
        if_x1   jmp     #\tms_status_rd

tms_ram_wr      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                wrbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_ram_rd      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                rdbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_status_rd   rdlong  tms_tmp1, #@tms_status
                getbyte zk_tmp8, tms_tmp1, #0
                and     tms_tmp1, #%000_11111
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

'
' AY-3-8910
'
psg_reg_write
                getbyte msx_psg_latch, zk_tmp8, #0
                and     msx_psg_latch, #$0F
                ret     wcz

psg_write
                mov     zk_tmp0, #@psg_regs
                add     zk_tmp0, msx_psg_latch
                wrbyte  zk_tmp8, zk_tmp0
                ret     wcz

psg_read
                mov     zk_tmp0, #@psg_regs
                add     zk_tmp0, msx_psg_latch
                rdbyte  zk_tmp8, zk_tmp0
                ret     wcz

DAT             ' Z80 Memory Space
                orgh

msx_slot0       file    "cbios_main_msx1.rom"
                'file    "vg8020_basic-bios1.rom"

msx_slot1
                'file    "Galaga (1984)(Namcot).rom"
                'file    "Galaxian (1984)(Namcot).rom"
                'file    "Lode Runner (1984)(Sony).rom"
                'file    "Moon Patrol (1984)(Irem).rom"
                'file    "Mr. Do! (1984)(Nippon Columbia - Colpax - Universal).rom"
                'file    "Pac-Man (1984)(Namcot).rom"
                'file    "Pitfall (1984)(Pony Canyon).rom"
                'file    "Pitfall II - Lost Caverns (1985)(Pony Canyon).rom"
                'file    "Q-Bert (1986)(Konami)[RC-746].rom"
                'file    "River Raid (1984)(Pony Canyon).rom"
                'file    "Space Invaders (1985)(Taito).rom"
                'file    "Super Cobra (1983)(Konami)[RC-705].rom"
                'file    "Time Pilot (1983)(Konami)[RC-703].rom"
                'file    "Zanac (1986)(Pony Canyon).rom"
                'file    "Zaxxon (1985)(Pony Canyon).rom"

msx_slot1_end

msx_slot3       byte    0[65536]

tms_vram        byte    0[16384]                    ' TMS9918 video ram

tms_bitmap      ' Memory used as rendered bitmap
