{
    MSX Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Based on ZiKore Z80 Emulator by Ada Gottensträter
    with modifications by Marco Maccaferri

    TMS9918 Emulator by Marco Maccaferri
    AY-3-8912 Emulator by Johannes Ahlebrand, port to P2 by Ada Gottensträter
    PS/2 Keyboard driver by Marco Maccaferri
}
CON

    _CLKFREQ = 250_000_000

    VIDEO    = VGA ' video mode VGA, NTSC or PAL
    VGA_PIN  = 48
    CVBS_PIN = 32 addpins 1 ' 32=CVBS/Y, 33=C

    USB_BASE_PIN  = 40

    AUDIO_LEFT_PIN  = 38
    AUDIO_RIGHT_PIN = 39

    TAPE_MIC = 0   ' OUT
    TAPE_EAR = 1   ' IN
    TAPE_REM = 2   ' OUT (motor)

DAT             ' Startup
                org     $000

usb_host_start
                asmclk
                drvl    #56
                drvl    #57

                mov     hcog_base_addr, ptrb

                add     ptrb, ##@hlut_start - @usb_host_start
                setq2   #512-1
                rdlong  0, ptrb

                rep     @.lockmadness,#16   ' allocate all locks, to be safe...
                locknew pb
                nop
.lockmadness

sys_reset
                cogid   #3      wc          ' check if user reset
                cogstop #3

        if_nc   coginit #1, ##@tms_driver   ' start video on cog #1

                setq    #@psg_regs
                coginit #2, ##@ay_emu       ' start AY-3-8912 on cog #2

                coginit #3, ##@zk_cogbase   ' start Z80 on cog #3

                jmp     #\usb_host_init         'cog #0 (this) USB host

' Shared variables

zk_irq_mem      long    $0_FF               ' bit 8 = IRQ, 7..0 vector

msx_keys        byte    $FF[16]

' TMS9918 registers

tms_regs        byte    $00, $00, $00, $00, $00, $00, $00, $00
tms_status      long    $0_00   ' bit 8 = VDP_IRQ, 7..0 = VDP status

' AY-3-8910 registers

psg_regs        byte    $00[14]
                byte    $FF ' port A
                byte    $FF ' port B

' Keyboard Matrix
'
'            bit 7       bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0
'    row 0       7 &     6 ^     5 %     4 $     3 #     2 @     1 !     0 )
'    row 1       ; :     ] }     [ {     \ ¦     = +     - _     9 (     8 *
'    row 2       B       A       DEAD    / ?     . >     , <     ` ~     ' "
'    row 3       J       I       H       G       F       E       D       C
'    row 4       R       Q       P       O       N       M       L       K
'    row 5       Z       Y       X       W       V       U       T       S
'    row 6       F3      F2      F1      CODE    CAPS    GRAPH   CTRL    SHIFT
'    row 7       RET     SELECT  BS      STOP    TAB     ESC     F5      F4
'    row 8       →       ↓       ↑       ←       DEL     INS     HOME    SPACE
'    row 9       NUM4    NUM3    NUM2    NUM1    NUM0    NUM/    NUM+    NUM*
'    row 10      NUM.    NUM,    NUM-    NUM9    NUM8    NUM7    NUM6    NUM5
'
' PS/2 Keyboard
'
'  +-------+--------+--------+--------+--------+---------+--------+--------+
'  | ESC   |  F1-6  |  F2-7  |  F3-8  |  F4-9  |  F-5-10 | SELECT |  STOP  |
'  +-----+-+---+----++-----+-+---+----++-----+-+---+-----+-----+--+--+-----+-----+-----------+
'  | ` ~ | 1 ! | 2 @ | 3 # | 4 $ | 5 % | 6 ^ | 7 & | 8 * | 9 ( | 0 ) | - _ | = + |    BS     |
'  +-----+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
'  | TAB    |  Q  |  W  |  E  |  R  |  T  |  Y  |  U  |  I  |  O  |  P  | [ { | ] } |        |
'  +--------++----++----++----++----++----++----++----++----++----++----++----++----++       |
'            |  A  |  S  |  D  |  F  |  G  |  H  |  J  |  K  |  L  | ; : | ' " | \ ¦ | ENTER |
'  +-------+-++----++----++----++----++----++----++----++----++----++----++-------+--+-------+
'  | SHIFT |  |  Z  |  X  |  C  |  V  |  B  |  N  |  M  | , < | . > | / ? |      SHIFT       |
'  +-------+--+-+---+---+-+-----+-----+-----+-----+-----+-----+-+---+--+--+----+------+------+
'  | CTRL  |    | GRAPH |                 SPACE                 | CODE |       | DEAD | CTRL |
'  +-------+----+-------+---------------------------------------+------+-------+------+------+
'
'  Other mapped keys:
'
'    HOME/INS/DEL
'    UP/DOWN/LEFT/RIGHT Arrows
'    Numeric Keypad
'
'  WIN+WIN = RESET

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup
' */
' /* txn_in
'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                loc     pb, #@urx_buff - @usb_host_start
                add     pb, hcog_base_addr
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                and     frame, ##$7ff
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                wrbyte  retval, usb_err_code_p          ' Save the error code for the client interface
                wxpin   #USB_ERROR, usb_event_pin       ' Signal the client an error has occurred
                mov     hrep, #5
.spin
                rdlong  htmp, cmd_data_p
                cmp     htmp, #CMD_RESET        wz
        if_z    wrlong  #ERR_NONE, cmd_data_p           ' Acknowledge client reset cmd received
        if_z    flth    host_error_led
        if_z    jmp     #host_reset                     ' See if it works...
                drvnot  host_error_led
                mov     hctwait, _100ms_                ' Blink the error LED
                call    #poll_waitx
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #.spin
                djnz    hrep, #.spin
        if_c    flth    host_error_led                  ' Clear the error LED
        if_c    ret                             wc      ' Handle disconnect?
                mov     hrep, #5
                jmp     #.spin

'------------------------------------------------------------------------------
' Post interrupt IN transactions at configured intervals.
'------------------------------------------------------------------------------
poll_kbd
                getct   hct3
                addct3  hct3, _8ms_                     ' Set the timer for next poll interval
                call    #\hget_kbd_in_report
                jmp     #\msx_encode_key

' Pointers to this spin object's VAR block data (assigned at cog startup)
cmd_data_p      long    @usbCmdData
kb_intf_num_p   long    @kbIntfNum
kb_interval_p   long    @kbInterval
kb_in_max_pkt_p long    @kbInMaxPkt
kb_next_datax_p long    @kbNextDatax
kb_max_index_p  long    @kbMaxIndex
kb_led_states_p long    @kbLedStates
kb_report_p     long    @kbCurReport
usb_err_code_p  long    @usbErrCode ' Contains "Protocol error codes" constant enumeration value.


' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
dm              long    USB_BASE_PIN + 2 ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN ' Host event reporting uses a long repository smart pin
host_active_led long    USB_BASE_PIN ' Client defines the LED pin# for host bus activity
host_error_led  long    56        ' Client defines the LED pin# to light on error
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
poll_target     long    0         ' Address of a subroutine that polls an interrupt IN endpoint
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hhid_intf_idx   long    0         ' Used during verbose descriptor terminal output
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                loc     pb, #@dev_desc_buff - @usb_host_start ' Start address of DeviceDescriptor struct for IN data
                add     pb, hcog_base_addr
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                loc     pa, #@dev_desc_buff - @usb_host_start
                add     pa, hcog_base_addr              ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, #1 << 8            ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                loc     pb, #@dev_desc_buff - @usb_host_start ' Start address of DeviceDescriptor struct has exact descriptor length
                add     pb, hcog_base_addr
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                loc     ptra, #@dev_desc_buff - @usb_host_start ' Do the same with the control max packet size
                add     ptra, hcog_base_addr
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                loc     pb, #@con_desc_buff - @usb_host_start ' Hub start address of ConfigurationDescriptor structure
                add     pb, hcog_base_addr
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                loc     ptra, #@con_desc_buff - @usb_host_start ' Check the config descriptor struct for expected data
                add     ptra, hcog_base_addr
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                loc     ptra, #@urx_buff - @usb_host_start ' Copy DATAx in rx buffer to dest struct
                add     ptra, hcog_base_addr
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    ret
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                loc     ptra, #@urx_buff - @usb_host_start ' Copy the rx buffer
                add     ptra, hcog_base_addr
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                ret

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm
                waitx   _21ms_                          ' Hold to let the idle state get settled
                mov     pa, #hreg_init_start            ' Reset all host common registers to startup values
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.regloop
discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
set_poll_target
                cmp     hkbd_ep_addr, #0        wz
        if_z    mov     poll_target, #0                 ' Unknown device, so no interrupt targets
        if_nz   mov     poll_target, #poll_kbd
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                cmp     poll_target, #0         wz
        if_z    jmp     #.nopoll
                pollct3                         wc
        if_c    call    poll_target                     ' Call the current poll/wait subroutine
.nopoll
                rdlong  htmp, cmd_data_p
                cmp     htmp, #CMD_SUSPEND      wz
        if_z    jmp     #hsuspend
                rdlong  htmp, cmd_data_p
                cmp     htmp, #CMD_RESET        wz
        if_z    wrlong  #ERR_NONE, cmd_data_p           ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                wrlong  #ERR_NONE, cmd_data_p           ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                rdlong  htmp, cmd_data_p
                cmp     htmp, #CMD_RESUME       wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
                wrlong  #ERR_NONE, cmd_data_p           ' Acknowledge resume cmd complete
                jmp     #set_poll_target                ' This addr configs a USB poll transaction and falls thru to hidle

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                flth    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvh    htmp                            ' Enable the port
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                call    #init_kbdm_data                 ' Reset keyboard/mouse data area to start-up values
                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                mov     hsearch_key, #TYPE_INTERFACE
                call    #hsearch_desc_type
                cmp     ptrb, #0                wz
        if_z    jmp     #hset_config                    ' No more interface descs
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset to next desc, if any
                rdbyte  hhid_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  htmp, ptrb[INTF_bIntfClass]
                cmp     htmp, #CLASS_HID        wz      ' Only interested in the HID class interface descriptors
        if_nz   jmp     #.next_intf                     ' Search next interface in chain, if any
                rdbyte  htmp, ptrb[INTF_bSubClass]      ' Look for a boot interface sub-class
                cmp     htmp, #SUBCLASS_INTF_BOOT wz
        if_nz   jmp     #.next_intf
                rdbyte  hr3, ptrb[INTF_bProtocol] wz    ' Protocol must be non-zero
        if_z    jmp     #.next_intf
.endp
                mov     hsave1, ptrb
                mov     hsave2, hnext_desc
                mov     hsearch_key, #TYPE_ENDPOINT
                call    #hsearch_desc_type              ' Endpoint descs always follow interface descs
                cmp     ptrb, #0                wz
        if_nz   jmp     #.get_ep
.bad_ep
                mov     hnext_desc, hsave2
                mov     ptrb, hsave1
                jmp     #.next_intf
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
        if_nc   jmp     #.bad_ep                        ' Not an IN endpoint
                shl     hr1, #8 + 7
                add     ptrb, #ENDP_wMaxPktSize
                rdword  hr2, ptrb++
                and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb                       ' Fetch the bInterval member (min poll interval, in milliseconds)
                mov     hnext_desc, hsave2
                mov     ptrb, hsave1
                cmp     hr3, #INTF_PROTO_KBD    wz
        if_nz   jmp     #.next_intf
.keyboard
                mov     ptra, kb_intf_num_p
                wrbyte  hhid_intf_idx, ptra++           ' Save interface index and poll interval values
                wrbyte  hr0, ptra++
                mov     hkbd_ep_addr, hctrl_ep_addr
                and     hkbd_ep_addr, ##ADDR_MASK
                or      hkbd_ep_addr, hr1               ' IN endpoint address
                wrbyte  hr2, ptra
                jmp     #.next_intf                     ' See if there's a mouse subclass

'------------------------------------------------------------------------------
' Search the configuration descriptor chain for a specific descriptor type.
'------------------------------------------------------------------------------
' On entry:
'   con_tot_len - total length of the config descriptor chain.
'   next_desc - offset from the configuration descriptor to start the search.
'     It is assumed that the offset will point to the start of a USB standard
'     descriptor.
'   search_key - descriptor type to match.
' On exit:
'   PTRB - if a match is found, the descriptor start address, otherwise zero.
'   next_desc - descriptor offset if found, otherwise unchanged.
'------------------------------------------------------------------------------
hsearch_desc_type
                mov     hsave0, hnext_desc
.next
                cmp     hnext_desc, hcon_tot_len  wcz
        if_ae   mov     ptrb, #0
        if_ae   mov     hnext_desc, hsave0
        if_ae   ret
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, hsearch_key        wz
        if_z    ret
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
'                mov     hkbd_ep_addr, #0                ' DEBUG
'                mov     hmouse_ep_addr, #0              ' DEBUG
                mov     htmp2, #DEV_UNKNOWN
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No boot keyboard or mouse interface
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No keyboard
                rdbyte  htmp, kb_intf_num_p
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                rdbyte  hpar2, kb_intf_num_p
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hkbd_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     htmp2, #KB_READY                ' Keyboard interface configured
.notify_client
        _ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0
                mov     ptra, kb_intf_num_p
                mov     pa, kb_report_p
                add     pa, #KBD_IN_RPT_LEN
.loop
                wrbyte  #0, ptra++
                cmp     pa, ptra                wcz
        if_b    jmp     #.loop
        _ret_   wrbyte  #PID_DATA0, kb_next_datax_p     ' Reset interrupt IN datax sequence PIDs

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                rdbyte  htmp, kb_intf_num_p
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, kb_led_states_p             ' Start address of OUT data
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     ptra, kb_in_max_pkt_p
                rdbyte  htmp, ptra++                    ' Always ask for max report size
                rdbyte  hpar3, ptra
                setword hpar3, htmp, #1                 ' Max IN packet size to expect
                mov     hpar2, kb_report_p
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret                                     ' No auto-repeat action
.data
                drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet
                mov     ptra, kb_next_datax_p
                rdbyte  hpar1, ptra
                cmp     hpar1, #PID_DATA0       wz
        if_z    mov     hpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     hpar1, #PID_DATA0
                wrbyte  hpar1, ptra++
                wrbyte  hpar3, ptra                     ' Save actual bytes read
.led_check
                rdbyte  htmp, kb_led_states_p
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                wrbyte  hkbd_ledstates, kb_led_states_p ' Update toggle key indicator states
                mov     ep_addr_pid, hctrl_ep_addr
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #host_error                     ' FIXME: on !ACK try to recover instead of fatal error
                ret

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start
urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
usb_cache_end

' USB
usbCmdData      long    0
usbErrCode      byte    0

' Class driver vars for keyboard boot protocol.
kbIntfNum       byte    0
kbInterval      byte    0
kbInMaxPkt      byte    0
kbNextDatax     byte    0
kbMaxIndex      byte    0
kbLedStates     byte    0
kbCurReport     byte    0[KBD_IN_RPT_LEN]
kbPreReport     byte    0[KBD_IN_RPT_LEN]


'------------------------------------------------------------------------------
' MSX Key encoder
'------------------------------------------------------------------------------

msx_encode_key
                mov     ptra, ##@kbCurReport
                mov     ptrb, ##@kbPreReport
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                mov     hpar1, #0
                rdbyte  hpar2, ##@kbCurReport
                call    #msx_set_key

_release        modc    _set    wc
                mov     ptra, ##@kbPreReport+2
                mov     pa, #6
.l1             rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.l3
                mov     ptrb, ##@kbCurReport+2
                mov     pb, #6
.l2             rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.l3
                djnz    pb, #.l2
                call    #msx_set_key
.l3             djnz    pa, #.l1

_press          modc    _clr    wc
                mov     ptra, ##@kbCurReport+2
                mov     pa, #6
.l1             rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.l3
                mov     ptrb, ##@kbPreReport+2
                mov     pb, #6
.l2             rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.l3
                djnz    pb, #.l2
                call    #msx_set_key
.l3             djnz    pa, #.l1

_copy           mov     ptra, ##@kbCurReport
                mov     ptrb, ##@kbPreReport
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                test    hpar2, #LEFT_GUIF   wz  ' check reset key combination
        if_nz   test    hpar2, #RIGHT_GUIF  wz  ' |
        if_nz   jmp     #\sys_reset             ' jump to system reset

                ret

' On entry:
'   hpar1 - USB key code
'   hpar2 - Shift state
msx_set_key
                test    hpar2, #KEYS_SHIFT  wz  ' SHIFT
                rdbyte  htmp, #@msx_keys+6
                muxz    htmp, #%00000001
                wrbyte  htmp, #@msx_keys+6

                test    hpar2, #KEYS_CTRL   wz  ' CTRL
                rdbyte  htmp, #@msx_keys+6
                muxz    htmp, #%00000010
                wrbyte  htmp, #@msx_keys+6

                test    hpar2, #KEYS_ALT   wz  ' ALT (GRAPH)
                rdbyte  htmp, #@msx_keys+6
                muxz    htmp, #%00000100
                wrbyte  htmp, #@msx_keys+6

                shl     hpar1, #1
                add     hpar1, ##@usb_table
                rdword  hpar1, hpar1
                getnib  ptrb, hpar1, #2
                add     ptrb, #@msx_keys
                rdbyte  htmp, ptrb
                muxc    htmp, hpar1
        _ret_   wrbyte  htmp, ptrb

' Translation table from USB key code to MSX keyboard matrix
usb_table
                word                       0  '00
                word                       0  '01
                word                       0  '02
                word                       0  '03
                word    (2 << 8) | %01000000  '04    a
                word    (2 << 8) | %10000000  '05    b
                word    (3 << 8) | %00000001  '06    c
                word    (3 << 8) | %00000010  '07    d
                word    (3 << 8) | %00000100  '08    e
                word    (3 << 8) | %00001000  '09    f
                word    (3 << 8) | %00010000  '0A    g
                word    (3 << 8) | %00100000  '0B    h
                word    (3 << 8) | %01000000  '0C    i
                word    (3 << 8) | %10000000  '0D    j
                word    (4 << 8) | %00000001  '0E    k
                word    (4 << 8) | %00000010  '0F    l
                word    (4 << 8) | %00000100  '10    m
                word    (4 << 8) | %00001000  '11    n
                word    (4 << 8) | %00010000  '12    o
                word    (4 << 8) | %00100000  '13    p
                word    (4 << 8) | %01000000  '14    q
                word    (4 << 8) | %10000000  '15    r
                word    (5 << 8) | %00000001  '16    s
                word    (5 << 8) | %00000010  '17    t
                word    (5 << 8) | %00000100  '18    u
                word    (5 << 8) | %00001000  '19    v
                word    (5 << 8) | %00010000  '1A    w
                word    (5 << 8) | %00100000  '1B    x
                word    (5 << 8) | %01000000  '1C    y
                word    (5 << 8) | %10000000  '1D    z
                word    (0 << 8) | %00000010  '1E    1
                word    (0 << 8) | %00000100  '1F    2
                word    (0 << 8) | %00001000  '20    3
                word    (0 << 8) | %00010000  '21    4
                word    (0 << 8) | %00100000  '22    5
                word    (0 << 8) | %01000000  '23    6
                word    (0 << 8) | %10000000  '24    7
                word    (1 << 8) | %00000001  '25    8
                word    (1 << 8) | %00000010  '26    9
                word    (0 << 8) | %00000001  '27    0
                word    (7 << 8) | %10000000  '28    Enter
                word    %0111_00000100  '29    Esc
                word    (7 << 8) | %00100000  '2A    BS
                word    (7 << 8) | %00001000  '2B    Tab
                word    (8 << 8) | %00000001  '2C    Space
                word    %0001_00000100  '2D    - and _
                word    %0001_00001000  '2E    = and +
                word    %0001_00100000  '2F    [ and {
                word    %0001_01000000  '30    ] and }
                word    %0001_00010000  '31    \ and |
                word                       0  '32    None-US # and ~
                word    %0001_10000000  '33    ; and :
                word    %0010_00000001  '34    ' and "
                word                       0  '35    ` and ~
                word    %0010_00000100  '36    , and <
                word    %0010_00001000  '37    . and >
                word    %0010_00010000  '38    / and ?
                word    %0110_00010000  '39    CapsLock
                word    (6 << 8) | %00100000  '3A    F1
                word    (6 << 8) | %01000000  '3B    F2
                word    (6 << 8) | %10000000  '3C    F3
                word    (7 << 8) | %00000001  '3D    F4
                word    (7 << 8) | %00000010  '3E    F5
                word                       0  '3F    F6
                word                       0  '40    F7
                word                       0  '41    F8
                word                       0  '42    F9
                word                       0  '43    F10
                word                       0  '44    F11
                word                       0  '45    F12
                word                       0  '46    PrScr
                word                       0  '47    ScrLock
                word                       0  '48    Pause
                word    %1000_00000100  '49    Insert
                word    %1000_00000010  '4A    Home
                word                       0  '4B    PageUp
                word    %1000_00001000  '4C    Delete
                word                       0  '4D    End
                word                       0  '4E    PageDown
                word    (8 << 8) | %10000000  '4F    Right
                word    (8 << 8) | %00010000  '50    Left
                word    (8 << 8) | %01000000  '51    Down
                word    (8 << 8) | %00100000  '52    Up
                word                       0  '53    NumLock
                word                       0  '54    (/)
                word    %1001_00000001  '55    (*)
                word    %1010_00100000  '56    (-)
                word    %1001_00000010  '57    (+)
                word                       0  '58    (Enter)
                word    %1001_00010000  '59    (1)
                word    %1001_00100000  '5A    (2)
                word    %1001_01000000  '5B    (3)
                word    %1001_10000000  '5C    (4)
                word    %1010_00000001  '5D    (5)
                word    %1010_00000010  '5E    (6)
                word    %1010_00000100  '5F    (7)
                word    %1010_00001000  '60    (8)
                word    %1010_00010000  '61    (9)
                word    %1001_00001000  '62    (0)
                word                       0  '63    (.)
                word                       0  '64    Non-US \ and |
                word                       0  '65    App

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, DEV_DISCONNECT
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
' Keyboard and mouse report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
    MOUSE_RPT_LEN   = 8     ' Maximum mouse boot protocol IN data packet size

DAT             ' ZiKore Z80 COG resident code
                org     $000

zk_cogbase
                add     ptrb, ##@zk_lutbase - @zk_cogbase
                setq2   #511
                rdlong  0, ptrb

                mov     zk_cycles, #5
                getct   zk_lastwait

zk_nextop
                lockrel #0                      ' release lock

                mul     zk_cycles, zk_cycletime
                addct1  zk_lastwait, zk_cycles
                waitct1

                locktry #0              wc      ' acquire lock for instruction processing
    if_nc       jmp     #$-1

                mov     zk_cycles, #0

                rdlong  zk_irq_ctl, #@tms_status
                testb   zk_irq_ctl, #8            wz   ' Z = VDP_IRQ
                rdlong  zk_irq_ctl, #@zk_irq_mem
                testb   zk_irq_ctl, #8            orz  ' Z = IRQ or VDP_IRQ
                testb   zk_irqenable,#ZK_IFF1_BIT andz ' Z = EI and (IRQ or VDP_IRQ)
        if_x1   jmp     #\zk_doirq                     ' jump if Z=1

                mov     zk_temphl, zk_hl
                mov     zk_hlptr, #zk_hl
                mov     zk_tempidx, zk_hl
                mov     zk_prefix, #0
                incmod  zk_refresh, #127

                call    #zk_readcode
                add     zk_cycles, #1
                mov     zk_opcode, zk_tmp8
                'debug(uhex_byte(zk_opcode))
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                'debug(uhex_long(zk_opimpl))
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
                push    #zk_nextop
                execf   zk_opimpl

zk_iyprefix
                mov     zk_hlptr, #zk_iy
zk_ixprefix
                mov     zk_hlptr, #zk_ix

                mov     zk_prefix, zk_opcode
                incmod  zk_refresh, #127
                add     zk_cycles, #1

                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc   jmp     #.nodisplace
                ' handle index displacement
                mov     zk_temphl, zk_hl
                alts    zk_hlptr
                mov     zk_tempidx, 0-0
                mov     zk_hlptr, #zk_hl
                call    #zk_readcode
                signx   zk_tmp8, #7
                add     zk_tempidx, zk_tmp8
                execf   zk_opimpl

.nodisplace
                alts    zk_hlptr
                mov     zk_temphl, 0-0
                mov     zk_tempidx, zk_temphl
                execf   zk_opimpl

zk_bitprefix
                call    #\zk_readcode
                mov     zk_opcode, zk_tmp8
                add     zk_cycles, #1
                incmod  zk_refresh, #127

                cmp     zk_prefix, #0 wz
        if_z    call    #zk_getrz
        if_nz   call    #zk_read8hl

                mov     pa, zk_opcode
                shr     pa, #3
                and     pa, #7

                testb   zk_opcode, #7 wc
                testb   zk_opcode, #6 wz
        if_00   jmp     #.shift
        if_01   jmp     #.bit
                bitz    zk_tmp8, pa
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix, #0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

.bit
                decod   pa
                and     pa, zk_tmp8 wz
                muxz    zk_flags, #(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
                bitl    zk_flags, #ZK_NMODE_BIT
                bith    zk_flags, #ZK_HALF_BIT
                setq    #1<<ZK_SIGN_BIT
                muxq    zk_flags, pa
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags, zk_tmp8

.shift
                push    #.shiftdone
                altd    pa, #zk_shift_impl_tbl
                execf   0-0

.shiftdone
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix,#0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

zk_shift_impl_tbl
                long    zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
                long    zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
                long    zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
                long    zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
                long    zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
                long    zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
                long    zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
                long    zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL

zk_extprefix
                call #\zk_readcode
                mov zk_opcode,zk_tmp8
                add zk_cycles,#1
                incmod zk_refresh,#127
                'debug("extend ",uhex_byte(zk_opcode))

                cmp zk_opcode,#$A0 wc
        if_ae   jmp #.blockop
                cmp zk_opcode,#$40 wc
        if_b    ret

                mov pa,zk_opcode
                and pa,#7
                altd pa,#zk_ext_impl_tbl
                execf 0-0

.blockop
                '' The undocumented flags on these are cursed.
                test    zk_opcode,#%0100_0100 wz
        if_nz   ret     ' NOP
                rczr    zk_opcode wcz ' get operation type into cz
        if_00   add     zk_cycles,#2
        if_01   add     zk_cycles,#5
        if_1x   add     zk_cycles,#1
        if_00   skipf   ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01   skipf   ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10   skipf   ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11   skipf   ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

                getword zk_ea,zk_debc,#0 ' IN
                call    #\zk_portin ' IN
                call    #\zk_read8hl ' everything else

                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
                bith    zk_flags,#ZK_NMODE_BIT ' CP
                testb   zk_tmp8,#7 wc ' IN/OUT
                bitc    zk_flags,#ZK_NMODE_BIT ' IN/OUT

                mov     zk_optmp0,zk_accu ' LD CP
                getbyte zk_optmp0,zk_hl,#0 ' OUT
                getbyte zk_optmp0,zk_debc,#0 ' IN
                testb   zk_opcode,#1 wc ' IN
                sumc    zk_optmp0,#1 ' IN
                mov     zk_optmp1,zk_tmp8 ' CP
                xor     zk_optmp1,zk_optmp0 ' CP

                sub     zk_optmp0,zk_tmp8 ' CP only
                add     zk_optmp0,zk_tmp8 ' LD,IN,OUT

                xor     zk_optmp1,zk_optmp0 ' CP
                and     zk_optmp0,#255 wz ' CP,IN,OUT
                bitz    zk_flags,#ZK_ZERO_BIT ' CP
                testb   zk_optmp0,#7 wc ' CP
                bitc    zk_flags,#ZK_SIGN_BIT ' CP

                testb   zk_optmp1,#4 wc   ' CP
                cmpr    zk_optmp0,#255 wc  ' IN/OUT
                bitc    zk_flags,#ZK_HALF_BIT ' CP
                muxc    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c    sub     zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

                skipf   ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
                skipf   ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
                skipf   ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
                skipf   ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


                testb   zk_optmp0,#1 wc ' LD,CP
                bitc    zk_flags,#5 'LD,CP (sets YF)
                testb   zk_optmp0,#3 wc ' LD,CP
                bitc    zk_flags,#3 'LD,CP (sets XF)

                getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
                and     zk_optmp0,#7 ' IN,OUT
                xor     zk_optmp0,zk_optmp1 wc ' IN,OUT
                bitnc   zk_flags,#ZK_OVER_BIT ' IN,OUT

                mov     zk_ea,zk_hl  ' IN
                getword zk_ea,zk_debc,#1 ' LD
                call    #\zk_write8 ' LD,IN
                getword zk_ea,zk_debc,#0 ' OUT
                call    #\zk_portout ' OUT

                getword zk_optmp1,zk_debc,#0 ' LD,CP
                decmod  zk_optmp1,zk_ffffh wz ' all
                setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
                setword zk_debc,zk_optmp1,#0 ' LD,CP
                bitnz   zk_flags,#ZK_OVER_BIT ' LD,CP
                bitz    zk_flags,#ZK_ZERO_BIT ' IN,OUT
                setq    #ZK_SIGNXYMASK ' IN,OUT
                muxq    zk_flags,zk_optmp1 ' IN,OUT

                testb   zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
                testb   zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc   incmod  zk_ea,zk_ffffh    ' LD
        if_c    decmod  zk_ea,zk_ffffh    ' LD
                setword zk_debc,zk_ea,#1 ' LD

        if_nc   incmod  zk_hl,zk_ffffh
        if_c    decmod  zk_hl,zk_ffffh

                testb   zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz    sub     zk_pc,#2
 if_c_and_nz    add     zk_cycles,#5
                'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
                ret

zk_ext_impl_tbl
                long    zk_cio + (%10_11_111_000000<<10) ' IN [BCDEHL0A],(C)
                long    zk_cio + (%00_01_111_000000<<10) ' OUT (C),[BCDEHL0A]
                long    zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
                long    zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
                long    zk_neg
                long    zk_irqret
                long    zk_imode
                long    zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7

                altd    pa,#zk_extmath16_impl_tbl
                altd    pa,#zk_extld16_impl_tbl
                altd    pa,#zk_extmisc_impl_tbl

                execf   0-0

zk_extmath16_impl_tbl
                long    zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
                long    zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
                long    zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
                long    zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
                long    zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
                long    zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
                long    zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
                long    zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
                long    zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
                long    zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
                long    zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
                long    zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
                long    zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
                long    zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
                long    zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
                long    zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
                long    zk_a2i                       ' LD I,A
                long    zk_a2r                       ' LD R,A
                long    zk_i2a                       ' LD A,I
                long    zk_r2a  + (%1_000<<10)       ' LD A,R
                long    zk_rxd + (%000_111_00<<10)   ' RRD
                long    zk_rxd + (%111_000_00<<10)   ' RLD
                long    zk_nextop                    ' NOP
                long    zk_nextop                    ' NOP

zk_rxd
                call    #\zk_read8hl
                add     zk_cycles,#4
                ' RLD
                rolnib  zk_tmp8,zk_accu,#0
                getnib  pa,zk_tmp8,#2
                setnib  zk_tmp8,#0,#2
                ' RRD
                setnib  zk_tmp8,zk_accu,#2
                getnib  pa,zk_tmp8,#0
                shr     zk_tmp8,#4

                setnib  zk_accu,pa,#0
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_accu
                jmp     #\zk_write8hl

zk_a2r
                mov     zk_refresh,zk_accu
                and     zk_refresh,#$7F
        _ret_   mov     zk_refreshhi,zk_accu

zk_a2i
        _ret_   mov     zk_ivector,zk_accu

zk_r2a
                mov     zk_accu,zk_refresh
                setq    #$80
                muxq    zk_accu,zk_refreshhi
zk_i2a
                mov     zk_accu,zk_ivector

                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_irqret       '' RETI/RETN
                '' These are literally the same
                testb   zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_irqenable,#ZK_IFF1_BIT
                call    #\zk_pop16
        _ret_   mov     zk_pc,zk_tmp16


zk_imode
                cmp     zk_opcode,#$5E  wz
        if_nz   cmp     zk_opcode,#$7E  wz
                bitz    zk_irqenable,#ZK_IM2_BIT
                ret

zk_irqoff
        _ret_   andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_irqon
        _ret_   or      zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_doirq
                add     zk_cycles,#5+2
                test    zk_irqenable,#(1<<ZK_HALT_BIT)  wz
        if_nz   incmod  zk_pc,zk_ffffh
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)|(1<<ZK_HALT_BIT) ' IRQ
                mov     zk_tmp16,zk_pc
                call    #\zk_push16

                test    zk_irqenable,#(1<<ZK_IM2_BIT)  wz
        if_z    mov     zk_pc,#$38 ' IM1/IM0

        if_nz   getbyte zk_ea,zk_irq_ctl,#0 ' IM2
        if_nz   setbyte zk_ea,zk_ivector,#1 ' IM2
        if_nz   call    #\zk_read16 ' IM2
        if_nz   mov     zk_pc,zk_tmp16 ' IM2

                jmp     #\zk_nextop

zk_jump_indir
        _ret_   mov     zk_pc,zk_temphl
zk_hl_to_sp
                add     zk_cycles,#2
        _ret_   mov     zk_sp,zk_temphl

zk_jump
                call    #\zk_readcode16
zk_condret
                add     zk_cycles,#1 ' Extra cycle in conditional RET

                testb   zk_flags,#ZK_ZERO_BIT wc
                testb   zk_flags,#ZK_CARRY_BIT wc
                testb   zk_flags,#ZK_OVER_BIT wc
                testb   zk_flags,#ZK_SIGN_BIT wc

                modc    _nc wc
        if_c    call    #\zk_nextop
zk_ret
                call    #zk_pop16
                mov     zk_optmp0,zk_tmp16 ' For every op!
zk_rst
                mov     zk_optmp0,zk_opcode
                and     zk_optmp0,#%00111000
zk_pushjmp
                mov     zk_tmp16,zk_pc
                mov     zk_pc,zk_optmp0
                jmp     #\zk_push16
                ret

zk_getrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                'debug("in zk_getrz ",uhex_byte(pa))
                add     pa,#zk_getrpa-$-1
                jmprel  pa
zk_getry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
zk_getrpa
                jmprel  pa
        _ret_   getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_   getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_   getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_   getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_   getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_   getbyte zk_tmp8,zk_temphl,#0 ' L register
                jmp     #zk_read8hl              ' (HL)
        _ret_   getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                add     pa,#zk_setrpa-$-1
                jmprel  pa
zk_setry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
                'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa       jmprel  pa
        _ret_   setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_   setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_   setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_   setbyte zk_debc,zk_tmp8,#2   ' E register
                jmp     #.seth                   ' H register
                jmp     #.setl                   ' L register
                jmp     #zk_write8hl             ' (HL)
        _ret_   setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
                setbyte zk_temphl,zk_tmp8,#1
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl
.setl
                setbyte zk_temphl,zk_tmp8,#0
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_push16
                add     zk_cycles,#1
                sub     zk_sp,#2
                setword zk_sp,#0,#1
                mov     zk_ea,zk_sp
                jmp     #zk_write16
zk_pop16
                mov     zk_ea,zk_sp
                add     zk_sp,#2
                setword zk_sp,#0,#1
                jmp     #zk_read16

zk_read16hl
                getword zk_ea,zk_tempidx,#0
zk_read16
                call    #zk_read8
                getbyte zk_tmp16,zk_tmp8,#0
                add     zk_ea,#1
                call    #zk_read8
                setbyte zk_tmp16,zk_tmp8,#1
        _ret_   sub     zk_ea,#1

zk_read8hl
                getword zk_ea,zk_tempidx,#0
                jmp     #zk_read8
zk_readcode
                mov     zk_ea,zk_pc
                incmod  zk_pc,zk_ffffh
                'setword zk_pc,#0,#1
                ' fall through
zk_read8
                add     zk_cycles, #3
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_00   jmp     #\msx_read8_0000
        if_01   jmp     #\msx_read8_4000
        if_10   jmp     #\msx_read8_8000
        if_11   jmp     #\msx_read8_C000

zk_readcode16
                call    #zk_readcode
                getbyte zk_tmp16,zk_tmp8,#0
                call    #zk_readcode
        _ret_   setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
                getword zk_ea,zk_tempidx,#0
zk_write16
                getbyte zk_tmp8,zk_tmp16,#0
                call    #zk_write8
                add     zk_ea,#1
                getbyte zk_tmp8,zk_tmp16,#1
                call    #zk_write8
        _ret_   sub     zk_ea,#1

zk_write8hl
                getword zk_ea,zk_tempidx,#0
zk_write8
                add     zk_cycles, #3
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_00   jmp     #\msx_write8_0000
        if_01   jmp     #\msx_write8_4000
        if_10   jmp     #\msx_write8_8000
        if_11   jmp     #\msx_write8_C000

zk_portout
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                getbyte pa, zk_ea, #0

                cmp     pa, #$98     wcz
        if_e    jmp     #\tms_ram_wr                ' 98 = video ram write
                cmp     pa, #$99     wcz
        if_e    jmp     #\tms_ctl_wr                ' 99 = video register write

                cmp     pa, #$A0     wcz
        if_e    jmp     #\psg_reg_write             ' A0 = psg register write
                cmp     pa, #$A1     wcz
        if_e    jmp     #\psg_write                 ' A1 = psg value write

                cmp     pa, #$A8     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #0
                cmp     pa, #$A9     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #1
                cmp     pa, #$AA     wcz
        if_e    jmp     #.ppi_c_wr
                cmp     pa, #$AB     wcz
        if_e    setbyte msx_ppi, zk_tmp8, #3
                ret     wcz

.ppi_c_wr
                setbyte msx_ppi, zk_tmp8, #2
                testb   zk_tmp8, #4     wc  ' motor control (REM)
                drvc    #TAPE_REM           ' |
                testb   zk_tmp8, #5     wc  ' tape write (MIC)
                drvc    #TAPE_MIC           ' |
                ret     wcz

zk_portin
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                mov     zk_tmp8, #$FF
                getbyte pa, zk_ea, #0

                cmp     pa, #$98     wcz
        if_e    jmp     #\tms_ram_rd                ' 98 = video ram read
                cmp     pa, #$99     wcz
        if_e    jmp     #\tms_status_rd             ' 99 = video status read

                cmp     pa, #$A2     wcz
        if_e    jmp     #\psg_read                  ' A2 = psg value read

                cmp     pa, #$A8     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #0
                cmp     pa, #$A9     wcz            ' keyboard row read
        if_e    jmp     #\msx_kb_read
                cmp     pa, #$AA     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #2
                cmp     pa, #$AB     wcz
        if_e    getbyte zk_tmp8, msx_ppi, #3

                ret     wcz

zk_ffffh        long    $FFFF
zk_18000h       long    $18000
zk_bit31        long    negx

zk_cycles       long    5
zk_pc           long    $0000

zk_flags        long    0
zk_accu         long    0
zk_debc         long    0
zk_sp           long    $F000
zk_hl           long    0
zk_ix           long    0
zk_iy           long    0
zk_altflags     long    0
zk_altaccu      long    0
zk_altdebc      long    0
zk_althl        long    0
zk_refresh      long    0
zk_refreshhi    long    0
zk_ivector      long    0
zk_irqenable    long    0

zk_cycletime    long    _CLKFREQ / ZK_CLOCK

msx_ppi         long    $00_00_00_00

msx_psg_latch   long    0

tms_flag        long    0
tms_ramptr      long    0
tms_tmp0        long    0
tms_tmp1        long    0

zk_lastwait     res     1

zk_opcode       res     1
zk_opimpl       res     1
zk_prefix       res     1
zk_temphl       res     1
zk_tempidx      res     1
zk_hlptr        res     1
zk_tmp16        res     1

zk_optmp0       res     1
zk_optmp1       res     1

zk_tmp0         res     1
zk_tmp8         res     1 ' memory read/write value
zk_ea           res     1 ' remapped EA
zk_irq_ctl      res     1
zk_nmi_ctl      res     1

                fit     $1F0

DAT             ' ZiKore Z80 LUT resident code
                org     $200
zk_lutbase

zk_rolla        mov     zk_tmp8,zk_accu
zk_shiftop
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

                bitl    zk_tmp8,#7 wcz  ' left + SRA
                bitz    zk_tmp8,#7 addbits 1 ' only SRA
                bitl    zk_tmp8,#0 wcz  ' right
                modc    _set wc ' only SLL
                modc    _clr wc ' only SLA

                testb   zk_flags,#ZK_CARRY_BIT wc' only RL/RR
                bitz    zk_flags,#ZK_CARRY_BIT

                rcl     zk_tmp8,#1 wz   ' left
                bitc    zk_tmp8,#8     ' right (not SRA/SRL)
                shr     zk_tmp8,#1 wz   ' right

                setq    #ZK_XYMASK
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

        _ret_   mov     zk_accu,zk_tmp8

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_tmp8,#$FF wc
        _ret_   bitnc   zk_flags,#ZK_OVER_BIT

zk_cio
                mov     zk_optmp1,zk_opcode
                and     zk_optmp1,#7<<3
                cmp     zk_optmp1,#6<<3 wz
                mov     zk_tmp8,#0
        if_nz   call    #\zk_getry
                getword zk_ea,zk_debc,#0
zk_immio
                call    #\zk_readcode
                mov     zk_ea,zk_tmp8
                setbyte zk_ea,zk_accu,#1

                mov     zk_tmp8,zk_accu
                jmp     #\zk_portout

                call    #\zk_portin
        _ret_   mov     zk_accu,zk_tmp8

                and     zk_tmp8,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

                cmp     zk_optmp1,#6<<3 wz
        if_z    ret
                jmp     #\zk_setry

zk_incdec8
                call    #\zk_getry
                mov     zk_optmp0,#1
zk_math8
                call    #\zk_getrz
zk_immmath
                call    #\zk_readcode
                mov     zk_optmp0,zk_tmp8
                mov     zk_tmp8,zk_accu

                modc    _clr wc
                testb   zk_flags,#ZK_CARRY_BIT wc

                ' Flag helper gunk
                mov     zk_optmp1,zk_tmp8

                addx    zk_tmp8,zk_optmp0
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_tmp8,zk_optmp0
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_tmp8
                test    zk_tmp8,#$100 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                and     zk_tmp8,#255 wz

                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8
                ' Special nonsense for CP
                setq    #ZK_XYMASK
                muxq    zk_flags,zk_optmp0

                mov     zk_accu,zk_tmp8
                call    #\zk_setry

                xor     zk_optmp1,zk_optmp0
                bitz    zk_flags,#ZK_ZERO_BIT
                testb   zk_optmp1,#4 wc
                bitc    zk_flags,#ZK_HALF_BIT
                test    zk_optmp1,#$180 wc
        _ret_   bitc    zk_flags,#ZK_OVER_BIT

zk_neg
                cmp     zk_accu,#$80 wz
                bitz    zk_flags,#ZK_OVER_BIT
                testb   zk_accu,#4 wz
                subr    zk_accu,#0 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                testb   zk_accu,#4 xorz
                bitz    zk_flags,#ZK_HALF_BIT
                and     zk_accu,#$FF wz
                bitz    zk_flags,#ZK_ZERO_BIT
                bith    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu


zk_cpl
                xor     zk_accu,#$FF
                or      zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_math16
                modc    _clr wc
zk_cmath16
                testb   zk_flags,#ZK_CARRY_BIT wc

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                mov     zk_optmp1,zk_temphl
                xor     zk_optmp1,zk_tmp16

                addx    zk_temphl,zk_tmp16
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_temphl,zk_tmp16
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_temphl
                and     zk_temphl,zk_ffffh wz

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_optmp1,zk_18000h wc
                bitc    zk_flags,#ZK_OVER_BIT

                getbyte pa,zk_temphl,#1
                setq    #ZK_SIGNXYMASK
                setq    #ZK_XYMASK
                muxq    zk_flags,pa

                testb   zk_optmp1,#12 wc
                bitc    zk_flags,#ZK_HALF_BIT
                testb   zk_optmp1,#16 wc
                bitc    zk_flags,#ZK_CARRY_BIT

                add     zk_cycles,#7

                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_daa
                mov     zk_optmp0,#$00
                mov     zk_tmp8,zk_accu
                cmpr    zk_tmp8,#$99 wc
                testb   zk_flags,#ZK_CARRY_BIT orc
        if_c    add     zk_optmp0,#$60
                bitc    zk_flags,#ZK_CARRY_BIT
                getnib  zk_optmp1,zk_tmp8,#0
                cmpr    zk_optmp1,#$9 wc
                testb   zk_flags,#ZK_HALF_BIT orc
        if_c    add     zk_optmp0,#$06
                testb   zk_flags,#ZK_NMODE_BIT wc
                sumc    zk_accu,zk_optmp0
                and     zk_accu,#255 wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT ' Parity?
                testb   zk_accu,#4 wc
                testb   zk_tmp8,#4 xorc
                bitc    zk_flags,#ZK_HALF_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_immlogic
                call    #\zk_readcode
zk_logic
                call    #\zk_getrz

                and     zk_accu,zk_tmp8 wcz
                or      zk_accu,zk_tmp8 wcz
                xor     zk_accu,zk_tmp8 wcz

                bitnc   zk_flags,#ZK_OVER_BIT ' parity
                bitz    zk_flags,#ZK_ZERO_BIT
                andn    zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                bith    zk_flags,#ZK_HALF_BIT ' Only for AND
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_pushaf
                getbyte zk_tmp16,zk_accu,#0
                rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
                add     zk_cycles,#2
zk_pushbc       getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde       getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl       mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                jmp     #\zk_push16

                add     zk_tmp16,#1
                sub     zk_tmp16,#1

zk_loadimm16
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16   ' for LDs with (imm16)
                call    #\zk_read16     ' ^^
                jmp     #\zk_write16     ' ^^
zk_poppair
                call    #\zk_pop16

        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

                getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_   getbyte zk_flags,zk_tmp16,#0  ' set F

zk_jr           '' JR and DJNZ
                call    #\zk_readcode

                getbyte pa,zk_debc,#1
                sub     pa,#1 wz
                setbyte zk_debc,pa,#1
                add     zk_cycles,#1

                testb   zk_flags,#ZK_ZERO_BIT wz
                testb   zk_flags,#ZK_CARRY_BIT wz

                modz    _nz wz
        if_z    call    #\zk_nextop
                ' branch taken
                add     zk_cycles,#5
                signx   zk_tmp8,#7
        _ret_   add     zk_pc,zk_tmp8

zk_exx          '' EXX
                xor     zk_debc,zk_altdebc
                xor     zk_altdebc,zk_debc
                xor     zk_debc,zk_altdebc
                ' Note: not affected by IX/IY substitution
                xor     zk_hl,zk_althl
                xor     zk_althl,zk_hl
        _ret_   xor     zk_hl,zk_althl

zk_ex_dehl      '' EX DE,HL
                ' Note: not affected by IX/IY substitution
                getword zk_optmp0,zk_debc,#1
                setword zk_debc,zk_hl,#1
        _ret_   mov     zk_hl,zk_optmp0


zk_ex_hlstk     '' EX (SP),HL
                add     zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
                mov     zk_ea,zk_sp
                call    #\zk_read16
                altd    zk_hlptr
                mov     0-0,zk_tmp16
                mov     zk_tmp16,zk_temphl
                jmp     #\zk_write16

zk_ld_abs16     '' LD HL,(imm16) and LD (imm16),HL
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl ' get HL/I*
                mov     zk_tmp16,zk_sp ' get SP
                jmp     #\zk_write16

                call    #\zk_read16
        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   mov     zk_sp,zk_tmp16

zk_scf
                modc    _clr wc
zk_ccf
                testb   zk_flags,#ZK_CARRY_BIT wc
                bitnc   zk_flags,#ZK_CARRY_BIT
                bitc    zk_flags,#ZK_HALF_BIT
                bitl    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_ld_abs       '' LD A,(imm16) and LD (imm16),A
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16
zk_a_and_ptr    '' A and (BC)/(DE) ops
                getword zk_ea,zk_debc,#0 ' get BC
                getword zk_ea,zk_debc,#1 ' get DE
                call    #\zk_read8
        _ret_   mov     zk_accu,zk_tmp8
                mov     zk_tmp8,zk_accu
                jmp     #\zk_write8

zk_regmove
                push    #zk_setry
                jmp     #\zk_getrz

zk_loadimm8
                push    #zk_setry
                jmp     #\zk_readcode

zk_ex_af        '' EX AF,AF'
                xor     zk_accu,zk_altaccu
                xor     zk_altaccu,zk_accu
                xor     zk_accu,zk_altaccu
                xor     zk_flags,zk_altflags
                xor     zk_altflags,zk_flags
        _ret_   xor     zk_flags,zk_altflags

zk_halt
                or      zk_irqenable,#(1<<ZK_HALT_BIT)
        _ret_   decmod  zk_pc,zk_ffffh

'
' MSX
'
msx_read8_0000
                testb   msx_ppi, #1     wc
                testb   msx_ppi, #0     wz
                jmp     #msx_read8
msx_read8_4000
                testb   msx_ppi, #3     wc
                testb   msx_ppi, #2     wz
                jmp     #msx_read8
msx_read8_8000
                testb   msx_ppi, #5     wc
                testb   msx_ppi, #4     wz
                jmp     #msx_read8
msx_read8_C000
                testb   msx_ppi, #7     wc
                testb   msx_ppi, #6     wz
msx_read8
                getword pa, zk_ea, #0
        if_00   jmp     #\msx_slot0_read    ' 0 = 32K ROM
        if_01   jmp     #\msx_slot1_read    ' 1 = cartridge A
        if_10   ret     wcz                 ' 2 = cartridge B
        if_11   jmp     #\msx_slot3_read    ' 3 = 64K RAM

msx_write8_0000
                testb   msx_ppi, #1     wc
                testb   msx_ppi, #0     wz
                jmp     #msx_write8
msx_write8_4000
                testb   msx_ppi, #3     wc
                testb   msx_ppi, #2     wz
                jmp     #msx_write8
msx_write8_8000
                testb   msx_ppi, #5     wc
                testb   msx_ppi, #4     wz
                jmp     #msx_write8
msx_write8_C000
                testb   msx_ppi, #7     wc
                testb   msx_ppi, #6     wz
msx_write8
                getword pa, zk_ea, #0
        if_00   ret     wcz                 ' 0 = 32K ROM
        if_01   ret     wcz                 ' 1 = cartridge A
        if_10   ret     wcz                 ' 2 = cartridge B
        if_11   jmp     #\msx_slot3_write   ' 3 = 64K RAM

msx_slot0_read
                testb   zk_ea, #15      wc
                testb   zk_ea, #14      wz
        if_11   ret     wcz                 ' C000-FFFF empty
                add     pa, ##@msx_slot0
                rdbyte  zk_tmp8, pa
                ret     wcz

msx_slot1_read
                mov     zk_tmp0, ##(@msx_slot1_end - @msx_slot1) >> 10
                cmp     zk_tmp0, #32 wcz
        if_e    testb   pa, #15 wc
        if_e    and     pa, ##$3FFF
        if_e    bitc    pa, #14
                cmp     zk_tmp0, #16 wcz
        if_e    and     pa, ##$3FFF
                cmp     zk_tmp0, #8  wcz
        if_e    and     pa, ##$1FFF
                add     pa, ##@msx_slot1
                rdbyte  zk_tmp8, pa
                ret     wcz

msx_slot3_read
                add     pa, ##@msx_slot3
                rdbyte  zk_tmp8, pa
                ret     wcz

msx_slot3_write
                add     pa, ##@msx_slot3
                wrbyte  zk_tmp8, pa
                ret     wcz

                fit     $400

DAT             ' ZiKore Z80 opcode table
                orgh

zk_optable      '' Opcode table
                long    zk_nextop                                           ' $00: NOP
                long    zk_loadimm16 + (%0000_1_111_0<<10)                  ' $01: LD BC,imm16
                long    zk_a_and_ptr + (%001110<<10)                        ' $02: LD (BC),A
                long    zk_incdec16+(%0000_1_1111_10_1_11100<<10)           ' $03: INC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $04: INC B
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $05: DEC B
                long    zk_loadimm8                                         ' $06: LD B,imm8
                long    zk_rolla+(%0_010_110_01_11110_00<<10)               ' $07: RLCA
                long    zk_ex_af                                            ' $08: EX AF,AF'
                long    zk_math16+(%0010_111_00_1100_00_1110_1_0<<10)       ' $09: ADD HL,BC
                long    zk_a_and_ptr + (%000010<<10)                        ' $0A: LD A,(BC)
                long    zk_incdec16+(%0000_1_1111_01_1_11100<<10)           ' $0B: DEC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $0C: INC C
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $0D: DEC C
                long    zk_loadimm8                                         ' $0E: LD C,imm8
                long    zk_rolla+(%0_010_001_01_11011_00<<10)               ' $0F: RRCA
                long    zk_jr + (%01_11_0000_0<<10)                         ' $10: DJNZ
                long    zk_loadimm16 + (%0001_1_111_0<<10)                  ' $11: LD DE,imm16
                long    zk_a_and_ptr + (%00110 <<10)+1                      ' $12: LD (DE),A
                long    zk_incdec16+(%0001_1_1111_10_1_11010<<10)           ' $13: INC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $14: INC D
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $15: DEC D
                long    zk_loadimm8                                         ' $16: LD D,imm8
                long    zk_rolla+(%0_010_110_00_11110_00<<10)               ' $17: RLA
                long    zk_jr + (%11_11_1111_0<<10)                         ' $18: JR
                long    zk_math16+(%0010_111_00_1100_00_1101_1_0<<10)       ' $19: ADD HL,DE
                long    zk_a_and_ptr + (%00000 <<10)+1                      ' $1A: LD A,(DE)
                long    zk_incdec16+(%0001_1_1111_01_1_11010<<10)           ' $1B: DEC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $1C: INC E
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $1D: DEC E
                long    zk_loadimm8                                         ' $1E: LD E,imm8
                long    zk_rolla+(%0_010_001_00_11011_00<<10)               ' $1F: RRA
                long    zk_jr + (%01_10_1111_0<<10)                         ' $20: JR NZ
                long    zk_loadimm16 + (%0011_1_111_0<<10)                  ' $21: LD HL,imm16
                long    zk_ld_abs16 + (%01011_00<<10)                       ' $22: LD (imm16),HL
                long    zk_incdec16+(%0011_1_1111_10_1_10110<<10)           ' $23: INC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $24: INC H
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $25: DEC H
                long    zk_loadimm8                                         ' $26: LD H,imm8
                long    zk_daa                                              ' $27: DAA
                long    zk_jr + (%00_10_1111_0<<10)                         ' $28: JR Z
                long    zk_math16+(%0010_111_00_1100_00_1011_1_0<<10)       ' $29: ADD HL,HL
                long    zk_ld_abs16 + (%00110_11111_00<<10)                 ' $2A: LD HL,(imm16)
                long    zk_incdec16+(%0011_1_1111_01_1_10110<<10)           ' $2B: DEC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $2C: INC L
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $2D: DEC L
                long    zk_loadimm8                                         ' $2E: LD L,imm8
                long    zk_cpl                                              ' $2F: CPL
                long    zk_jr + (%01_01_1111_0<<10)                         ' $30: JR NC
                long    zk_loadimm16 + (%0111_1_111_0<<10)                              ' $31: LD SP,imm16
                long    zk_ld_abs + (%001111_00<<10)                                    ' $32: LD (imm16),A
                long    zk_incdec16+(%0111_1_1111_10_1_01110<<10)                       ' $33: INC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP       ' $34: INC (HL)
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP       ' $35: DEC (HL)
                long    zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
                long    zk_scf + (%10 << 10)                 ' $37: SCF
                long    zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
                long    zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
                long    zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
                long    zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
                long    zk_loadimm8                          ' $3E: LD A,imm8
                long    zk_ccf                               ' $3F: CCF
                long    zk_nextop                            ' $40: LD B,B (NOP)
                long    zk_regmove                           ' $41: LD B,C
                long    zk_regmove                           ' $42: LD B,D
                long    zk_regmove                           ' $43: LD B,E
                long    zk_regmove                           ' $44: LD B,H
                long    zk_regmove                           ' $45: LD B,L
                long    zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
                long    zk_regmove                           ' $47: LD B,A
                long    zk_regmove                           ' $48: LD C,B
                long    zk_nextop                            ' $49: LD C,C (NOP)
                long    zk_regmove                           ' $4A: LD C,D
                long    zk_regmove                           ' $4B: LD C,E
                long    zk_regmove                           ' $4C: LD C,H
                long    zk_regmove                           ' $4D: LD C,L
                long    zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
                long    zk_regmove                           ' $4F: LD C,A
                long    zk_regmove                           ' $50: LD D,B
                long    zk_regmove                           ' $51: LD D,C
                long    zk_nextop                            ' $52: LD D,D (NOP)
                long    zk_regmove                           ' $53: LD D,E
                long    zk_regmove                           ' $54: LD D,H
                long    zk_regmove                           ' $55: LD D,L
                long    zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
                long    zk_regmove                           ' $57: LD D,A
                long    zk_regmove                           ' $58: LD E,B
                long    zk_regmove                           ' $59: LD E,C
                long    zk_regmove                           ' $5A: LD E,D
                long    zk_nextop                            ' $5B: LD E,E (NOP)
                long    zk_regmove                           ' $5C: LD E,H
                long    zk_regmove                           ' $5D: LD E,L
                long    zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
                long    zk_regmove                           ' $5F: LD E,A
                long    zk_regmove                           ' $60: LD H,B
                long    zk_regmove                           ' $61: LD H,C
                long    zk_regmove                           ' $62: LD H,D
                long    zk_regmove                           ' $63: LD H,E
                long    zk_nextop                            ' $64: LD H,H (NOP)
                long    zk_regmove                           ' $65: LD H,L
                long    zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
                long    zk_regmove                           ' $67: LD H,A
                long    zk_regmove                           ' $68: LD L,B
                long    zk_regmove                           ' $69: LD L,C
                long    zk_regmove                           ' $6A: LD L,D
                long    zk_regmove                           ' $6B: LD L,E
                long    zk_regmove                           ' $6C: LD L,H
                long    zk_nextop                            ' $6D: LD L,L (NOP)
                long    zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
                long    zk_regmove                           ' $6F: LD L,A
                long    zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
                long    zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
                long    zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
                long    zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
                long    zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
                long    zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
                long    zk_halt                              ' $76: HALT
                long    zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
                long    zk_regmove                           ' $78: LD A,B
                long    zk_regmove                           ' $79: LD A,C
                long    zk_regmove                           ' $7A: LD A,D
                long    zk_regmove                           ' $7B: LD A,E
                long    zk_regmove                           ' $7C: LD A,H
                long    zk_regmove                           ' $7D: LD A,L
                long    zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
                long    zk_nextop                            ' $7F: LD A,A (NOP)
                long   (zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
                long   (zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
                long   (zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
                long   (zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
                long   (zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
                long    zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
                long    zk_logic + (%000000_110_0<<10)       ' $A7: AND A
                long   (zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
                long    zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
                long    zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
                long   (zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
                long    zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
                long    zk_logic + (%001000_101_0<<10)       ' $B7: OR A
                long   (zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
                long    zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
                long    zk_poppair+(%0_0<<10)                  ' $C1: POP BC
                long    zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
                long    zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
                long    zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
                long    zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
                long    zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
                long    zk_rst                               ' $C7: RST 00h
                long    zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
                long    zk_ret + (%0101_11_00<<10)           ' $C9: RET
                long    zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
                long    zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
                long    zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
                long    zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
                long    zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
                long    zk_rst                               ' $CF: RST 08h
                long    zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
                long    zk_poppair+(%01_0<<10)                 ' $D1: POP DE
                long    zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
                long    zk_immio + (%00_000<<10)               ' $D3: OUT (imm8),A
                long    zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
                long    zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
                long    zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
                long    zk_rst                               ' $D7: RST 10h
                long    zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
                long    zk_exx                               ' $D9: EXX
                long    zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
                long    zk_immio + (%00_11_000<<10)            ' $DB: IN A,(imm8)
                long    zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
                long    zk_ixprefix                          ' $DD: IX prefix
                long    zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
                long    zk_rst                               ' $DF: RST 18h
                long    zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
                long    zk_poppair+(%0011_0<<10)               ' $E1: POP HL
                long    zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
                long    zk_ex_hlstk                          ' $E3: EX (SP),HL
                long    zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
                long    zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
                long    zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
                long    zk_rst                               ' $E7: RST 20h
                long    zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
                long    zk_jump_indir                          ' $E9: JP (HL)
                long    zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
                long    zk_ex_dehl                           ' $EB: EX DE,HL
                long    zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
                long    zk_extprefix + ZK_HLOP               ' $ED: extension prefix
                long    zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
                long    zk_rst                               ' $EF: RST 28h
                long    zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
                long    zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
                long    zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
                long    zk_irqoff                              ' $F3: DI
                long    zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
                long    zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
                long    zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
                long    zk_rst                               ' $F7: RST 30h
                long    zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
                long    zk_hl_to_sp                            ' $F9: LD SP,(HL)
                long    zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
                long    zk_irqon                               ' $FB: EI
                long    zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
                long    zk_iyprefix + (%10<<10)              ' $FD: IY prefix
                long    zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
                long    zk_rst                               ' $FF: RST 38h


CON ' ZiKore Z80 constants

    ZK_CLOCK      = 3_576_000
    ZK_HLOP       = 1 << 10

    ZK_CARRY_BIT  = 0
    ZK_NMODE_BIT  = 1
    ZK_OVER_BIT   = 2 ' also parity
    ZK_HALF_BIT   = 4
    ZK_ZERO_BIT   = 6
    ZK_SIGN_BIT   = 7

    ZK_XYMASK     = %0010_1000
    ZK_SIGNXYMASK = %1010_1000

    ZK_IFF1_BIT   = 0
    ZK_IFF2_BIT   = 1
    ZK_HALT_BIT   = 2
    ZK_IM2_BIT    = 3

DAT             ' TMS9918
                org     $000

tms_driver
                add     ptrb, ##@tms_palette - @tms_driver
                setq2   #511                    ' load video drivers into lut
                rdlong  0, ptrb

                call    #\(VIDEO == VGA ? vga_init : cvbs_init) ' start video driver

                mov     scol, #0
                xcont   #10,#0                  ' do streamer instruction to start interrupt sequence
'
'
' Main program
'
loop
                cmp     _cl, scnt           wcz
    if_z        jmp     #loop

                mov     scol, scol+1
                mov     scnt, _cl

                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192      wz
    if_ne       jmp     #.skip

                locktry #0              wc
    if_nc       jmp     #$-1
                rdlong  a, #@tms_status         ' update status byte
                or      a, #TMSVSYNC            ' vsync flag
                test    regs+1, #TMSINTEN   wz  ' interrupt enable
                bitnz   a, #8                   ' IRQ
                wrlong  a, #@tms_status
                lockrel #0

.skip           setq    #1                      ' read registers into temp buffer
                rdlong  sbuf, #@tms_regs        ' |

                getnib  scol+1, sbuf+1, #6      ' border color for next line
                movbyts scol+1, #0

                getbyte regs+0, sbuf, #0
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
                getbyte regs+1, sbuf, #1
                getbyte regs+2, sbuf, #2
                shl     regs+2, #10             ' name table base address * $400
                add     regs+2, _tms_vram
                getbyte regs+3, sbuf, #3
                shl     regs+3, #6              ' color table base address * $40
    if_nz       andn    regs+3, vdp_8k_mask     ' limit color table to 8k boundaries
                add     regs+3, _tms_vram
                getbyte regs+4, sbuf+1, #0
                shl     regs+4, #11             ' pattern generator base address * $800
    if_nz       andn    regs+4, vdp_8k_mask     ' limit pattern table to 8k boundaries
                add     regs+4, _tms_vram
                getbyte r4_mask, sbuf+1, #0
                and     r4_mask, #%00000011
                shl     r4_mask, #8
                getbyte regs+5, sbuf+1, #1
                shl     regs+5, #7              ' sprite attribute table base address * $80
                add     regs+5, _tms_vram
                getbyte regs+6, sbuf+1, #2
                shl     regs+6, #11             ' sprite pattern generator base address * $800
                add     regs+6, _tms_vram
                getbyte regs+7, sbuf+1, #3

                cmp     _cl, #(VIDEO == PAL ? 48 : 24)  wcz ' check if first visible line
    if_c        jmp     #loop
                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192    wc  ' check if last visible line
    if_nc       jmp     #loop

    if_z        mov     loff, #0                ' if first line reset counters...
    if_z        mov     lcnt, #0
    if_z        mov     ptrv, _tms_bitmap       ' ...and pointers

                setq    #32-1                   ' read all sprite attribute table
                rdlong  sbuf, regs+5

scanline
                mov     ptra, ptrv

                test    regs+1, #TMSBLANK   wz  ' blank
    if_z        jmp     #blank_line

                test    regs+1, #TMSMODE1   wz  ' text mode
                mov     a, lcnt
                andn    a, #$07                 ' divide and multiply by 8
                mov     b, a
                shl     a, #2                   ' multiply by 32
    if_nz       add     a, b                    ' multiply by 40
                add     regs+2, a
    if_nz       jmp     #text_mode

                test    regs+1, #TMSMODE2   wz  ' multicolor mode
    if_nz       jmp     #multicolor_mode

                jmp     #graphics_mode

text_mode
                getnib  ctmp, regs+7, #1        ' foreground color
                shl     ctmp, #8
                setnib  ctmp, regs+7, #0        ' background color

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                mov     ptrb, regs+2

                mov     ecnt, #40
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, loff
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                shr     a, #8
                mov     cbuf+1, ctmp
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++
                sub     ptra, #2

                djnz    ecnt, #.loop

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                jmp     #end_scanline

blank_line
                getnib  ctmp, regs+7, #0        ' background color
                movbyts ctmp, #0

                mov     ecnt, #256/4            ' fill line with background
.l1             wrlong  ctmp, ptra++
                djnz    ecnt, #.l1

                jmp     #end_scanline

multicolor_mode
                mov     a, lcnt
                shr     a, #2
                and     a, #$07

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3
                add     ptrc, regs+4            ' points to color table
                add     ptrc, a

                rdbyte  cbuf+0, ptrc            ' colors

                mov     cbuf+1, cbuf+0
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0
                shr     cbuf+0, #4          wz
    if_z        setnib  cbuf+0, regs+7, #0

                movbyts cbuf+0, #%%0000
                movbyts cbuf+1, #%%0000

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                jmp     #sprites

graphics_mode
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       mov     a, lcnt
    if_nz       shr     a, #6                   ' divide by 64 (8 rows by 8 pixels)
    if_nz       shl     a, #8                   ' multiply by 2048
    if_nz       and     a, r4_mask
    if_nz       shl     a, #3                   ' multiply by 2048 (cont.)
                mov     b, loff                 ' offset into pattern table
    if_nz       add     b, a                    ' add mode II pattern table offset

                bitnz   .shlr, #21              ' patch shl(0)/shr(1)

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display

                mov     ptrd, ptrc
.shlr           shl     ptrd, #3
                add     ptrd, regs+3            ' points to color table
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       add     ptrd, b
                rdbyte  a, ptrd                 ' colors

                getnib  cbuf+0, a, #0
                and     cbuf+0, #$0F        wz
    if_z        setnib  cbuf+0, regs+7, #0
                getnib  cbuf+1, a, #1
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0

                setbyte cbuf+0, cbuf+1, #1
                mov     cbuf+1, cbuf+0

                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, b
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                movbyts cbuf+0, a
                shr     a, #8
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                ' fall through

sprites
                mov     ecnt, #9                ' clear collision buffer
.l1             altd    ecnt, #line-1           ' |
                mov     0-0, #0                 ' |
                djnz    ecnt, #.l1              ' |

                mov     b, #8                   ' calculate sprite size
                test    regs+1, #TMSSPRSIZE wz  ' |
    if_nz       shl     b, #1                   ' |
                test    regs+1, #TMSSPRMAG  wz  ' |
    if_nz       shl     b, #1                   ' b = 8/16/32

                mov     stat, #0
                mov     vcnt, #0
                mov     ccnt, #0

                mov     ecnt, #TMSSPRITES
.l2             alts    ccnt, #sbuf             ' find last sprite
                getbyte y, 0-0, #0              ' |
                cmp     y, #$D0             wz  ' |
    if_e        jmp     #.loop                  ' |
                add     y, #1                   ' |
                cmp     y, #$D0             wcz ' |
    if_a        sub     y, #$100                ' |
                                                ' |
                mov     a, lcnt                 ' | check sprite scanline visibility
                subs    a, y                wc  ' | |
    if_b        jmp     #.l3                    ' | |
                cmp     a, b                wc  ' | |
    if_ae       jmp     #.l3                    ' | |
                add     vcnt, #1                ' | vcnt = number of sprites on scanline
                                                ' |
.l3             add     ccnt, #1                ' |
                djnz    ecnt, #.l2              ' |

.loop           decmod  ccnt, #0            wc  ' loop backward to draw visible sprites
    if_c        jmp     #.end                   ' |

                alts    ccnt, #sbuf
                mov     sprt, 0-0

                getbyte y, sprt, #0
                add     y, #1
                cmp     y, #$D0             wcz
    if_a        sub     y, #$100

                mov     a, lcnt                 ' check sprite scanline visibility
                subs    a, y                wc
    if_b        jmp     #.loop
                cmp     a, b                wc
    if_ae       jmp     #.loop

                cmps    vcnt, #5            wcz
    if_e        mov     stat, ccnt              ' set 5th sprite
    if_e        or      stat, #TMS5SPRITE       ' |
                sub     vcnt, #1
    if_ae       jmp     #.loop                  ' comment to remove sprite limit

                getbyte ptrc, sprt, #2
                test    regs+1, #TMSSPRSIZE wz
    if_nz       and     ptrc, #$FC
                shl     ptrc, #3
                add     ptrc, regs+6
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shr     a, #1
                add     ptrc, a

                getnib  ctmp, sprt, #6          'set sprite color
                shl     ctmp, #8

                getbyte x, sprt, #1
                testb   sprt, #31           wz  'TMSEARLYCLK
    if_x1       sub     x, #32
                mov     ptra, ptrv
                add     ptra, x

                test    regs+1, #TMSSPRSIZE wz
    if_z        mov     ecnt, #4
    if_nz       mov     ecnt, #8

                rdbyte  sprt, ptrc
                shl     sprt, #8
    if_nz       add     ptrc, #16
    if_nz       rdbyte  a, ptrc
    if_nz       or      sprt, a

                test    regs+1, #TMSSPRMAG  wz
    if_nz       setword sprt, sprt, #1
    if_nz       mergew  sprt
    if_z        shl     sprt, #16

                cmps    x, #0       wc          ' skip left offscreen pixels
    if_c        abs     x                       ' |
    if_c        add     ptra, x                 ' |
    if_c        sub     ecnt, x                 ' |
    if_c        cmps    x, #32      wz          ' |
    if_c_and_z  mov     sprt, #0                ' |
    if_c_and_nz shl     sprt, x                 ' |
    if_c        mov     x, #0                   ' |

                mov     cbuf, sprt
                mov     cbuf+1, cbuf

                mov     y, x                    ' check sprite collision
                sar     y, #5                   ' |
                add     y, #line                ' |
                setd    .c0, y                  ' |
                setd    .c0+1, y                ' |
                add     y, #1                   ' |
                setd    .c1, y                  ' |
                setd    .c1+1, y                ' |
                mov     a, x                    ' |
                and     a, #$1F     wz          ' |
    if_z        mov     cbuf+1, #0              ' |
                shr     cbuf, a                 ' |
.c0             test    0-0, cbuf   wz          ' |
                or      0-0, cbuf               ' |
                mov     y, #32                  ' |
                sub     y, a                    ' |
                shl     cbuf+1,y                ' |
.c1 if_z        test    0-0, cbuf+1 wz          ' |
                or      0-0, cbuf+1             ' |
    if_nz       or      stat, #%0010_0000       ' update collision flag
                mov     line+8, #0              ' clear right offscreen pixels

                rev     sprt

.draw           getnib  a, sprt, #0
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                wmlong  cbuf+0, ptra++
                add     x, #4
                cmp     x, #256     wc
                shr     sprt, #4    wz
    if_c_and_nz djnz    ecnt, #.draw

                jmp     #.loop
.end

                locktry #0              wc
    if_nc       jmp     #$-1
                rdbyte  a, #@tms_status         ' update status byte
                test    stat, #TMSCOLL      wz
    if_nz       or      a, #TMSCOLL
                test    a, #TMS5SPRITE      wz
    if_z        or      a, stat
                wrbyte  a, #@tms_status
                lockrel #0

end_scanline
                add     ptrv, #256
                incmod  loff, #7
                incmod  lcnt, #192-1

                jmp     #loop
'
'
' Data
'
dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

cx              long    0
cy              long    0

vga_xf          long   (VGA_FPIX frac _CLKFREQ) >> 1             ' streamer frequency setting
vga_bs          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +   8    ' streamer command: before-sync
vga_ds          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  48    ' streamer command: during-sync
vga_as          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  24    ' streamer command: after sync
vga_vi          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + 320    ' streamer command: visible
vga_bv          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: before visible
vga_dv          long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 + 256    ' streamer command: during visible
vga_av          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: after visible
vga_pn          long    VGA_PIN & $38       ' base pin

cvbs_cb         long    VIDEO == PAL ? PAL_CB : NTSC_CB             ' colorburst reference color
cvbs_cy         long    VIDEO == PAL ? PAL_CY : NTSC_CY             ' colorspace y coefficients
cvbs_ci         long    VIDEO == PAL ? PAL_CI : NTSC_CI             ' colorspace i coefficients
cvbs_cq         long    VIDEO == PAL ? PAL_CQ : NTSC_CQ             ' colorspace q coefficients
cvbs_ca         long    VIDEO == PAL ? PAL_CA : NTSC_CQ             ' colorspace q coefficients, alt for pal
cvbs_cf         long   (VIDEO == PAL ? PAL_CF : NTSC_CF) frac _CLKFREQ ' colorspace frequency setting
cvbs_xf         long    VIDEO == PAL ? PAL_XF : NTSC_XF             ' streamer frequency setting

cvbs_bs         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  10 :  10)    ' streamer command: before-sync
cvbs_ds         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  30 :  27)    ' streamer command: during-sync
cvbs_bc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?   6 :   4)    ' streamer command: before-colorburst
cvbs_dc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  15)    ' streamer command: during-colorburst
cvbs_ac         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  17 :   9)    ' streamer command: after-colorburst
cvbs_db         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_bv         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  28)    ' streamer command: before-visible
cvbs_dv         long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 +                    256        ' streamer command: during-visible
cvbs_av         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  29)    ' streamer command: after-visible
cvbs_vi         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_hl         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  14)    ' streamer command: high-vsync-low
cvbs_hh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 183 : 165)    ' streamer command: high-vsync-high

cvbs_ll         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 177 : 161)    ' streamer command: low-vsync-low
cvbs_lh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  21 :  18)    ' streamer command: low-vsync-high

cvbs_pn         long    CVBS_PIN            ' pin(s)

_md             long    0
_lb             long    0                   ' line buffer pointer
_cl             long    0                   ' current line
_tms_vram       long    @tms_vram
_tms_bitmap     long    @tms_bitmap

vdp_8k_mask     long    $1FFF
r4_mask         long    0

a               res     1
b               res     1
x               res     1
y               res     1

scnt            res     1
scol            res     2                       'backdrop/border color

lcnt            res     1
loff            res     1
ccnt            res     1
vcnt            res     1
ecnt            res     1

ctmp            res     1
cbuf            res     2
sprt            res     1

ptrc            res     1
ptrd            res     1
ptrv            res     1

stat            res     1
regs            res     8
sbuf            res     32

line            res     8+1

DAT             ' VGA / CVBS drivers
                org     $200

tms_palette
                long    $00_00_00_00
                long    $00_00_00_00
                long    $66_CC_66_00
                long    $88_EE_88_00
                long    $44_44_DD_00
                long    $77_77_FF_00
                long    $BB_55_55_00
                long    $77_DD_DD_00
                long    $DD_66_66_00
                long    $FF_77_77_00
                long    $CC_CC_55_00
                long    $EE_EE_88_00
                long    $55_AA_55_00
                long    $BB_55_BB_00
                long    $CC_CC_CC_00
                long    $EE_EE_EE_00
'
'
' VGA Driver
'
vga_init
                setcmod #%01_0_000_1            ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16   ' g
                setcq   ##VGA_INTENSITY << 08   ' b
                setxfrq vga_xf                  ' set transfer frequency

                cogid   cx                      ' insert cogid into dac modes
                setnib  dacmode_s,cx,#2
                setnib  dacmode_c,cx,#2

                wrpin   dacmode_s,vga_pn        ' enable 123-ohm 3.3V dac mode in pin +0

                xor     vga_pn,#2<<6|1          ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c,vga_pn

                xor     vga_pn,#3<<6 ^(2<<6|1)  ' make pins +0..3 outputs
                drvl    vga_pn

                xor     vga_pn,#4|(3<<6)        ' leave av_base pointing to pin +4 (vertical sync)
                drvh    vga_pn

                mov     ijmp1,##vga_field       ' set up streamer-empty interrupt
        _ret_   setint1 #10
'
'
' Field loop
'
vga_field
                mov     cy,#24                  ' before-visible blank lines
                calld   pa, #.border

                mov     _lb, _tms_bitmap

                mov     cy,#192                 ' visible lines
.line           xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1

                rdfast  #4, _lb                 ' start reading pixels into fifo
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                ' duplicate line
                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line

                add     _lb, #256
                resi1
                djnz    cy,#.line

                mov     cy,#24                  ' after-visible blank lines
                calld   pa, #.border

                mov     cy, #10
                calld   pa, #.blank

                drvnot  vga_pn                  ' vertical sync on
                mov     cy, #2
                calld   pa, #.blank
                drvnot  vga_pn                  ' vertical sync off

                mov     _cl, #0

                mov     cy, #33
                calld   pa, #.blank

                jmp     #vga_field              ' loop
'
'
' Subroutines
'
.border         xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.border
                jmp     pa

.blank          xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,#0               ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.blank              ' loop if more blanks needed
                jmp     pa
'
'
' CVBS Driver
'
cvbs_init
                setcmod #%11_1_0000             ' set colorspace converter to YIQ mode (composite)
                setcy   cvbs_cy                 ' set colorspace converter y coefficients
                setci   cvbs_ci                 ' set colorspace converter i coefficients
                setcq   cvbs_cq                 ' set colorspace converter q coefficients
                setcfrq cvbs_cf                 ' set colorspace converter frequency
                setxfrq cvbs_xf                 ' set transfer frequency

                cogid   cx                      ' install cogid into dacmode
                setnib  dacmode_c,cx,#2
                wrpin   dacmode_c,cvbs_pn       ' enable dac mode in pin(s)
                drvl    cvbs_pn                 ' enable dac output(s)

                mov     ijmp1,##cvbs_field      ' set up streamer-empty interrupt
        _ret_   setint1 #10

cvbs_field
                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' before-visible blank lines
                calld   pa, #.border            ' |

                rdfast  #0, _tms_bitmap         ' start reading pixels into fifo
                mov     cy, #192                ' visible lines

.line           xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |

                xcont   cvbs_bv, scol           ' left border
                resi1
                xcont   cvbs_dv, #0             ' visible part (from streamer)
                resi1
                xcont   cvbs_av, scol           ' right border
                resi1

                djnz    cy, #.line

                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' after-visible blank lines
                calld   pa, #.border            ' |

                mov     cy, #(VIDEO == PAL ? 8 : 2)                  ' before-visible blank lines
                calld   pa, #.blank             ' |

                mov     _cl, #0

                mov     cy, #6
                calld   pa, #.vhigh             ' initial high vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vlow              ' low vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vhigh             ' final high vertical syncs

                mov     cy, #(VIDEO == PAL ? 8 : 10)                 ' before-visible blank lines
                calld   pa, #.blank             ' |

                jmp     #cvbs_field             ' loop

.border         xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_vi, scol           ' blank line
                resi1                           ' |
                djnz    cy, #.border
                jmp     pa

.blank          xcont   cvbs_bs, #1             ' horizontal sync
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_db, #1             ' blank line
                resi1                           ' |
                djnz    cy, #.blank
                jmp     pa

.vhigh          xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_hl, #2             ' |
                resi1                           ' |
                xcont   cvbs_hh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vhigh
                jmp     pa

.vlow           xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_ll, #2             ' |
                resi1                           ' |
                xcont   cvbs_lh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vlow
                jmp     pa

                fit     $3F0

CON ' TMS9918 constants

    TMSMODE3   = %00000010      ' mode bit 3
    TMSEXTVID  = %00000001      ' external video

    ' register 1 control bits
    TMS4K16K   = %10000000      ' 4/16K RAM
    TMSBLANK   = %01000000      ' screen blank
    TMSINTEN   = %00100000      ' interrupt enable
    TMSMODE1   = %00010000      ' mode bit 1
    TMSMODE2   = %00001000      ' mode bit 2
    TMSSPRSIZE = %00000010      ' sprite size
    TMSSPRMAG  = %00000001      ' sprite magnification

    TMSVSYNC   = %10000000      ' frame sync
    TMS5SPRITE = %01000000      ' 5th sprite
    TMSCOLL    = %00100000      ' coincidence flag

    TMSSPRITES = 32

CON ' VGA constants

    VGA           = 0
    VGA_FPIX      = 12_500_000
    VGA_INTENSITY = 80    '0..128

CON ' CVBS constants

    NTSC            = 1
    NTSC_BLANK_LEV  = 40.0                                  'levels
    NTSC_BLACK_LEV  = NTSC_BLANK_LEV + 7.5
    NTSC_PEAK_LEV   = NTSC_BLANK_LEV + 140.0
    NTSC_SCALE      = 127.0 / NTSC_PEAK_LEV * 128.0
    NTSC_SCALE_COR  = NTSC_SCALE / 1.646                    'CORDIC prescale for IQ modulator

    NTSC_BLANK      = round(NTSC_SCALE * 2.0 * NTSC_BLANK_LEV / NTSC_PEAK_LEV)
    NTSC_BLACK      = round(NTSC_SCALE * 2.0 * NTSC_BLACK_LEV / NTSC_PEAK_LEV)

    NTSC_YR         = round(NTSC_SCALE     *  0.299)        'Y sums to 1
    NTSC_YG         = round(NTSC_SCALE     *  0.587)
    NTSC_YB         = round(NTSC_SCALE     *  0.114)

    NTSC_IR         = round(NTSC_SCALE_COR *  0.596)        'I sums to 0
    NTSC_IG         = round(NTSC_SCALE_COR * -0.274)
    NTSC_IB         = round(NTSC_SCALE_COR * -0.322)

    NTSC_QR         = round(NTSC_SCALE_COR *  0.212)        'Q sums to 0
    NTSC_QG         = round(NTSC_SCALE_COR * -0.523)
    NTSC_QB         = round(NTSC_SCALE_COR *  0.311)

    NTSC_CY         = (NTSC_YR & $FF) << 24 + (NTSC_YG & $FF) << 16 + (NTSC_YB & $FF) << 8 + NTSC_BLACK
    NTSC_CI         = (NTSC_IR & $FF) << 24 + (NTSC_IG & $FF) << 16 + (NTSC_IB & $FF) << 8 + NTSC_BLANK
    NTSC_CQ         = (NTSC_QR & $FF) << 24 + (NTSC_QG & $FF) << 16 + (NTSC_QB & $FF) << 8 + 128

    NTSC_CB         = $809000_01                            'colorburst reference color
    NTSC_CF         = 3_579_545                             'colorburst frequency
    NTSC_CC         = round(227.5 * 4.0)                    'color cycles per line * 4 to preserve fraction
    NTSC_X_TOTAL    = 378

    'NTSC_DOTF       = (NTSC_X_TOTAL * (NTSC_CF * 4 * 128)) / NTSC_CC
    'NTSC_I          = 31 - encod _CLKFREQ
    NTSC_XF         = $030B8EB8 ' ((NTSC_DOTF >> (7 - NTSC_I)) frac (_CLKFREQ << NTSC_I) + 1) >> 1

    PAL             = 2
    PAL_BLANK_LEV   = 43.0                                  'levels
    PAL_BLACK_LEV   = PAL_BLANK_LEV + 0.0
    PAL_PEAK_LEV    = PAL_BLANK_LEV + 140.0
    PAL_SCALE       = 127.0 / PAL_PEAK_LEV * 128.0
    PAL_SCALE_COR   = PAL_SCALE / 1.646                     'CORDIC prescale for IQ modulator

    PAL_BLANK       = round(PAL_SCALE * 2.0 * PAL_BLANK_LEV / PAL_PEAK_LEV)
    PAL_BLACK       = round(PAL_SCALE * 2.0 * PAL_BLACK_LEV / PAL_PEAK_LEV)

    PAL_YR          = round(PAL_SCALE     *  0.299)         'Y sums to 1
    PAL_YG          = round(PAL_SCALE     *  0.587)
    PAL_YB          = round(PAL_SCALE     *  0.114)

    PAL_UR          = round(PAL_SCALE_COR * -0.147)         'I sums to 0
    PAL_UG          = round(PAL_SCALE_COR * -0.289)
    PAL_UB          = round(PAL_SCALE_COR *  0.436)

    PAL_VR          = round(PAL_SCALE_COR *  0.615)         'Q sums to 0
    PAL_VG          = round(PAL_SCALE_COR * -0.515)
    PAL_VB          = round(PAL_SCALE_COR * -0.100)

    PAL_CY          = ( PAL_YR & $FF) << 24 + ( PAL_YG & $FF) << 16 + ( PAL_YB & $FF) << 8 + PAL_BLACK
    PAL_CI          = ( PAL_UR & $FF) << 24 + ( PAL_UG & $FF) << 16 + ( PAL_UB & $FF) << 8 + PAL_BLANK
    PAL_CQ          = ( PAL_VR & $FF) << 24 + ( PAL_VG & $FF) << 16 + ( PAL_VB & $FF) << 8 + 128
    PAL_CA          = (-PAL_VR & $FF) << 24 + (-PAL_VG & $FF) << 16 + (-PAL_VB & $FF) << 8 + 128

    PAL_CB          = $FFC060_01                            'colorburst reference color
    PAL_CF          = 4_433_618                             'colorburst frequency
    PAL_CC          = round(283.75 * 4.0)                   'color cycles per line * 4 to preserve fraction
    PAL_X_TOTAL     = 416

    'PAL_DOTF        = (PAL_X_TOTAL * (PAL_CF * 4 * 128)) / PAL_CC
    'PAL_I           = 31 - encod _CLKFREQ
    PAL_XF          = $0353F900 ' ((PAL_DOTF >> (7 - PAL_I)) frac (_CLKFREQ << PAL_I) + 1) >> 1

DAT ' AY-3-8912 cog code
                    org     $000

ay_emu
                    fltl    leftp
                    fltl    rightp
                    wrpin   r1, leftp
                    wrpin   r1, rightp
                    wxpin   sampleRate, leftp
                    wxpin   sampleRate, rightp
                    wypin   dac_center, leftp
                    wypin   dac_center, rightp
                    drvh    leftp
                    drvh    rightp

' Read all AY registers from hub memory and convert
' them to more convenient representations.
mainLoop
getRegisters
                    setq    #4-1
                    rdlong  temp1, ptra
                    getword frequency1, temp1, #0           ' reg 0+1
                    shl     frequency1, #20
                    getword frequency2, temp1, #1           ' reg 2+3
                    shl     frequency2, #20
                    getword frequency3, temp2, #0           ' reg 4+5
                    shl     frequency3, #20
                    getbyte noisePeriod, temp2, #2          ' reg 6
                    and     noisePeriod, #$1f
                    fge     noisePeriod, #2
                    shl     noisePeriod, #20
                    getbyte enableRegister, temp2, #3       ' reg 7
                    setd    oscValues, enableRegister
                    getbyte amplitude1, temp3, #0           ' reg 8
                    getbyte amplitude2, temp3, #1           ' reg 9
                    getbyte amplitude3, temp3, #2           ' reg 10
                    getbyte envelopePeriod, temp4, #0       ' reg 12
                    rolbyte envelopePeriod, temp3, #3       ' reg 11
                    shl     envelopePeriod, #16         wz
    if_z            mov     envelopePeriod, half_period     ' 0 == half the period of 1
                    getbyte envelopeShape, temp4, #1        ' reg 13

' Calculate AY samples channel 1-3 and store in out1-out3
                    mov     mixOut, dac_center              '  DC offset

'        Envelope shaping -> envelopeAmplitude
Envelope            sub     envCounter, envSubValue     wc  ' Handle envelope incrementation
    if_c            add     envCounter, envelopePeriod
    if_c            add     envelopeValue, envelopeInc
                    fle     envCounter, envelopePeriod

                    test    envelopeShape, #16          wz  ' Handle envelope "reset bit" ( Extra bit added by Ahle2 )
    if_z            neg     envelopeValue, #0
    if_z            mov     envelopeInc, #1
    if_z            mov     envCounter, envelopePeriod
    if_z            or      envelopeShape, #16
    if_z            wrbyte  envelopeShape, ptra[13/1]       ' <-IMPORTANT, sets bit 5 ("reset bit") of envelope shape register in hub ram

                    test    envelopeShape, #8           wc  ' Handle envelope continue = 0
                    test    envelopeShape, #4           wz
    if_nc_and_z     mov     envelopeShape, #9
    if_nc_and_nz    mov     envelopeShape, #15

                    test    envelopeShape, #2           wz  ' Sets the envelope hold level
                    muxz    envHoldLevel, #15               '

                    test    envelopeValue, #16          wz  ' Check if > 15
                    test    envelopeShape, #1           wc  ' Check hold bit
    if_nz_and_c     mov     envelopeInc, #0                 ' Hold envelope
    if_nz_and_c     mov     envelopeValue, envHoldLevel     '

    if_nz           test    envelopeShape, #2           wc  ' Check and handle envelope alternation
    if_nz_and_c     neg     envelopeInc, envelopeInc
    if_nz_and_c     add     envelopeValue, envelopeInc

                    mov     envelopeAmplitude, envelopeValue
                    test    envelopeShape, #4           wc  ' Check and handle envelope invertion (attack)
    if_nc           xor     envelopeAmplitude, #15          ' (Move Value or ~Value to envelopeAmplitude)


' Waveform shaping noise -> bit 3 of oscValues
Noise1              sub      phaseAccumulatorN, noiseSubValue wc ' Noise generator
    if_nc           jmp      #Env1
                    add      phaseAccumulatorN, noisePeriod
                    test     noiseValue, noiseTap       wc
                    muxc     noiseValue, noiseMSB
                    shr      noiseValue, #1             wc
    if_c            xor      oscValues, #8


' Waveform shaping channel 1 -> out1
Env1                test     amplitude1, #16            wz  ' Selects envelope or fixed amplitude
    if_nz           mov      amplitude1, envelopeAmplitude  ' depending on bit 5 of amplitude register 1

Square1             cmp      frequency1, freqRef        wc
    if_nc           sub      phaseAccumulator1, oscSubValue wc  ' Square wave generator
    if_c            add      phaseAccumulator1, frequency1      ' channel 1
    if_c            xor      oscValues, #1

                    test     oscValues, mask513         wz  ' Handles mixing of channel 1
    if_nz           test     oscValues, mask4104        wz
                    getnib   arg1, amplitude1, #0
                    alts     arg1, #amplitudeTable
                    sumnz    mixOut, 0-0                    ' Tone on/off, Noise on/off
    'if_z            mov      out1, r1                       ' out1 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)

' Waveform shaping channel 2 -> out2

Env2                test     amplitude2, #16            wz  ' Selects envelope or fixed amplitude
    if_nz           mov      amplitude2, envelopeAmplitude  ' depending on bit 5 of amplitude register 2

Square2             cmp      frequency2, freqRef        wc
    if_nc           sub      phaseAccumulator2, oscSubValue wc  ' Square wave generator
    if_c            add      phaseAccumulator2, frequency2      ' channel 2
    if_c            xor      oscValues, #2

                    test     oscValues, mask1026        wz  ' Handles mixing of channel 2
    if_nz           test     oscValues, mask8200        wz
                    getnib   arg1, amplitude2, #0
                    alts     arg1, #amplitudeTable
                    sumnz    mixOut, 0-0                    ' Tone on/off, Noise on/off
    'if_z            mov      out2, r1                       ' out2 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)


' Waveform shaping channel 3 -> out3
Env3                test     amplitude3, #16            wz  ' Selects envelope or fixed amplitude
    if_nz           mov      amplitude3, envelopeAmplitude  ' depending on bit 5 of amplitude register 3
                    mov      arg1, amplitude3

Square3             cmp      frequency3, freqRef        wc
    if_nc           sub      phaseAccumulator3, oscSubValue wc  ' Square wave generator
    if_c            add      phaseAccumulator3, frequency3      ' channel 3
    if_c            xor      oscValues, #4

                    test     oscValues, mask2052        wz  ' Handles mixing of channel 3
    if_nz           test     oscValues, mask16392       wz
                    getnib   arg1, amplitude3, #0
                    alts     arg1, #amplitudeTable
                    sumnz    mixOut, 0-0                    ' Tone on/off, Noise on/off
    'if_z            mov      out3, r1                       ' out3 = (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)

' Mix channels and update FRQA/FRQB PWM-values
mixer
                    'testp   rightp   wc
                    'drvc #38 ' light LED if too slow
                    testp   rightp      wc
    if_nc           jmp     #$-1
                    wypin   mixOut,leftp
                    wypin   mixOut,rightp
                    jmp     #mainLoop

'    Variables, tables, masks and reference values
amplitudeTable      long    trunc(AMPLITUDE_LEVEL_0)
                    long    trunc(AMPLITUDE_LEVEL_1)
                    long    trunc(AMPLITUDE_LEVEL_2)
                    long    trunc(AMPLITUDE_LEVEL_3)
                    long    trunc(AMPLITUDE_LEVEL_4)
                    long    trunc(AMPLITUDE_LEVEL_5)
                    long    trunc(AMPLITUDE_LEVEL_6)
                    long    trunc(AMPLITUDE_LEVEL_7)
                    long    trunc(AMPLITUDE_LEVEL_8)
                    long    trunc(AMPLITUDE_LEVEL_9)
                    long    trunc(AMPLITUDE_LEVEL_A)
                    long    trunc(AMPLITUDE_LEVEL_B)
                    long    trunc(AMPLITUDE_LEVEL_C)
                    long    trunc(AMPLITUDE_LEVEL_D)
                    long    trunc(AMPLITUDE_LEVEL_E)
                    long    trunc(AMPLITUDE_LEVEL_F)

'Masks and reference values
mask513             long    513
mask1026            long    1026
mask2052            long    2052
mask4104            long    4104
mask8200            long    8200
mask16392           long    16392
mask32bit           long    $ffffffff
mask16bit           long    $ffff
half_period         long    $00008000
val31bit            long    $80000000
noiseMSB            long    1 << NOISE_MSB
noiseTap            long    NOISE_TAP
sampleRate          long    _CLKFREQ / SAMPLE_RATE
freqRef             long    10 << 20
dac_center          long    $7F80
leftp               long    AUDIO_LEFT_PIN
rightp              long    AUDIO_RIGHT_PIN

'Setup and subroutine parameters
arg1                long    0
r1                  long    P_DAC_75R_2V|P_OE|P_DAC_DITHER_PWM

'AY variables
noiseValue          long    $ffff
envCounter          long    1
envSubValue         long    ENV_CORR
oscSubValue         long    OSC_CORR
noiseSubValue       long    NOISE_CORR
envelopeValue       long    0
envelopeInc         long    1

envHoldLevel        res     1
oscValues           res     1
amplitude1          res     1
amplitude2          res     1
amplitude3          res     1
envelopeAmplitude   res     1
enableRegister      res     1
envelopeShape       res     1
frequency1          res     1
frequency2          res     1
frequency3          res     1
envelopePeriod      res     1
noisePeriod         res     1
phaseAccumulatorN   res     1
phaseAccumulator1   res     1
phaseAccumulator2   res     1
phaseAccumulator3   res     1
mixOut              res     1
temp1               res     1
temp2               res     1
temp3               res     1
temp4               res     1

                    fit     $1F0

CON ' AY-3-8912 constants

    ' WARNING !!
    ' Don't alter the constants below unless you know what you are doing
    '-------------------------------------------------------------------
    PSG_FREQ    = 1_773_400.0               ' Clock frequency input on the emulated AY chip
    SAMPLE_RATE = round(PSG_FREQ/ 16.0)     ' Sample rate of AYcog (PSG_FREQ/ 16.0 is the HW-accurate value)

    OSC_CORR    = trunc(1.05 * PSG_FREQ * ((PSG_FREQ/ 16.0)/float(SAMPLE_RATE))) ' Relative oscillator frequency (Where does the 1.05 come from?)
    NOISE_CORR  = OSC_CORR>>1               ' Relative noise frequency
    ENV_CORR    = OSC_CORR>>5               ' Relative envelope timing

    NOISE_TAP = %1001                       ' LFSR noise constants
    NOISE_MSB = 17                          '

    VOLUME_CORRECTION = 0.7                 ' Volume correction value
    MAX_AMPLITUDE     = float($7F7F / 4)    ' maxDACvalue / numberOfChannels (this makes room for maximum "swing" on all channels)
    AMPLITUDE_DAMP_FACTOR = 0.75            ' The damp factor between each volume step

    AMPLITUDE_LEVEL_F = MAX_AMPLITUDE     * VOLUME_CORRECTION
    AMPLITUDE_LEVEL_E = AMPLITUDE_LEVEL_F * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_D = AMPLITUDE_LEVEL_E * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_C = AMPLITUDE_LEVEL_D * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_B = AMPLITUDE_LEVEL_C * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_A = AMPLITUDE_LEVEL_B * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_9 = AMPLITUDE_LEVEL_A * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_8 = AMPLITUDE_LEVEL_9 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_7 = AMPLITUDE_LEVEL_8 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_6 = AMPLITUDE_LEVEL_7 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_5 = AMPLITUDE_LEVEL_6 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_4 = AMPLITUDE_LEVEL_5 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_3 = AMPLITUDE_LEVEL_4 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_2 = AMPLITUDE_LEVEL_3 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_1 = AMPLITUDE_LEVEL_2 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_0 = 0.0

DAT             ' I/O Hub-exec code
                orgh

'
' MSX
'
msx_kb_read
                getbyte zk_tmp0, msx_ppi, #2
                and     zk_tmp0, #%00001111
                add     zk_tmp0, #@msx_keys
                rdbyte  zk_tmp8, zk_tmp0
                ret     wcz

'
' TMS9918
'
tms_ctl_wr
                testb   tms_flag, #0    wz
         if_x0  jmp     #\tms_data_wr
         if_x1  jmp     #\tms_reg_wr

tms_data_wr     bith    tms_flag, #0
                getbyte tms_tmp0, zk_tmp8, #0
                ret     wcz

tms_reg_wr      bitl    tms_flag, #0
                testb   zk_tmp8, #7     wz
        if_x0   jmp     #tms_addr_wr
                mov     tms_tmp1, zk_tmp8
                and     tms_tmp1, #$07
                cmp     tms_tmp1, #1    wz      ' Z = Reg1 (may be INT enable)
                add     tms_tmp1, #@tms_regs
                wrbyte  tms_tmp0, tms_tmp1
        if_nz   ret     wcz
                rdlong  tms_tmp1, #@tms_status
                testb   zk_tmp8, #5     wc      ' C = INT ENABLE
                testb   tms_tmp1, #5    andc    ' FSync
                bitc    tms_tmp1, #8            ' Generate IRQ if INT enable and FSync
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

tms_addr_wr     mov     tms_ramptr, zk_tmp8
                and     tms_ramptr, #$3F
                shl     tms_ramptr, #8
                or      tms_ramptr, tms_tmp0
                ret     wcz

tms_rd
                testb   zk_ea, #0       wz
        if_x0   jmp     #\tms_ram_rd
        if_x1   jmp     #\tms_status_rd

tms_ram_wr      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                wrbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_ram_rd      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                rdbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_status_rd   rdlong  tms_tmp1, #@tms_status
                getbyte zk_tmp8, tms_tmp1, #0
                and     tms_tmp1, #%000_11111
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

'
' AY-3-8910
'
psg_reg_write
                getnib  msx_psg_latch, zk_tmp8, #0
                ret     wcz

psg_write
                cmp     msx_psg_latch, #$0E wcz ' port A
        if_e    ret     wcz
                mov     zk_tmp0, #@psg_regs
                add     zk_tmp0, msx_psg_latch
                wrbyte  zk_tmp8, zk_tmp0
                ret     wcz

psg_read
                cmp     msx_psg_latch, #$0E wcz ' port A
        if_e    jmp     #.porta_rd
                mov     zk_tmp0, #@psg_regs
                add     zk_tmp0, msx_psg_latch
                rdbyte  zk_tmp8, zk_tmp0
                ret     wcz

.porta_rd
                testp   #TAPE_EAR       wc  ' tape read (EAR)
                bitc    zk_tmp8, #7         ' |
                ret     wcz

DAT             ' Z80 Memory Space
                orgh

msx_slot0       'file    "cbios_main_msx1.rom"
                file    "msx.rom"
                file    "cbios_logo_msx1.rom"

msx_slot1
                'file    "Galaga (1984)(Namcot).rom" ' 32K
                'file    "Galaxian (1984)(Namcot).rom" ' 8K
                'file    "Lode Runner (1984)(Sony).rom" ' 32K
                'file    "Moon Patrol (1984)(Irem).rom" ' 16K
                'file    "Mr. Do! (1984)(Nippon Columbia - Colpax - Universal).rom" ' 16K
                'file    "Pac-Man (1984)(Namcot).rom" ' 16K
                'file    "Pitfall (1984)(Pony Canyon).rom" ' 16K
                'file    "Pitfall II - Lost Caverns (1985)(Pony Canyon).rom" ' 16K
                'file    "Q-Bert (1986)(Konami)[RC-746].rom" ' 32K
                'file    "River Raid (1984) (Pony Cannon) (J).rom"
                'file    "Space Invaders (1985)(Taito).rom" ' 16K
                'file    "Super Cobra (1983)(Konami)[RC-705].rom" ' 8K
                'file    "Time Pilot (1983)(Konami)[RC-703].rom" ' 16K
                'file    "Zanac (1986)(Pony Canyon).rom" ' 32K
                'file    "Zaxxon (1985)(Pony Canyon).rom" ' 32K
msx_slot1_end

msx_slot3       byte    0[65536]

tms_vram        byte    0[16384]                    ' TMS9918 video ram

tms_bitmap      ' Memory used as rendered bitmap
