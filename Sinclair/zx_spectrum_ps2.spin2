{
    ZX Spectrum 48K Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Based on ZiKore Z80 Emulator by Ada Gottenstr√§ter
    with modifications by Marco Maccaferri

    PS/2 Keyboard driver by Marco Maccaferri
}
CON

    _CLKFREQ = 240_000_000

    VIDEO    = VGA ' video mode VGA, NTSC or PAL
    VGA_PIN  = 48
    CVBS_PIN = 32 addpins 1 ' 32=CVBS/Y, 33=C

    PS2_DATA_PIN  = 47
    PS2_CLOCK_PIN = 46

    ZX_MIC        = 0   ' OUT
    ZX_EAR        = 1   ' IN

DAT             ' Startup
                org     $000

                asmclk
                drvl    #56
                drvl    #57

                mov     pa, ##48*1024/4
                mov     ptra, ##@z80_4000   ' initialize memory
.l1             wrlong  #0, ptra++
                djnz    pa, #.l1

                coginit #4, ##@video_driver ' start video on cog #4
                coginit #3, ##@ps2_driver   ' start PS/2 driver on cog #3

                waitx   ##_CLKFREQ          ' delay to allow monitor to settle
                coginit #0, ##@zk_cogbase   ' start Z80 on cog #0 (this)

                orgh

' Shared variables

zk_nmi_mem      long    0                   ' bit 8 = NMI
zk_irq_mem      long    0                   ' bit 8 = IRQ, 7..0 vector

zx_border       byte    $00                 ' screen border

                                            ' ROW  D4 D3 D2 D1 D0
zx_keys         byte    $FF[8]              '  0   V  C  X  Z  CS
                                            '  1   G  F  D  S  A
                                            '  2   T  R  E  W  Q
                                            '  3   5  4  3  2  1
                                            '  4   6  7  8  9  0
                                            '  5   Y  U  I  O  P
                                            '  6   H  J  K  L  ENTER
                                            '  7   B  N  M  SS SPACE

DAT             ' PS/2 Keyboard driver
                org     $000

ps2_driver
                fltl    #PS2_DATA_PIN
                fltl    #PS2_CLOCK_PIN

                mov     ps2_data, #$F3      ' auto-repeat
                call    #ps2_transmit
                and     ps2_data, #%011_11111 ' slow 1s / 2cps
                call    #ps2_transmit

                mov     ps2_state, #%0_000  ' turn off all leds
                jmp     #ps2_locks

ps2_reset
                setq    #2-1
                wrlong  zx_keys, #@zx_keys

ps2_loop        and     ps2_state, #$07     ' keep locks state

.l1             call    #ps2_receive
                getbyte ps2_code, ps2_data, #0

                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #.l1

                cmp     ps2_data, #$E0  wz
        if_z    bith    ps2_state, #28
        if_z    jmp     #ps2_ext0
                cmp     ps2_data, #$E1  wz
        if_z    bith    ps2_state, #29
        if_z    jmp     #ps2_ext1

ps2_ext_ret     testbn  ps2_state, #29  wz
        if_nz   jmp     #ps2_loop           ' E1 codes are ignored

                testb   ps2_state, #7   wc  ' release

                cmp     ps2_code, #$14  wz  ' left control
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_CTRL

                cmp     ps2_code, #$14  wz  ' right control
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_CTRL

                cmp     ps2_code, #$12  wz  ' left shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_SHIFT
                cmp     ps2_data, #$59  wz  ' right shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_SHIFT

                cmp     ps2_code, #$11  wz  ' left alt
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_ALT

                cmp     ps2_code, #$11  wz  ' right alt
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_ALT

                cmp     ps2_code, #$1F  wz  ' left gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_GUI
                cmp     ps2_code, #$27  wz  ' right gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_GUI

                cmp     ps2_code, #$77  wz  ' num. lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #0       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$58  wz  ' caps lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #1       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$7E  wz  ' scroll lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #2       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds

                test    ps2_shift, #LEFT_GUI  wz ' check reset key combination
        if_nz   test    ps2_shift, #RIGHT_GUI wz ' |
        if_nz   andn    ps2_shift, #LEFT_GUI|RIGHT_GUI
        if_nz   jmp     #sys_reset               ' jump to system reset

                testb   ps2_state, #28  wc      ' extended code
                rcl     ps2_code, #1            '   to bit 0
                altgb   ps2_code, #ps2_table    ' get usb scancode
                getbyte ps2_key, 0-0, #0        ' |

                cmp     ps2_key, #$00   wz      ' no key associated
        if_z    jmp     #ps2_loop

                mov     ptra, #@zx_keys
                testb   ps2_state, #7   wc      ' release

                cmp     ps2_code, #($66<<1)|0   wz ' BS
        if_nz   cmp     ps2_code, #($6B<<1)|1   wz ' LEFT
        if_nz   cmp     ps2_code, #($74<<1)|1   wz ' RIGHT
        if_nz   cmp     ps2_code, #($75<<1)|1   wz ' UP
        if_nz   cmp     ps2_code, #($72<<1)|1   wz ' DOWN
        if_z    call    #c_shift

                cmp     ps2_code, #($41<<1)|0   wz ' ,
        if_nz   cmp     ps2_code, #($49<<1)|0   wz ' .
        if_z    call    #s_shift

                mov     ps2_data, ps2_key
                shr     ps2_data, #5
                add     ptra, ps2_data
                rdbyte  ps2_temp, ptra
                and     ps2_key, #%11111
                muxc    ps2_temp, ps2_key
                wrbyte  ps2_temp, ptra
                jmp     #ps2_loop

c_shift         rdbyte  ps2_temp, ptra[%000]
                muxc    ps2_temp, #%00001
        _ret_   wrbyte  ps2_temp, ptra[%000]

s_shift         rdbyte  ps2_temp, ptra[%111]
                muxc    ps2_temp, #%00010
        _ret_   wrbyte  ps2_temp, ptra[%111]

ps2_locks       mov     ps2_data, #$ED
                call    #ps2_transmit
                mov     ps2_data, #0
                testb   ps2_state, #0   wz  ' num. lock
                bitz    ps2_data, #1
                testb   ps2_state, #1   wz  ' caps lock
                bitz    ps2_data, #2
                testb   ps2_state, #2   wz  ' scroll lock
                bitz    ps2_data, #0
                call    #ps2_transmit
                jmp     #ps2_loop

ps2_ext1        call    #ps2_receive
                setbyte ps2_code, ps2_data, #1
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext1

                ' fall through

ps2_ext0        call    #ps2_receive
                setbyte ps2_code, ps2_data, #0
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext0

                jmp     #ps2_ext_ret

ps2_transmit    drvl    #PS2_CLOCK_PIN      ' pull clock low
                getct   ps2_tout            ' hold clock for 128us (must be > 100us)
                addct1  ps2_tout, ps2_us128 ' |
                jnct1   #$
                drvl    #PS2_DATA_PIN       ' pull data low
                getct   ps2_tout            ' hold data for 4us
                addct1  ps2_tout, ps2_us4   ' |
                jnct1   #$

                fltl    #PS2_CLOCK_PIN      ' release clock
                getct   ps2_tout            ' allow pin to float
                addct1  ps2_tout, ps2_us1   ' |
                jnct1   #$

                test    ps2_data, #$FF  wc  ' append parity
                muxnc   ps2_data, #$100     ' |
                bith    ps2_data, #9        ' append stop bit

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #10
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                shr     ps2_data, #1    wc  ' output data bit
                drvc    #PS2_DATA_PIN       ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit ?

                fltl    #PS2_DATA_PIN

.l3             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data low
        if_z    testpn  #PS2_DATA_PIN   wz  ' |
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l3                ' |

.l4             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data high
        if_nz   testpn  #PS2_DATA_PIN   wz  ' |
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l4                ' |

                ' Fall through to receive ack

ps2_receive     testpn  #PS2_CLOCK_PIN  wz  ' wait initial clock low
        if_nz   jmp     #ps2_receive        ' |

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #11
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                testp   #PS2_DATA_PIN   wc  ' sample data
                rcr     ps2_data, #1        ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit?

                shr     ps2_data, #22       ' align byte
                test    ps2_data, #$1FF wc  ' test parity
        if_nc   jmp     #ps2_reset          ' |
        _ret_   and     ps2_data, #$FF      ' ok

sys_reset
                cogstop #0                  ' stop Z80

                mov     pa, ##48*1024/4
                mov     ptra, ##@z80_4000   ' initialize memory
.l1             wrlong  #0, ptra++          '   0 if user reset
                djnz    pa, #.l1

                coginit #0, ##@zk_cogbase   ' start Z80 on cog #0
                jmp     #ps2_loop

ps2_us1         long    _CLKFREQ / 1000_000 * 1     ' 1 usec.
ps2_us4         long    _CLKFREQ / 1000_000 * 4     ' 4 usec.
ps2_us128       long    _CLKFREQ / 1000_000 * 128   ' 128 usec.
ps2_us2000      long    _CLKFREQ / 1000_000 * 4000  ' 2000 usec.

ps2_bits        long    0
ps2_code        long    0
ps2_state       long    0
ps2_shift       long    0
ps2_key         long    0

ps2_data        long    0
ps2_tout        long    0
ps2_temp        long    0

ps2_table       byte                    0,                 0  '00
                byte                    0,                 0  '01    F9
                byte                    0,                 0  '02
                byte                    0,                 0  '03    F5
                byte                    0,                 0  '04    F3
                byte                    0,                 0  '05    F1
                byte                    0,                 0  '06    F2
                byte                    0,                 0  '07    F12
                byte                    0,                 0  '08
                byte                    0,                 0  '09    F10
                byte                    0,                 0  '0A    F8
                byte                    0,                 0  '0B    F6
                byte                    0,                 0  '0C    F4
                byte                    0,                 0  '0D    Tab
                byte                    0,                 0  '0E    `
                byte                    0,                 0  '0F
                byte                    0,                 0  '10
                byte                    0,                 0  '11    Alt-L     Alt-R
                byte    (0 << 5) | %00001,                 0  '12    Shift-L
                byte                    0,                 0  '13
                byte    (7 << 5) | %00010, (7 << 5) | %00010  '14    Ctrl-L    Ctrl-R
                byte    (2 << 5) | %00001,                 0  '15    q
                byte    (3 << 5) | %00001,                 0  '16    1
                byte                    0,                 0  '17
                byte                    0,                 0  '18
                byte                    0,                 0  '19
                byte    (0 << 5) | %00010,                 0  '1A    z
                byte    (1 << 5) | %00010,                 0  '1B    s
                byte    (1 << 5) | %00001,                 0  '1C    a
                byte    (2 << 5) | %00010,                 0  '1D    w
                byte    (3 << 5) | %00010,                 0  '1E    2
                byte                    0,                 0  '1F              Win-L
                byte                    0,                 0  '20
                byte    (0 << 5) | %01000,                 0  '21    c
                byte    (0 << 5) | %00100,                 0  '22    x
                byte    (1 << 5) | %00100,                 0  '23    d
                byte    (2 << 5) | %00100,                 0  '24    e
                byte    (3 << 5) | %01000,                 0  '25    4
                byte    (3 << 5) | %00100,                 0  '26    3
                byte                    0,                 0  '27              Win-R
                byte                    0,                 0  '28
                byte    (7 << 5) | %00001,                 0  '29    Space
                byte    (0 << 5) | %10000,                 0  '2A    v
                byte    (1 << 5) | %01000,                 0  '2B    f
                byte    (2 << 5) | %10000,                 0  '2C    t
                byte    (2 << 5) | %01000,                 0  '2D    r
                byte    (3 << 5) | %10000,                 0  '2E    5
                byte                    0,                 0  '2F              Apps
                byte                    0,                 0  '30
                byte    (7 << 5) | %01000,                 0  '31    n
                byte    (7 << 5) | %10000,                 0  '32    b
                byte    (6 << 5) | %10000,                 0  '33    h
                byte    (1 << 5) | %10000,                 0  '34    g
                byte    (5 << 5) | %10000,                 0  '35    y
                byte    (4 << 5) | %10000,                 0  '36    6
                byte                    0,                 0  '37              Power
                byte                    0,                 0  '38
                byte                    0,                 0  '39
                byte    (7 << 5) | %00100,                 0  '3A    m
                byte    (6 << 5) | %01000,                 0  '3B    j
                byte    (5 << 5) | %01000,                 0  '3C    u
                byte    (4 << 5) | %01000,                 0  '3D    7
                byte    (4 << 5) | %00100,                 0  '3E    8
                byte                    0,                 0  '3F              Sleep
                byte                    0,                 0  '40
                byte    (7 << 5) | %01000,                 0  '41    ,
                byte    (6 << 5) | %00100,                 0  '42    k
                byte    (5 << 5) | %00100,                 0  '43    i
                byte    (5 << 5) | %00010,                 0  '44    o
                byte    (4 << 5) | %00001,                 0  '45    0
                byte    (4 << 5) | %00010,                 0  '46    9
                byte                    0,                 0  '47
                byte                    0,                 0  '48
                byte    (7 << 5) | %00100,                 0  '49    .
                byte                    0,                 0  '4A    /         (/)
                byte    (6 << 5) | %00010,                 0  '4B    l
                byte                    0,                 0  '4C    ;
                byte    (5 << 5) | %00001,                 0  '4D    p
                byte                    0,                 0  '4E    -
                byte                    0,                 0  '4F
                byte                    0,                 0  '50
                byte                    0,                 0  '51
                byte                    0,                 0  '52    '
                byte                    0,                 0  '53
                byte                    0,                 0  '54    [
                byte                    0,                 0  '55    =
                byte                    0,                 0  '56
                byte                    0,                 0  '57
                byte                    0,                 0  '58    CapsLock
                byte    (0 << 5) | %00001,                 0  '59    Shift-R
                byte    (6 << 5) | %00001, (6 << 5) | %00001  '5A    Enter     (Enter)
                byte                    0,                 0  '5B    ]
                byte                    0,                 0  '5C
                byte                    0,                 0  '5D    \
                byte                    0,                 0  '5E              WakeUp
                byte                    0,                 0  '5F
                byte                    0,                 0  '60
                byte                    0,                 0  '61
                byte                    0,                 0  '62
                byte                    0,                 0  '63
                byte                    0,                 0  '64
                byte                    0,                 0  '65
                byte    (4 << 5) | %00001,                 0  '66    BackSpace
                byte                    0,                 0  '67
                byte                    0,                 0  '68
                byte                    0,                 0  '69    (1)       End
                byte                    0,                 0  '6A
                byte                    0, (3 << 5) | %10000  '6B    (4)       Left
                byte                    0,                 0  '6C    (7)       Home
                byte                    0,                 0  '6D
                byte                    0,                 0  '6E
                byte                    0,                 0  '6F
                byte                    0,                 0  '70    (0)       Insert
                byte                    0,                 0  '71    (.)       Delete
                byte                    0, (4 << 5) | %10000  '72    (2)       Down
                byte                    0,                 0  '73    (5)
                byte                    0, (4 << 5) | %00100  '74    (6)       Right
                byte                    0, (4 << 5) | %01000  '75    (8)       Up
                byte                    0,                 0  '76    Esc
                byte                    0,                 0  '77    NumLock
                byte                    0,                 0  '78    F11
                byte                    0,                 0  '79    (+)
                byte                    0,                 0  '7A    (3)       PageDn
                byte                    0,                 0  '7B    (-)
                byte                    0,                 0  '7C    (*)       PrScr
                byte                    0,                 0  '7D    (9)       PageUp
                byte                    0,                 0  '7E    ScrLock
                byte                    0,                 0  '7F
                byte                    0,                 0  '80
                byte                    0,                 0  '81
                byte                    0,                 0  '82
                byte                    0,                 0  '83    F7

                fit     $1F0

CON

    LEFT_CTRL   = %0000_0001
    LEFT_SHIFT  = %0000_0010
    LEFT_ALT    = %0000_0100
    LEFT_GUI    = %0000_1000
    RIGHT_CTRL  = %0001_0000
    RIGHT_SHIFT = %0010_0000
    RIGHT_ALT   = %0100_0000
    RIGHT_GUI   = %1000_0000

DAT             ' ZiKore Z80 COG resident code
                org     $000

zk_cogbase
                add     ptrb, ##@zk_lutbase - @zk_cogbase
                setq2   #511
                rdlong  0, ptrb

                waitatn ' sync with video
                waitatn ' |
                getct   zk_lastwait

zk_nextop
                call    #\zx_ula_advance
                mov     ula_state_done, #0
                subs    ula_cnt, zk_cycles

                mul     zk_cycles, zk_cycletime
                addct1  zk_lastwait, zk_cycles
                waitct1

                mov     zk_cycles, #0

                testb   zk_nmi_ctl, #8      wc  ' C = old NMI
                rdlong  zk_nmi_ctl, #@zk_nmi_mem
                testb   zk_nmi_ctl, #8      wz  ' Z = current NMI
        if_01   jmp     #\zk_donmi              ' jump if 0 -> 1 transition

                cmps    ula_cnt, #0         wcz ' simulated interrupt
        if_a    jmp     #.skip
                add     ula_cnt, ##(VIDEO == PAL ? (224*312) : (224*264))
                waitatn                         ' we are slightly faster than video, wait
                getct   zk_lastwait             ' update clock reference

                testb   zk_irqenable,#ZK_IFF1_BIT wz   ' Z = EI
        if_x1   mov     ptra, ##@z80_4000
        if_x1   mov     ptrb, ##@z80_4000+32*192
        if_x1   jmp     #\zk_doirq                     ' jump if Z=1
.skip

                mov     zk_temphl, zk_hl
                mov     zk_hlptr, #zk_hl
                mov     zk_tempidx, zk_hl
                mov     zk_prefix, #0
                incmod  zk_refresh, #127

                call    #zk_readcode
                add     zk_cycles, #1
                mov     zk_opcode, zk_tmp8
                'debug(uhex_byte(zk_opcode))
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                'debug(uhex_long(zk_opimpl))
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
                push    #zk_nextop
                execf   zk_opimpl

zk_iyprefix
                mov     zk_hlptr, #zk_iy
zk_ixprefix
                mov     zk_hlptr, #zk_ix

                mov     zk_prefix, zk_opcode
                incmod  zk_refresh, #127
                add     zk_cycles, #1

                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                shl     zk_tmp8, #2
                add     zk_tmp8, ##@zk_optable
                rdlong  zk_opimpl, zk_tmp8
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc   jmp     #.nodisplace
                ' handle index displacement
                mov     zk_temphl, zk_hl
                alts    zk_hlptr
                mov     zk_tempidx, 0-0
                mov     zk_hlptr, #zk_hl
                call    #zk_readcode
                signx   zk_tmp8, #7
                add     zk_tempidx, zk_tmp8
                execf   zk_opimpl

.nodisplace
                alts    zk_hlptr
                mov     zk_temphl, 0-0
                mov     zk_tempidx, zk_temphl
                execf   zk_opimpl

zk_bitprefix
                call    #\zk_readcode
                mov     zk_opcode, zk_tmp8
                add     zk_cycles, #1
                incmod  zk_refresh, #127

                cmp     zk_prefix, #0 wz
        if_z    call    #zk_getrz
        if_nz   call    #zk_read8hl

                mov     pa, zk_opcode
                shr     pa, #3
                and     pa, #7

                testb   zk_opcode, #7 wc
                testb   zk_opcode, #6 wz
        if_00   jmp     #.shift
        if_01   jmp     #.bit
                bitz    zk_tmp8, pa
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix, #0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

.bit
                decod   pa
                and     pa, zk_tmp8 wz
                muxz    zk_flags, #(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
                bitl    zk_flags, #ZK_NMODE_BIT
                bith    zk_flags, #ZK_HALF_BIT
                setq    #1<<ZK_SIGN_BIT
                muxq    zk_flags, pa
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags, zk_tmp8

.shift
                push    #.shiftdone
                altd    pa, #zk_shift_impl_tbl
                execf   0-0

.shiftdone
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix,#0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

zk_shift_impl_tbl
                long    zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
                long    zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
                long    zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
                long    zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
                long    zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
                long    zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
                long    zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
                long    zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL

zk_extprefix
                call #\zk_readcode
                mov zk_opcode,zk_tmp8
                add zk_cycles,#1
                incmod zk_refresh,#127
                'debug("extend ",uhex_byte(zk_opcode))

                cmp zk_opcode,#$A0 wc
        if_ae   jmp #.blockop
                cmp zk_opcode,#$40 wc
        if_b    ret

                mov pa,zk_opcode
                and pa,#7
                altd pa,#zk_ext_impl_tbl
                execf 0-0

.blockop
                '' The undocumented flags on these are cursed.
                test    zk_opcode,#%0100_0100 wz
        if_nz   ret     ' NOP
                rczr    zk_opcode wcz ' get operation type into cz
        if_00   add     zk_cycles,#2
        if_01   add     zk_cycles,#5
        if_1x   add     zk_cycles,#1
        if_00   skipf   ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01   skipf   ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10   skipf   ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11   skipf   ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

                getword zk_ea,zk_debc,#0 ' IN
                call    #\zk_portin ' IN
                call    #\zk_read8hl ' everything else

                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
                bith    zk_flags,#ZK_NMODE_BIT ' CP
                testb   zk_tmp8,#7 wc ' IN/OUT
                bitc    zk_flags,#ZK_NMODE_BIT ' IN/OUT

                mov     zk_optmp0,zk_accu ' LD CP
                getbyte zk_optmp0,zk_hl,#0 ' OUT
                getbyte zk_optmp0,zk_debc,#0 ' IN
                testb   zk_opcode,#1 wc ' IN
                sumc    zk_optmp0,#1 ' IN
                mov     zk_optmp1,zk_tmp8 ' CP
                xor     zk_optmp1,zk_optmp0 ' CP

                sub     zk_optmp0,zk_tmp8 ' CP only
                add     zk_optmp0,zk_tmp8 ' LD,IN,OUT

                xor     zk_optmp1,zk_optmp0 ' CP
                and     zk_optmp0,#255 wz ' CP,IN,OUT
                bitz    zk_flags,#ZK_ZERO_BIT ' CP
                testb   zk_optmp0,#7 wc ' CP
                bitc    zk_flags,#ZK_SIGN_BIT ' CP

                testb   zk_optmp1,#4 wc   ' CP
                cmpr    zk_optmp0,#255 wc  ' IN/OUT
                bitc    zk_flags,#ZK_HALF_BIT ' CP
                muxc    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c    sub     zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

                skipf   ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
                skipf   ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
                skipf   ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
                skipf   ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


                testb   zk_optmp0,#1 wc ' LD,CP
                bitc    zk_flags,#5 'LD,CP (sets YF)
                testb   zk_optmp0,#3 wc ' LD,CP
                bitc    zk_flags,#3 'LD,CP (sets XF)

                getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
                and     zk_optmp0,#7 ' IN,OUT
                xor     zk_optmp0,zk_optmp1 wc ' IN,OUT
                bitnc   zk_flags,#ZK_OVER_BIT ' IN,OUT

                mov     zk_ea,zk_hl  ' IN
                getword zk_ea,zk_debc,#1 ' LD
                call    #\zk_write8 ' LD,IN
                getword zk_ea,zk_debc,#0 ' OUT
                call    #\zk_portout ' OUT

                getword zk_optmp1,zk_debc,#0 ' LD,CP
                decmod  zk_optmp1,zk_ffffh wz ' all
                setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
                setword zk_debc,zk_optmp1,#0 ' LD,CP
                bitnz   zk_flags,#ZK_OVER_BIT ' LD,CP
                bitz    zk_flags,#ZK_ZERO_BIT ' IN,OUT
                setq    #ZK_SIGNXYMASK ' IN,OUT
                muxq    zk_flags,zk_optmp1 ' IN,OUT

                testb   zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
                testb   zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc   incmod  zk_ea,zk_ffffh    ' LD
        if_c    decmod  zk_ea,zk_ffffh    ' LD
                setword zk_debc,zk_ea,#1 ' LD

        if_nc   incmod  zk_hl,zk_ffffh
        if_c    decmod  zk_hl,zk_ffffh

                testb   zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz    sub     zk_pc,#2
 if_c_and_nz    add     zk_cycles,#5
                'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
                ret

zk_ext_impl_tbl
                long    zk_cio + (%10_11_111_000000<<10) ' IN [BCDEHL0A],(C)
                long    zk_cio + (%00_01_111_000000<<10) ' OUT (C),[BCDEHL0A]
                long    zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
                long    zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
                long    zk_neg
                long    zk_irqret
                long    zk_imode
                long    zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7

                altd    pa,#zk_extmath16_impl_tbl
                altd    pa,#zk_extld16_impl_tbl
                altd    pa,#zk_extmisc_impl_tbl

                execf   0-0

zk_extmath16_impl_tbl
                long    zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
                long    zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
                long    zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
                long    zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
                long    zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
                long    zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
                long    zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
                long    zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
                long    zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
                long    zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
                long    zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
                long    zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
                long    zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
                long    zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
                long    zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
                long    zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
                long    zk_a2i                       ' LD I,A
                long    zk_a2r                       ' LD R,A
                long    zk_i2a                       ' LD A,I
                long    zk_r2a  + (%1_000<<10)       ' LD A,R
                long    zk_rxd + (%000_111_00<<10)   ' RRD
                long    zk_rxd + (%111_000_00<<10)   ' RLD
                long    zk_nextop                    ' NOP
                long    zk_nextop                    ' NOP

zk_rxd
                call    #\zk_read8hl
                add     zk_cycles,#4
                ' RLD
                rolnib  zk_tmp8,zk_accu,#0
                getnib  pa,zk_tmp8,#2
                setnib  zk_tmp8,#0,#2
                ' RRD
                setnib  zk_tmp8,zk_accu,#2
                getnib  pa,zk_tmp8,#0
                shr     zk_tmp8,#4

                setnib  zk_accu,pa,#0
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_accu
                jmp     #\zk_write8hl

zk_a2r
                mov     zk_refresh,zk_accu
                and     zk_refresh,#$7F
        _ret_   mov     zk_refreshhi,zk_accu

zk_a2i
        _ret_   mov     zk_ivector,zk_accu

zk_r2a
                mov     zk_accu,zk_refresh
                setq    #$80
                muxq    zk_accu,zk_refreshhi
zk_i2a
                mov     zk_accu,zk_ivector

                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_irqret       '' RETI/RETN
                '' These are literally the same
                testb   zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_irqenable,#ZK_IFF1_BIT
                call    #\zk_pop16
        _ret_   mov     zk_pc,zk_tmp16


zk_imode
                cmp     zk_opcode,#$5E  wz
        if_nz   cmp     zk_opcode,#$7E  wz
                bitz    zk_irqenable,#ZK_IM2_BIT
                ret

zk_irqoff
        _ret_   andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_irqon
        _ret_   or      zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_doirq
                add     zk_cycles,#1
                test    zk_irqenable,#(1<<ZK_IM2_BIT)  wz
        if_z    skipf   ##%0_1_1111_0_0001000_1111
        if_nz   skipf   ##%0_1_0000_1_0001000_11

zk_donmi
                skipf   ##%0_0_1111_1_0010000

                add     zk_cycles,#5
                test    zk_irqenable,#(1<<ZK_HALT_BIT)  wz
        if_nz   incmod  zk_pc,zk_ffffh
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_HALT_BIT) ' NMI
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)|(1<<ZK_HALT_BIT) ' IRQ
                mov     zk_tmp16,zk_pc
                call    #\zk_push16

                mov     zk_pc,#$38 ' IM1/IM0

                getbyte zk_ea, zk_irq_ctl, #0 ' IM2
                setbyte zk_ea, zk_ivector, #1 ' IM2
                call    #\zk_read16 ' IM2
                mov     zk_pc, zk_tmp16 ' IM2

                mov     zk_pc,#$66 ' NMI

                jmp     #\zk_nextop

zk_jump_indir
        _ret_   mov     zk_pc,zk_temphl
zk_hl_to_sp
                add     zk_cycles,#2
        _ret_   mov     zk_sp,zk_temphl

zk_jump
                call    #\zk_readcode16
zk_condret
                add     zk_cycles,#1 ' Extra cycle in conditional RET

                testb   zk_flags,#ZK_ZERO_BIT wc
                testb   zk_flags,#ZK_CARRY_BIT wc
                testb   zk_flags,#ZK_OVER_BIT wc
                testb   zk_flags,#ZK_SIGN_BIT wc

                modc    _nc wc
        if_c    call    #\zk_nextop
zk_ret
                call    #zk_pop16
                mov     zk_optmp0,zk_tmp16 ' For every op!
zk_rst
                mov     zk_optmp0,zk_opcode
                and     zk_optmp0,#%00111000
zk_pushjmp
                mov     zk_tmp16,zk_pc
                mov     zk_pc,zk_optmp0
                jmp     #\zk_push16
                ret

zk_getrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                'debug("in zk_getrz ",uhex_byte(pa))
                add     pa,#zk_getrpa-$-1
                jmprel  pa
zk_getry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
zk_getrpa
                jmprel  pa
        _ret_   getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_   getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_   getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_   getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_   getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_   getbyte zk_tmp8,zk_temphl,#0 ' L register
                jmp     #zk_read8hl              ' (HL)
        _ret_   getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                add     pa,#zk_setrpa-$-1
                jmprel  pa
zk_setry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
                'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa       jmprel  pa
        _ret_   setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_   setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_   setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_   setbyte zk_debc,zk_tmp8,#2   ' E register
                jmp     #.seth                   ' H register
                jmp     #.setl                   ' L register
                jmp     #zk_write8hl             ' (HL)
        _ret_   setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
                setbyte zk_temphl,zk_tmp8,#1
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl
.setl
                setbyte zk_temphl,zk_tmp8,#0
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_push16
                add     zk_cycles,#1
                sub     zk_sp,#2
                setword zk_sp,#0,#1
                mov     zk_ea,zk_sp
                jmp     #zk_write16
zk_pop16
                mov     zk_ea,zk_sp
                add     zk_sp,#2
                setword zk_sp,#0,#1
                jmp     #zk_read16

zk_read16hl
                getword zk_ea,zk_tempidx,#0
zk_read16
                call    #zk_read8
                getbyte zk_tmp16,zk_tmp8,#0
                add     zk_ea,#1
                call    #zk_read8
                setbyte zk_tmp16,zk_tmp8,#1
        _ret_   sub     zk_ea,#1

zk_read8hl
                getword zk_ea,zk_tempidx,#0
                jmp     #zk_read8
zk_readcode
                mov     zk_ea,zk_pc
                incmod  zk_pc,zk_ffffh
                'setword zk_pc,#0,#1
                ' fall through
zk_read8
                call    #\ula_contend_ram
                getword pa, zk_ea, #0
                add     pa, zk_ram
                rdbyte  zk_tmp8, pa
                ret     wcz

zk_readcode16
                call    #zk_readcode
                getbyte zk_tmp16,zk_tmp8,#0
                call    #zk_readcode
        _ret_   setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
                getword zk_ea,zk_tempidx,#0
zk_write16
                getbyte zk_tmp8,zk_tmp16,#0
                call    #zk_write8
                add     zk_ea,#1
                getbyte zk_tmp8,zk_tmp16,#1
                call    #zk_write8
        _ret_   sub     zk_ea,#1

zk_write8hl
                getword zk_ea,zk_tempidx,#0
zk_write8
                getword pa, zk_ea, #0
                cmp     pa, ##$4000     wcz
        if_ae   add     pa, zk_ram
        if_ae   wrbyte  zk_tmp8, pa
                call    #\ula_contend_ram
                ret     wcz

zk_portout
                ' zk_ea   = port
                ' zk_tmp8 = data
                testb   zk_ea, #0       wz  ' Z=A0
        if_x0   call    #\zx_ula_write
                call    #\ula_contend_port
                ret     wcz

zk_portin
                ' zk_ea   = port
                ' zk_tmp8 = data
                mov     zk_tmp8, #$FF
                call    #\ula_contend_port
                testb   zk_ea, #0       wz  ' Z=A0
        if_x0   jmp     #\zx_ula_read
                ret     wcz

zk_ffffh        long    $FFFF
zk_18000h       long    $18000
zk_bit31        long    negx

zk_cycles       long    5
zk_pc           long    $0000

zk_flags        long    0
zk_accu         long    0
zk_debc         long    0
zk_sp           long    $F000
zk_hl           long    0
zk_ix           long    0
zk_iy           long    0
zk_altflags     long    0
zk_altaccu      long    0
zk_altdebc      long    0
zk_althl        long    0
zk_refresh      long    0
zk_refreshhi    long    0
zk_ivector      long    0
zk_irqenable    long    0

zk_ram          long    @z80_0000

ula_cnt         long    (VIDEO == PAL ? (224*312) : (224*264))
ula_state       long    -(VIDEO == PAL ? (224*64) : (224*40))+1
ula_state_done  long    0

ula_blocks      long    3
ula_rows        long    8
ula_scans       long    8
ula_col         long    0

ula_cycles      long    0

zk_cycletime    long    _CLKFREQ / ZK_CLOCK ' round(float(_CLKFREQ) / float(ZK_CLOCK) * 256.0)

zk_lastwait     res     1

zk_opcode       res     1
zk_opimpl       res     1
zk_prefix       res     1
zk_temphl       res     1
zk_tempidx      res     1
zk_hlptr        res     1
zk_tmp16        res     1

zk_optmp0       res     1
zk_optmp1       res     1

zk_tmp0         res     1
zk_tmp8         res     1 ' memory read/write value
zk_ea           res     1 ' remapped EA
zk_irq_ctl      res     1
zk_nmi_ctl      res     1

                fit     $1F0

DAT             ' ZiKore Z80 LUT resident code
                org     $200
zk_lutbase

zk_rolla        mov     zk_tmp8,zk_accu
zk_shiftop
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

                bitl    zk_tmp8,#7 wcz  ' left + SRA
                bitz    zk_tmp8,#7 addbits 1 ' only SRA
                bitl    zk_tmp8,#0 wcz  ' right
                modc    _set wc ' only SLL
                modc    _clr wc ' only SLA

                testb   zk_flags,#ZK_CARRY_BIT wc' only RL/RR
                bitz    zk_flags,#ZK_CARRY_BIT

                rcl     zk_tmp8,#1 wz   ' left
                bitc    zk_tmp8,#8     ' right (not SRA/SRL)
                shr     zk_tmp8,#1 wz   ' right

                setq    #ZK_XYMASK
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

        _ret_   mov     zk_accu,zk_tmp8

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_tmp8,#$FF wc
        _ret_   bitnc   zk_flags,#ZK_OVER_BIT

zk_cio
                mov     zk_optmp1,zk_opcode
                and     zk_optmp1,#7<<3
                cmp     zk_optmp1,#6<<3 wz
                mov     zk_tmp8,#0
        if_nz   call    #\zk_getry
                getword zk_ea,zk_debc,#0
zk_immio
                call    #\zk_readcode
                mov     zk_ea,zk_tmp8
                setbyte zk_ea,zk_accu,#1

                mov     zk_tmp8,zk_accu
                jmp     #\zk_portout

                call    #\zk_portin
        _ret_   mov     zk_accu,zk_tmp8

                and     zk_tmp8,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

                cmp     zk_optmp1,#6<<3 wz
        if_z    ret
                jmp     #\zk_setry

zk_incdec8
                call    #\zk_getry
                mov     zk_optmp0,#1
zk_math8
                call    #\zk_getrz
zk_immmath
                call    #\zk_readcode
                mov     zk_optmp0,zk_tmp8
                mov     zk_tmp8,zk_accu

                modc    _clr wc
                testb   zk_flags,#ZK_CARRY_BIT wc

                ' Flag helper gunk
                mov     zk_optmp1,zk_tmp8

                addx    zk_tmp8,zk_optmp0
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_tmp8,zk_optmp0
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_tmp8
                test    zk_tmp8,#$100 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                and     zk_tmp8,#255 wz

                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8
                ' Special nonsense for CP
                setq    #ZK_XYMASK
                muxq    zk_flags,zk_optmp0

                mov     zk_accu,zk_tmp8
                call    #\zk_setry

                xor     zk_optmp1,zk_optmp0
                bitz    zk_flags,#ZK_ZERO_BIT
                testb   zk_optmp1,#4 wc
                bitc    zk_flags,#ZK_HALF_BIT
                test    zk_optmp1,#$180 wc
        _ret_   bitc    zk_flags,#ZK_OVER_BIT

zk_neg
                cmp     zk_accu,#$80 wz
                bitz    zk_flags,#ZK_OVER_BIT
                testb   zk_accu,#4 wz
                subr    zk_accu,#0 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                testb   zk_accu,#4 xorz
                bitz    zk_flags,#ZK_HALF_BIT
                and     zk_accu,#$FF wz
                bitz    zk_flags,#ZK_ZERO_BIT
                bith    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu


zk_cpl
                xor     zk_accu,#$FF
                or      zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_math16
                modc    _clr wc
zk_cmath16
                testb   zk_flags,#ZK_CARRY_BIT wc

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                mov     zk_optmp1,zk_temphl
                xor     zk_optmp1,zk_tmp16

                addx    zk_temphl,zk_tmp16
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_temphl,zk_tmp16
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_temphl
                and     zk_temphl,zk_ffffh wz

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_optmp1,zk_18000h wc
                bitc    zk_flags,#ZK_OVER_BIT

                getbyte pa,zk_temphl,#1
                setq    #ZK_SIGNXYMASK
                setq    #ZK_XYMASK
                muxq    zk_flags,pa

                testb   zk_optmp1,#12 wc
                bitc    zk_flags,#ZK_HALF_BIT
                testb   zk_optmp1,#16 wc
                bitc    zk_flags,#ZK_CARRY_BIT

                add     zk_cycles,#7

                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_daa
                mov     zk_optmp0,#$00
                mov     zk_tmp8,zk_accu
                cmpr    zk_tmp8,#$99 wc
                testb   zk_flags,#ZK_CARRY_BIT orc
        if_c    add     zk_optmp0,#$60
                bitc    zk_flags,#ZK_CARRY_BIT
                getnib  zk_optmp1,zk_tmp8,#0
                cmpr    zk_optmp1,#$9 wc
                testb   zk_flags,#ZK_HALF_BIT orc
        if_c    add     zk_optmp0,#$06
                testb   zk_flags,#ZK_NMODE_BIT wc
                sumc    zk_accu,zk_optmp0
                and     zk_accu,#255 wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT ' Parity?
                testb   zk_accu,#4 wc
                testb   zk_tmp8,#4 xorc
                bitc    zk_flags,#ZK_HALF_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_immlogic
                call    #\zk_readcode
zk_logic
                call    #\zk_getrz

                and     zk_accu,zk_tmp8 wcz
                or      zk_accu,zk_tmp8 wcz
                xor     zk_accu,zk_tmp8 wcz

                bitnc   zk_flags,#ZK_OVER_BIT ' parity
                bitz    zk_flags,#ZK_ZERO_BIT
                andn    zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                bith    zk_flags,#ZK_HALF_BIT ' Only for AND
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_pushaf
                getbyte zk_tmp16,zk_accu,#0
                rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
                add     zk_cycles,#2
zk_pushbc       getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde       getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl       mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                jmp     #\zk_push16

                add     zk_tmp16,#1
                sub     zk_tmp16,#1

zk_loadimm16
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16   ' for LDs with (imm16)
                call    #\zk_read16     ' ^^
                jmp     #\zk_write16     ' ^^
zk_poppair
                call    #\zk_pop16

        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

                getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_   getbyte zk_flags,zk_tmp16,#0  ' set F

zk_jr           '' JR and DJNZ
                call    #\zk_readcode

                getbyte pa,zk_debc,#1
                sub     pa,#1 wz
                setbyte zk_debc,pa,#1
                add     zk_cycles,#1

                testb   zk_flags,#ZK_ZERO_BIT wz
                testb   zk_flags,#ZK_CARRY_BIT wz

                modz    _nz wz
        if_z    call    #\zk_nextop
                ' branch taken
                add     zk_cycles,#5
                signx   zk_tmp8,#7
        _ret_   add     zk_pc,zk_tmp8

zk_exx          '' EXX
                xor     zk_debc,zk_altdebc
                xor     zk_altdebc,zk_debc
                xor     zk_debc,zk_altdebc
                ' Note: not affected by IX/IY substitution
                xor     zk_hl,zk_althl
                xor     zk_althl,zk_hl
        _ret_   xor     zk_hl,zk_althl

zk_ex_dehl      '' EX DE,HL
                ' Note: not affected by IX/IY substitution
                getword zk_optmp0,zk_debc,#1
                setword zk_debc,zk_hl,#1
        _ret_   mov     zk_hl,zk_optmp0


zk_ex_hlstk     '' EX (SP),HL
                add     zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
                mov     zk_ea,zk_sp
                call    #\zk_read16
                altd    zk_hlptr
                mov     0-0,zk_tmp16
                mov     zk_tmp16,zk_temphl
                jmp     #\zk_write16

zk_ld_abs16     '' LD HL,(imm16) and LD (imm16),HL
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl ' get HL/I*
                mov     zk_tmp16,zk_sp ' get SP
                jmp     #\zk_write16

                call    #\zk_read16
        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   mov     zk_sp,zk_tmp16

zk_scf
                modc    _clr wc
zk_ccf
                testb   zk_flags,#ZK_CARRY_BIT wc
                bitnc   zk_flags,#ZK_CARRY_BIT
                bitc    zk_flags,#ZK_HALF_BIT
                bitl    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_ld_abs       '' LD A,(imm16) and LD (imm16),A
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16
zk_a_and_ptr    '' A and (BC)/(DE) ops
                getword zk_ea,zk_debc,#0 ' get BC
                getword zk_ea,zk_debc,#1 ' get DE
                call    #\zk_read8
        _ret_   mov     zk_accu,zk_tmp8
                mov     zk_tmp8,zk_accu
                jmp     #\zk_write8

zk_regmove
                push    #zk_setry
                jmp     #\zk_getrz

zk_loadimm8
                push    #zk_setry
                jmp     #\zk_readcode

zk_ex_af        '' EX AF,AF'
                xor     zk_accu,zk_altaccu
                xor     zk_altaccu,zk_accu
                xor     zk_accu,zk_altaccu
                xor     zk_flags,zk_altflags
                xor     zk_altflags,zk_flags
        _ret_   xor     zk_flags,zk_altflags

zk_halt
                or      zk_irqenable,#(1<<ZK_HALT_BIT)
        _ret_   decmod  zk_pc,zk_ffffh

ula_contend_ram
                testb   zk_ea, #15      wc  ' C=A15
                testb   zk_ea, #14      wz  ' Z=A14
        if_01   call    #\zx_ula_advance
        if_01   add     zk_cycles, ula_cycles
        _ret_   add     zk_cycles, #3

ula_contend_port
                testb   zk_ea, #15      wc  ' C=A15
                testb   zk_ea, #14      wz  ' Z=A14
        if_01   call    #\zx_ula_advance
        if_01   add     zk_cycles, ula_cycles
                add     zk_cycles, #1

                testb   zk_ea, #0       wz
                call    #\zx_ula_advance
        if_x0   add     zk_cycles, ula_cycles
        if_x0   add     zk_cycles, #3
        if_x0   ret

                testb   zk_ea, #15      wc  ' C=A15
                testb   zk_ea, #14      wz  ' Z=A14
        if_01   call    #\zx_ula_advance
        if_01   add     zk_cycles, ula_cycles
                add     zk_cycles, #1
        if_01   call    #\zx_ula_advance
        if_01   add     zk_cycles, ula_cycles
                add     zk_cycles, #1
        if_01   call    #\zx_ula_advance
        if_01   add     zk_cycles, ula_cycles
        _ret_   add     zk_cycles, #1

zx_ula_advance
                sub     ula_state, ula_state_done
                add     ula_state, zk_cycles
                mov     ula_state_done, zk_cycles

.l1             cmps    ula_state, #8   wcz
        if_ae   sub     ula_state, #8
        if_ae   add     ula_col, #2
        if_ae   add     ptra, #2
        if_ae   add     ptrb, #2
        if_ae   jmp     #.l1

                cmpsub  ula_col, #32    wc
        if_1x   sub     ula_state, #224-128
        if_1x   sub     ptra, #32
        if_1x   sub     ptrb, #32
        if_1x   sub     ula_scans, #1   wz
        if_10   add     ptra, #256
        if_11   sub     ptra, ##$700-32
        if_11   add     ptrb, #32
        if_11   mov     ula_scans, #8

        if_11   sub     ula_rows, #1    wz
        if_11   add     ptra, ##2048-256
        if_11   mov     ula_rows, #8

        if_11   sub     ula_blocks, #1  wz
        if_11   sub     ptra, ##32*192
        if_11   sub     ptrb, ##32*24
        if_11   mov     ula_blocks, #3
        if_11   sub     ula_state, ##(VIDEO == PAL ? (224*120) : (224*72))

                mov     ula_cycles, #6
                sub     ula_cycles, ula_state   wc
        if_c    mov     ula_cycles, #0

                cmp     ula_state, #1   wz
        if_z    rdbyte  zk_tmp8, ptra[0]
                cmp     ula_state, #2   wz
        if_z    rdbyte  zk_tmp8, ptrb[0]
                cmp     ula_state, #3   wz
        if_z    rdbyte  zk_tmp8, ptra[1]
                cmp     ula_state, #4   wz
        if_z    rdbyte  zk_tmp8, ptrb[1]

                ret     wcz

                fit     $400

DAT             ' ZiKore Z80 opcode table
                orgh

zk_optable      '' Opcode table
                long    zk_nextop                                           ' $00: NOP
                long    zk_loadimm16 + (%0000_1_111_0<<10)                  ' $01: LD BC,imm16
                long    zk_a_and_ptr + (%001110<<10)                        ' $02: LD (BC),A
                long    zk_incdec16+(%0000_1_1111_10_1_11100<<10)           ' $03: INC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $04: INC B
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $05: DEC B
                long    zk_loadimm8                                         ' $06: LD B,imm8
                long    zk_rolla+(%0_010_110_01_11110_00<<10)               ' $07: RLCA
                long    zk_ex_af                                            ' $08: EX AF,AF'
                long    zk_math16+(%0010_111_00_1100_00_1110_1_0<<10)       ' $09: ADD HL,BC
                long    zk_a_and_ptr + (%000010<<10)                        ' $0A: LD A,(BC)
                long    zk_incdec16+(%0000_1_1111_01_1_11100<<10)           ' $0B: DEC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $0C: INC C
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $0D: DEC C
                long    zk_loadimm8                                         ' $0E: LD C,imm8
                long    zk_rolla+(%0_010_001_01_11011_00<<10)               ' $0F: RRCA
                long    zk_jr + (%01_11_0000_0<<10)                         ' $10: DJNZ
                long    zk_loadimm16 + (%0001_1_111_0<<10)                  ' $11: LD DE,imm16
                long    zk_a_and_ptr + (%00110 <<10)+1                      ' $12: LD (DE),A
                long    zk_incdec16+(%0001_1_1111_10_1_11010<<10)           ' $13: INC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $14: INC D
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $15: DEC D
                long    zk_loadimm8                                         ' $16: LD D,imm8
                long    zk_rolla+(%0_010_110_00_11110_00<<10)               ' $17: RLA
                long    zk_jr + (%11_11_1111_0<<10)                         ' $18: JR
                long    zk_math16+(%0010_111_00_1100_00_1101_1_0<<10)       ' $19: ADD HL,DE
                long    zk_a_and_ptr + (%00000 <<10)+1                      ' $1A: LD A,(DE)
                long    zk_incdec16+(%0001_1_1111_01_1_11010<<10)           ' $1B: DEC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $1C: INC E
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $1D: DEC E
                long    zk_loadimm8                                         ' $1E: LD E,imm8
                long    zk_rolla+(%0_010_001_00_11011_00<<10)               ' $1F: RRA
                long    zk_jr + (%01_10_1111_0<<10)                         ' $20: JR NZ
                long    zk_loadimm16 + (%0011_1_111_0<<10)                  ' $21: LD HL,imm16
                long    zk_ld_abs16 + (%01011_00<<10)                       ' $22: LD (imm16),HL
                long    zk_incdec16+(%0011_1_1111_10_1_10110<<10)           ' $23: INC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $24: INC H
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $25: DEC H
                long    zk_loadimm8                                         ' $26: LD H,imm8
                long    zk_daa                                              ' $27: DAA
                long    zk_jr + (%00_10_1111_0<<10)                         ' $28: JR Z
                long    zk_math16+(%0010_111_00_1100_00_1011_1_0<<10)       ' $29: ADD HL,HL
                long    zk_ld_abs16 + (%00110_11111_00<<10)                 ' $2A: LD HL,(imm16)
                long    zk_incdec16+(%0011_1_1111_01_1_10110<<10)           ' $2B: DEC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $2C: INC L
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $2D: DEC L
                long    zk_loadimm8                                         ' $2E: LD L,imm8
                long    zk_cpl                                              ' $2F: CPL
                long    zk_jr + (%01_01_1111_0<<10)                         ' $30: JR NC
                long    zk_loadimm16 + (%0111_1_111_0<<10)                              ' $31: LD SP,imm16
                long    zk_ld_abs + (%001111_00<<10)                                    ' $32: LD (imm16),A
                long    zk_incdec16+(%0111_1_1111_10_1_01110<<10)                       ' $33: INC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP       ' $34: INC (HL)
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP       ' $35: DEC (HL)
                long    zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
                long    zk_scf + (%10 << 10)                 ' $37: SCF
                long    zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
                long    zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
                long    zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
                long    zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
                long    zk_loadimm8                          ' $3E: LD A,imm8
                long    zk_ccf                               ' $3F: CCF
                long    zk_nextop                            ' $40: LD B,B (NOP)
                long    zk_regmove                           ' $41: LD B,C
                long    zk_regmove                           ' $42: LD B,D
                long    zk_regmove                           ' $43: LD B,E
                long    zk_regmove                           ' $44: LD B,H
                long    zk_regmove                           ' $45: LD B,L
                long    zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
                long    zk_regmove                           ' $47: LD B,A
                long    zk_regmove                           ' $48: LD C,B
                long    zk_nextop                            ' $49: LD C,C (NOP)
                long    zk_regmove                           ' $4A: LD C,D
                long    zk_regmove                           ' $4B: LD C,E
                long    zk_regmove                           ' $4C: LD C,H
                long    zk_regmove                           ' $4D: LD C,L
                long    zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
                long    zk_regmove                           ' $4F: LD C,A
                long    zk_regmove                           ' $50: LD D,B
                long    zk_regmove                           ' $51: LD D,C
                long    zk_nextop                            ' $52: LD D,D (NOP)
                long    zk_regmove                           ' $53: LD D,E
                long    zk_regmove                           ' $54: LD D,H
                long    zk_regmove                           ' $55: LD D,L
                long    zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
                long    zk_regmove                           ' $57: LD D,A
                long    zk_regmove                           ' $58: LD E,B
                long    zk_regmove                           ' $59: LD E,C
                long    zk_regmove                           ' $5A: LD E,D
                long    zk_nextop                            ' $5B: LD E,E (NOP)
                long    zk_regmove                           ' $5C: LD E,H
                long    zk_regmove                           ' $5D: LD E,L
                long    zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
                long    zk_regmove                           ' $5F: LD E,A
                long    zk_regmove                           ' $60: LD H,B
                long    zk_regmove                           ' $61: LD H,C
                long    zk_regmove                           ' $62: LD H,D
                long    zk_regmove                           ' $63: LD H,E
                long    zk_nextop                            ' $64: LD H,H (NOP)
                long    zk_regmove                           ' $65: LD H,L
                long    zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
                long    zk_regmove                           ' $67: LD H,A
                long    zk_regmove                           ' $68: LD L,B
                long    zk_regmove                           ' $69: LD L,C
                long    zk_regmove                           ' $6A: LD L,D
                long    zk_regmove                           ' $6B: LD L,E
                long    zk_regmove                           ' $6C: LD L,H
                long    zk_nextop                            ' $6D: LD L,L (NOP)
                long    zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
                long    zk_regmove                           ' $6F: LD L,A
                long    zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
                long    zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
                long    zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
                long    zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
                long    zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
                long    zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
                long    zk_halt                              ' $76: HALT
                long    zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
                long    zk_regmove                           ' $78: LD A,B
                long    zk_regmove                           ' $79: LD A,C
                long    zk_regmove                           ' $7A: LD A,D
                long    zk_regmove                           ' $7B: LD A,E
                long    zk_regmove                           ' $7C: LD A,H
                long    zk_regmove                           ' $7D: LD A,L
                long    zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
                long    zk_nextop                            ' $7F: LD A,A (NOP)
                long   (zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
                long   (zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
                long   (zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
                long   (zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
                long   (zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
                long    zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
                long    zk_logic + (%000000_110_0<<10)       ' $A7: AND A
                long   (zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
                long    zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
                long    zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
                long   (zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
                long    zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
                long    zk_logic + (%001000_101_0<<10)       ' $B7: OR A
                long   (zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
                long    zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
                long    zk_poppair+(%0_0<<10)                  ' $C1: POP BC
                long    zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
                long    zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
                long    zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
                long    zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
                long    zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
                long    zk_rst                               ' $C7: RST 00h
                long    zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
                long    zk_ret + (%0101_11_00<<10)           ' $C9: RET
                long    zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
                long    zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
                long    zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
                long    zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
                long    zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
                long    zk_rst                               ' $CF: RST 08h
                long    zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
                long    zk_poppair+(%01_0<<10)                 ' $D1: POP DE
                long    zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
                long    zk_immio + (%00_000<<10)               ' $D3: OUT (imm8),A
                long    zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
                long    zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
                long    zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
                long    zk_rst                               ' $D7: RST 10h
                long    zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
                long    zk_exx                               ' $D9: EXX
                long    zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
                long    zk_immio + (%00_11_000<<10)            ' $DB: IN A,(imm8)
                long    zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
                long    zk_ixprefix                          ' $DD: IX prefix
                long    zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
                long    zk_rst                               ' $DF: RST 18h
                long    zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
                long    zk_poppair+(%0011_0<<10)               ' $E1: POP HL
                long    zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
                long    zk_ex_hlstk                          ' $E3: EX (SP),HL
                long    zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
                long    zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
                long    zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
                long    zk_rst                               ' $E7: RST 20h
                long    zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
                long    zk_jump_indir                          ' $E9: JP (HL)
                long    zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
                long    zk_ex_dehl                           ' $EB: EX DE,HL
                long    zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
                long    zk_extprefix + ZK_HLOP               ' $ED: extension prefix
                long    zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
                long    zk_rst                               ' $EF: RST 28h
                long    zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
                long    zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
                long    zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
                long    zk_irqoff                              ' $F3: DI
                long    zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
                long    zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
                long    zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
                long    zk_rst                               ' $F7: RST 30h
                long    zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
                long    zk_hl_to_sp                            ' $F9: LD SP,(HL)
                long    zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
                long    zk_irqon                               ' $FB: EI
                long    zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
                long    zk_iyprefix + (%10<<10)              ' $FD: IY prefix
                long    zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
                long    zk_rst                               ' $FF: RST 38h


CON ' ZiKore Z80 constants

    ZK_CLOCK      = VIDEO == PAL ? 3_500_000 : 3_527_500
    ZK_HLOP       = 1 << 10

    ZK_CARRY_BIT  = 0
    ZK_NMODE_BIT  = 1
    ZK_OVER_BIT   = 2 ' also parity
    ZK_HALF_BIT   = 4
    ZK_ZERO_BIT   = 6
    ZK_SIGN_BIT   = 7

    ZK_XYMASK     = %0010_1000
    ZK_SIGNXYMASK = %1010_1000

    ZK_IFF1_BIT   = 0
    ZK_IFF2_BIT   = 1
    ZK_HALT_BIT   = 2
    ZK_IM2_BIT    = 3

DAT             ' Video COG resident code
                org     $000

video_driver
                add     ptrb, ##@video_driver_lut - @video_driver
                setq2   #16-1   ' load palette into LUT
                rdlong  0, ptrb

                jmp     #\(VIDEO == VGA ? vga_init : cvbs_init) ' start video driver

'
' VGA Driver
'
vga_init
                setcmod #%01_0_000_1          ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24 ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16 ' g
                setcq   ##VGA_INTENSITY << 08 ' b
                setxfrq vga_xf                ' set transfer frequency

                cogid   _vx                 ' insert cogid into dac modes
                setnib  dacmode_s,_vx,#2
                setnib  dacmode_c,_vx,#2

                wrpin   dacmode_s,vga_pn    ' enable 123-ohm 3.3V dac mode in pin +0

                xor     vga_pn,#2<<6|1      ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c,vga_pn

                xor     vga_pn,#3<<6 ^(2<<6|1) ' make pins +0..3 outputs
                drvl    vga_pn

                xor     vga_pn,#4|(3<<6)    ' leave av_base pointing to pin +4 (vertical sync)
                drvh    vga_pn

vga_field       mov     ptra, zx_screen
                mov     ptrb, zx_attribute

                incmod  _fc, #32            ' blink frequency
                cmp     _fc, #16        wc

                mov     pa, #3
.block          mov     _rc, #8
.row            mov     _sc, #8             ' visible lines 8*8*3=192
.scanline
                call    #.line
                call    #.line1

                add     ptra, #256
                djnz    _sc, #.scanline

                sub     ptra, ##2048-32
                add     ptrb, #32
                djnz    _rc, #.row

                add     ptra, ##2048-256
                djnz    pa, #.block

                callpa  #24, #.border       ' bottom border

                callpa  #10, #.blank        ' back porch

                drvnot  vga_pn              ' vertical sync on
                callpa  #2, #.blank
                drvnot  vga_pn              ' vertical sync off

                cogatn  #1 << 0             ' vsync atn to Z80 cog (#0)

                callpa  #33, #.blank        ' front porch

                callpa  #24, #.border       ' top border

                jmp     #vga_field          ' frame loop

.line1          skipf   #%0_111_000
.line           xcont   vga_bs, #0          ' do before-sync part of scan line
                xzero   vga_ds, #1          ' do sync part of scan line
                xcont   vga_as, #0          ' do before-visible part of scan line

                rdbyte  _bc, #@zx_border
                and     _bc, #%00000_111
                movbyts _bc, #0
                xcont   vga_bv, _bc         ' do left border

                rep     @.loop, #32
                rdbyte  t0, ptrb++
                testb   t0, #7      wz      ' blink
                rdbyte  _ch, ptra++
        if_11   xor     _ch, #$FF           ' invert bitmap if blinking

                rev     _ch                 ' revert lsb<>msb
                shr     _ch, #24            ' shift into position
                mergew  _ch                 ' merge to 8 bitpairs

                testb   t0, #6      wz      ' bright
                mov     t1, t0
                and     t1, #%0_0_111_000   ' mask background
                shr     t1, #3              ' shift into byte 0
                bitz    t1, #3              ' set brightness
                and     t0, #%0_0_000_111   ' mask foreground
                shl     t0, #8              ' shift into byte 1
                bitz    t1, #8+3            ' set brightness
                or      t0, t1
                or      t1, t0

                movbyts t0, _ch
                xcont   vga_dv, t0
                shr     _ch, #8
                movbyts t1, _ch
                xcont   vga_dv, t1
.loop

                xcont   vga_av, _bc         ' do right border

                sub     ptra, #32
                sub     ptrb, #32
                ret

.border         xcont   vga_bs, #0          ' do before-sync part of scan line
                xzero   vga_ds, #1          ' do sync part of scan line
                xcont   vga_as, #0          ' do after-sync part of scan line

                rdbyte  _bc, #@zx_border
                and     _bc, #%00000_111
                movbyts _bc, #0
                xcont   vga_vi, _bc         ' do visible part of scan line

                xcont   vga_bs, #0          ' do before-sync part of scan line
                xzero   vga_ds, #1          ' do sync part of scan line
                xcont   vga_as, #0          ' do after-sync part of scan line
                xcont   vga_vi, _bc         ' do visible part of scan line
        _ret_   djnz    pa, #.border

.blank          xcont   vga_bs, #0          ' do before-sync part of scan line
                xzero   vga_ds, #1          ' do sync part of scan line
                xcont   vga_as, #0          ' do before-visible part of scan line
                xcont   vga_db, #0          ' do visible part of scan line
        _ret_   djnz    pa, #.blank         ' loop if more blanks needed

'
' PAL/NTSC driver COG resident code
'
cvbs_init
                setcmod #%11_1_0000         ' set colorspace converter to YIQ mode (composite)
                setcy   cvbs_cy             ' set colorspace converter y coefficients
                setci   cvbs_ci             ' set colorspace converter i coefficients
                setcq   cvbs_cq             ' set colorspace converter q coefficients
                setcfrq cvbs_cf             ' set colorspace converter frequency
                setxfrq cvbs_xf             ' set transfer frequency

                cogid   _vx                 ' install cogid into dacmode
                setnib  dacmode_c,_vx,#2
                wrpin   dacmode_c,cvbs_pn   ' enable dac mode in pin(s)
                drvl    cvbs_pn             ' enable dac output(s)

cvbs_field
                mov     ptra, zx_screen
                mov     ptrb, zx_attribute

                incmod  _fc, #32            ' blink frequency

                mov     pa, #3
.block          mov     _rc, #8
.row            mov     _sc, #8             ' visible lines 8*8*3=192

.scanline       xcont   cvbs_bs, #1         ' horizontal sync
                xcont   cvbs_ds, #2         ' |
                xcont   cvbs_bc, #1         ' |
                xcont   cvbs_dc, cvbs_cb    ' |
                bitnot  _md, #31        wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq             ' |
        if_c    setcq   cvbs_ca             ' |
                xcont   cvbs_ac, #1         ' |

                rdbyte  _bc, #@zx_border
                and     _bc, #%00000_111
                movbyts _bc, #0
                xcont   cvbs_bv, _bc        ' do left border

                cmp     _fc, #16    wc

                rep     @.loop, #32
                rdbyte  t0, ptrb++
                testb   t0, #7      wz      ' blink
                rdbyte  _ch, ptra++
        if_11   xor     _ch, #$FF           ' invert bitmap if blinking

                rev     _ch                 ' revert lsb<>msb
                shr     _ch, #24            ' shift into position
                mergew  _ch                 ' merge to 8 bitpairs

                testb   t0, #6      wz      ' bright
                mov     t1, t0
                and     t1, #%0_0_111_000   ' mask background
                shr     t1, #3              ' shift into byte 0
                bitz    t1, #3              ' set brightness
                and     t0, #%0_0_000_111   ' mask foreground
                shl     t0, #8              ' shift into byte 1
                bitz    t1, #8+3            ' set brightness
                or      t0, t1
                or      t1, t0

                movbyts t0, _ch
                xcont   cvbs_dv, t0
                shr     _ch, #8
                movbyts t1, _ch
                xcont   cvbs_dv, t1
.loop

                xcont   cvbs_av, _bc        ' do right border

                add     ptra, #256-32
                sub     ptrb, #32
                djnz    _sc, #.scanline

                sub     ptra, ##2048-32
                add     ptrb, #32
                djnz    _rc, #.row

                add     ptra, ##2048-256
                djnz    pa, #.block

                callpa  #(VIDEO == PAL ? 48 : 25), #.border ' bottom border

                callpa  #(VIDEO == PAL ? 8 : 7), #.blank ' after-visible blank lines

                callpa  #6, #.vhigh                      ' initial high vertical syncs
                callpa  #(VIDEO == PAL ? 5 : 6), #.vlow  ' low vertical syncs
                callpa  #(VIDEO == PAL ? 5 : 6), #.vhigh ' final high vertical syncs

                cogatn  #1 << 0             ' vsync atn to Z80 cog (#0)

                callpa  #(VIDEO == PAL ? 8 : 7), #.blank ' before-visible blank lines

                callpa  #(VIDEO == PAL ? 48 : 24), #.border ' top border

                jmp     #cvbs_field         ' frame loop

.border         xcont   cvbs_bs, #1         ' horizontal sync
                xcont   cvbs_ds, #2         ' |
                xcont   cvbs_bc, #1         ' |
                xcont   cvbs_dc, cvbs_cb    ' |
                bitnot  _md, #31        wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq             ' |
        if_c    setcq   cvbs_ca             ' |
                xcont   cvbs_ac, #1         ' |

                rdbyte  _bc, #@zx_border
                and     _bc, #%00000_111
                movbyts _bc, #0
                xcont   cvbs_vi, _bc        ' do visible part of scan line

        _ret_   djnz    pa, #.border

.blank          xcont   cvbs_bs, #1         ' horizontal sync
                xcont   cvbs_ds, #2         ' |
                xcont   cvbs_bc, #1         ' |
                xcont   cvbs_dc, cvbs_cb    ' |
                bitnot  _md, #31        wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq             ' |
        if_c    setcq   cvbs_ca             ' |
                xcont   cvbs_ac, #1         ' |
                xcont   cvbs_db, #1         ' blank line
        _ret_   djnz    pa, #.blank

.vhigh          xcont   cvbs_bs,#1
                xcont   cvbs_hl, #2
                xcont   cvbs_hh, #1
        _ret_   djnz    pa, #.vhigh

.vlow           xcont   cvbs_bs,#1
                xcont   cvbs_ll, #2
                xcont   cvbs_lh, #1
        _ret_   djnz    pa, #.vlow

'
'
' Data
'
dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

vga_xf          long   (VGA_FPIX frac _CLKFREQ) >> 1             ' streamer frequency setting
vga_bs          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +   8    ' streamer command: before-sync
vga_ds          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  48    ' streamer command: during-sync
vga_as          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  24    ' streamer command: after sync
vga_vi          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + 320    ' streamer command: visible
vga_bv          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: before visible
vga_dv          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +   4    ' streamer command: during visible
vga_av          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: after visible
vga_db          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + 320    ' streamer command: during-blank
vga_pn          long    VGA_PIN & $38       ' base pin

cvbs_cb         long    VIDEO == PAL ? PAL_CB : NTSC_CB             ' colorburst reference color
cvbs_cy         long    VIDEO == PAL ? PAL_CY : NTSC_CY             ' colorspace y coefficients
cvbs_ci         long    VIDEO == PAL ? PAL_CI : NTSC_CI             ' colorspace i coefficients
cvbs_cq         long    VIDEO == PAL ? PAL_CQ : NTSC_CQ             ' colorspace q coefficients
cvbs_ca         long    VIDEO == PAL ? PAL_CA : NTSC_CQ             ' colorspace q coefficients, alt for pal
cvbs_cf         long   (VIDEO == PAL ? PAL_CF : NTSC_CF) frac _CLKFREQ ' colorspace frequency setting
cvbs_xf         long    VIDEO == PAL ? PAL_XF : NTSC_XF             ' streamer frequency setting

cvbs_bs         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  11 :  11)    ' streamer command: before-sync
cvbs_ds         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  32 :  33)    ' streamer command: during-sync
cvbs_bc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?   7 :   5)    ' streamer command: before-colorburst
cvbs_dc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  16 :  17)    ' streamer command: during-colorburst
cvbs_ac         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  30 :  30)    ' streamer command: after-colorburst
cvbs_db         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +                   352         ' streamer command: during-blank

cvbs_bv         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +                    48         ' streamer command: before-visible
cvbs_dv         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +                     4         ' streamer command: during-visible
cvbs_av         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +                    48         ' streamer command: after-visible
cvbs_vi         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +                   352         ' streamer command: visible

cvbs_hl         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  16 :  16)    ' streamer command: high-vsync-low
cvbs_hh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 197 : 197)    ' streamer command: high-vsync-high

cvbs_ll         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 191 : 191)    ' streamer command: low-vsync-low
cvbs_lh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  22 :  22)    ' streamer command: low-vsync-high

cvbs_pn         long    CVBS_PIN            ' pin(s)

zx_screen       long    @z80_4000
zx_attribute    long    @z80_4000 + 32*192

_vx             long    0
_sc             long    0
_rc             long    0
_md             long    0

_ch             long    0
_fc             long    0

_bc             long    0

t0              res     1
t1              res     1
t2              res     1

                fit     $1F0

DAT             ' Video LUT resident code
                org     $200

video_driver_lut
                long    $00_00_00_00    ' Palette
                long    $00_00_B8_00
                long    $B8_00_00_00
                long    $B8_00_B8_00
                long    $00_B8_00_00
                long    $00_B8_B8_00
                long    $B8_B8_00_00
                long    $B8_B8_B8_00

                long    $00_00_00_00
                long    $00_00_F8_00
                long    $F8_00_00_00
                long    $F8_00_F8_00
                long    $00_F8_00_00
                long    $00_F8_F8_00
                long    $F8_F8_00_00
                long    $F8_F8_F8_00

CON ' VGA constants

    VGA           = 0
    VGA_FPIX      = 12_500_000
    VGA_INTENSITY = 80    '0..128

CON ' CVBS constants

    CLK_I           = 31 - encod _CLKFREQ

    NTSC            = 1
    NTSC_BLANK_LEV  = 40.0                                  ' levels
    NTSC_BLACK_LEV  = NTSC_BLANK_LEV + 7.5
    NTSC_PEAK_LEV   = NTSC_BLANK_LEV + 140.0
    NTSC_SCALE      = 127.0 / NTSC_PEAK_LEV * 128.0
    NTSC_SCALE_COR  = NTSC_SCALE / 1.646                    ' CORDIC prescale for IQ modulator

    NTSC_BLANK      = round(NTSC_SCALE * 2.0 * NTSC_BLANK_LEV / NTSC_PEAK_LEV)
    NTSC_BLACK      = round(NTSC_SCALE * 2.0 * NTSC_BLACK_LEV / NTSC_PEAK_LEV)

    NTSC_YR         = round(NTSC_SCALE     *  0.299)        ' Y sums to 1
    NTSC_YG         = round(NTSC_SCALE     *  0.587)
    NTSC_YB         = round(NTSC_SCALE     *  0.114)

    NTSC_IR         = round(NTSC_SCALE_COR *  0.596)        ' I sums to 0
    NTSC_IG         = round(NTSC_SCALE_COR * -0.274)
    NTSC_IB         = round(NTSC_SCALE_COR * -0.322)

    NTSC_QR         = round(NTSC_SCALE_COR *  0.212)        ' Q sums to 0
    NTSC_QG         = round(NTSC_SCALE_COR * -0.523)
    NTSC_QB         = round(NTSC_SCALE_COR *  0.311)

    NTSC_CY         = (NTSC_YR & $FF) << 24 + (NTSC_YG & $FF) << 16 + (NTSC_YB & $FF) << 8 + NTSC_BLACK
    NTSC_CI         = (NTSC_IR & $FF) << 24 + (NTSC_IG & $FF) << 16 + (NTSC_IB & $FF) << 8 + NTSC_BLANK
    NTSC_CQ         = (NTSC_QR & $FF) << 24 + (NTSC_QG & $FF) << 16 + (NTSC_QB & $FF) << 8 + 128

    NTSC_CB         = $809000_01                            ' colorburst reference color
    NTSC_CF         = 3_579_545                             ' colorburst frequency
    'NTSC_CC         = 227.5                                 ' color cycles per line * 4 to preserve fraction
    'NTSC_X_TOTAL    = 448

    NTSC_DOTF       = 7_055_000 * 128 ' (NTSC_X_TOTAL * NTSC_CF * 128) / NTSC_CC
    NTSC_XF         = ((NTSC_DOTF >> (7 - CLK_I)) frac (_CLKFREQ << CLK_I) + 1) >> 1

    PAL             = 2
    PAL_BLANK_LEV   = 43.0                                  ' levels
    PAL_BLACK_LEV   = PAL_BLANK_LEV + 0.0
    PAL_PEAK_LEV    = PAL_BLANK_LEV + 140.0
    PAL_SCALE       = 127.0 / PAL_PEAK_LEV * 128.0
    PAL_SCALE_COR   = PAL_SCALE / 1.646                     ' CORDIC prescale for IQ modulator

    PAL_BLANK       = round(PAL_SCALE * 2.0 * PAL_BLANK_LEV / PAL_PEAK_LEV)
    PAL_BLACK       = round(PAL_SCALE * 2.0 * PAL_BLACK_LEV / PAL_PEAK_LEV)

    PAL_YR          = round(PAL_SCALE     *  0.299)         ' Y sums to 1
    PAL_YG          = round(PAL_SCALE     *  0.587)
    PAL_YB          = round(PAL_SCALE     *  0.114)

    PAL_UR          = round(PAL_SCALE_COR * -0.147)         ' I sums to 0
    PAL_UG          = round(PAL_SCALE_COR * -0.289)
    PAL_UB          = round(PAL_SCALE_COR *  0.436)

    PAL_VR          = round(PAL_SCALE_COR *  0.615)         ' Q sums to 0
    PAL_VG          = round(PAL_SCALE_COR * -0.515)
    PAL_VB          = round(PAL_SCALE_COR * -0.100)

    PAL_CY          = ( PAL_YR & $FF) << 24 + ( PAL_YG & $FF) << 16 + ( PAL_YB & $FF) << 8 + PAL_BLACK
    PAL_CI          = ( PAL_UR & $FF) << 24 + ( PAL_UG & $FF) << 16 + ( PAL_UB & $FF) << 8 + PAL_BLANK
    PAL_CQ          = ( PAL_VR & $FF) << 24 + ( PAL_VG & $FF) << 16 + ( PAL_VB & $FF) << 8 + 128
    PAL_CA          = (-PAL_VR & $FF) << 24 + (-PAL_VG & $FF) << 16 + (-PAL_VB & $FF) << 8 + 128

    PAL_CB          = $FFC060_01                            ' colorburst reference color
    PAL_CF          = 4_433_618                             ' colorburst frequency
    'PAL_CC          = 283.75                                ' color cycles per line
    'PAL_X_TOTAL     = 448

    PAL_DOTF        = 7_000_000 * 128 ' (PAL_X_TOTAL * PAL_CF * 128) / PAL_CC                     ' ZX dot frequency
    PAL_XF          = ((PAL_DOTF >> (7 - CLK_I)) frac (_CLKFREQ << CLK_I) + 1) >> 1

DAT             ' I/O Hub-exec code
                orgh

zx_ula_write
                wrbyte  zk_tmp8, #@zx_border
                testb   zk_tmp8, #4     wc  ' speaker
                testb   zk_tmp8, #3     orc ' mic
                drvc    #ZX_MIC             ' |
                ret     wcz

zx_ula_read
                getbyte zk_tmp0, zk_ea, #1
                xor     zk_tmp0, #$FF
                encod   zk_tmp0, zk_tmp0
                add     zk_tmp0, #@zx_keys
                rdbyte  zk_tmp8, zk_tmp0
                testp   #ZX_EAR         wc  ' ear
                bitc    zk_tmp8, #6         ' |
                ret     wcz

DAT             ' Z80 Memory Space
                orgh

z80_0000        file    "48.rom"
                orgh    z80_0000 + $4000
z80_4000
                ' Locations below used as Z80 RAM
