{
    ColecoVision Console Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Z80 Emulator by Ada GottenstrÃ¤ter (Wuerfel_21)
    TMS9918 Emulator by Marco Maccaferri
}
CON

    _CLKFREQ        = 250_000_000

    CPU_CLOCK       = 3_579_545.0 ' 3_546_893.0

    VGA_PIN         = 8

    PS2_DATA_PIN    = 25
    PS2_CLOCK_PIN   = 24

    AUDIO_RIGHT_PIN = 49
    AUDIO_LEFT_PIN  = 48

                ' startup code

DAT             org     $000

                asmclk
                coginit #1, ##@zk_cogbase       'start Z80 on cog #1
                coginit #2, ##@tms_driver       'start TMS9918 on cog #2
                jmp     #\ps2_driver

' Controller status

coleco_ctrls
                byte    $FF     ' keypad 0
                byte    $FF     ' joystick 0
                byte    $FF     ' keypad 1
                byte    $FF     ' joystick 1

' TMS9918 registers

tms_regs        byte    $00, $00, $00, $00, $00, $00, $00, $00
tms_status      byte    $00

' SN76489 registers

sn_registers
                                ' Reg bits function
                                ' -----------------------------------
                word    $0000   ' 00  9..0 channel 1 freq
                byte    $00     ' 01  3..0 channel 1 attunation
                word    $0000   ' 02  9..0 channel 2 freq
                byte    $00     ' 03  3..0 channel 2 attunation
                word    $0000   ' 04  9..0 channel 3 freq
                byte    $00     ' 05  3..0 channel 3 attunation
                byte    $00     ' 06  4..0 noise control
                byte    $00     ' 07  7..0 noise attunation

ps2_driver
                fltl    #PS2_DATA_PIN
                fltl    #PS2_CLOCK_PIN

                mov     ps2_data, #$F3      ' auto-repeat
                call    #ps2_transmit
                and     ps2_data, #%011_11111 ' slow 1s / 2cps
                call    #ps2_transmit

                mov     ps2_state, #%0_000  ' turn off all leds
                jmp     #ps2_locks

ps2_reset
ps2_loop        testpn  #PS2_CLOCK_PIN  wz  ' wait for initial clock low
        if_z    jmp     #$-1

                and     ps2_state, #$07     ' keep locks state
                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ##_CLKFREQ / 10

.l1             call    #ps2_receive
                getbyte ps2_code, ps2_data, #0

                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #.l1

                cmp     ps2_data, #$E0  wz
        if_z    bith    ps2_state, #28
        if_z    jmp     #ps2_ext0
                cmp     ps2_data, #$E1  wz
        if_z    bith    ps2_state, #29
        if_z    jmp     #ps2_ext1

ps2_ext_ret     testbn  ps2_state, #29  wz
        if_nz   jmp     #ps2_loop           ' E1 codes are ignored

                testb   ps2_state, #7   wc  ' release

                cmp     ps2_code, #$14  wz  ' left control
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_CTRL

                cmp     ps2_code, #$14  wz  ' right control
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_CTRL

                cmp     ps2_code, #$12  wz  ' left shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_SHIFT
                cmp     ps2_data, #$59  wz  ' right shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_SHIFT

                cmp     ps2_code, #$11  wz  ' left alt
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_ALT

                cmp     ps2_code, #$11  wz  ' right alt
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_ALT

                cmp     ps2_code, #$1F  wz  ' left gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_GUI
                cmp     ps2_code, #$27  wz  ' right gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_GUI

                cmp     ps2_code, #$77  wz  ' num. lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #0       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$58  wz  ' caps lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #1       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$7E  wz  ' scroll lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #2       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds

                testb   ps2_state, #28  wc  ' extended code
                rcl     ps2_code, #1        '   to bit 0
                altgb   ps2_code, #ps2_table ' get usb scancode
                getbyte ps2_key, ps2_code, #0   ' |
        '        shl     key, #8         wz
        'if_z    jmp     #loop

                testb   ps2_state, #7   wc  ' release

                'call    #translate
                cmp     ps2_key, #$1E       wz  ' 1
 if_z_and_nc    setbyte ps2_ctrl, #$0D, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$1F       wz  ' 2
 if_z_and_nc    setbyte ps2_ctrl, #$07, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$20       wz  ' 3
 if_z_and_nc    setbyte ps2_ctrl, #$0C, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$21       wz  ' 4
 if_z_and_nc    setbyte ps2_ctrl, #$02, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$22       wz  ' 5
 if_z_and_nc    setbyte ps2_ctrl, #$03, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$23       wz  ' 6
 if_z_and_nc    setbyte ps2_ctrl, #$0E, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$24       wz  ' 7
 if_z_and_nc    setbyte ps2_ctrl, #$05, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$25       wz  ' 8
 if_z_and_nc    setbyte ps2_ctrl, #$01, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$26       wz  ' 9
 if_z_and_nc    setbyte ps2_ctrl, #$0B, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$27       wz  ' 0
 if_z_and_nc    setbyte ps2_ctrl, #$0A, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$2D       wz  ' *
 if_z_and_nc    setbyte ps2_ctrl, #$09, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0
                cmp     ps2_key, #$2E       wz  ' #
 if_z_and_nc    setbyte ps2_ctrl, #$06, #0
  if_z_and_c    setbyte ps2_ctrl, #$FF, #0

                cmp     ps2_key, #$4F       wz  ' RIGHT
        if_z    bitc    ps2_ctrl, #8+1
                cmp     ps2_key, #$50       wz  ' LEFT
        if_z    bitc    ps2_ctrl, #8+3
                cmp     ps2_key, #$51       wz  ' DOWN
        if_z    bitc    ps2_ctrl, #8+2
                cmp     ps2_key, #$52       wz  ' UP
        if_z    bitc    ps2_ctrl, #8+0

                cmp     ps2_key, #$E0       wz  ' LEFT BUTTON
        if_z    bitc    ps2_ctrl, #8+6
                cmp     ps2_key, #$E1       wz  ' RIGHT BUTTON
        if_z    bitc    ps2_ctrl, #6

                wrlong  ps2_ctrl, #@coleco_ctrls

                jmp     #ps2_loop

ps2_locks       mov     ps2_data, #$ED
                call    #ps2_transmit
                mov     ps2_data, #0
                testb   ps2_state, #0   wz  ' num. lock
                bitz    ps2_data, #1
                testb   ps2_state, #1   wz  ' caps lock
                bitz    ps2_data, #2
                testb   ps2_state, #2   wz  ' scroll lock
                bitz    ps2_data, #0
                call    #ps2_transmit
                jmp     #ps2_loop

ps2_ext1        call    #ps2_receive
                setbyte ps2_code, ps2_data, #1
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext1

                ' fall through

ps2_ext0        call    #ps2_receive
                setbyte ps2_code, ps2_data, #0
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext0

                jmp     #ps2_ext_ret

ps2_transmit    drvl    #PS2_CLOCK_PIN      ' pull clock low
                getct   ps2_tout            ' hold clock for 128us (must be > 100us)
                addct1  ps2_tout, ps2_us128 ' |
                waitct1                     ' |
                drvl    #PS2_DATA_PIN       ' pull data low
                getct   ps2_tout            ' hold data for 4us
                addct1  ps2_tout, ps2_us4   ' |
                waitct1                     ' |

                fltl    #PS2_CLOCK_PIN      ' release clock
                getct   ps2_tout            ' allow pin to float
                addct1  ps2_tout, ps2_us1   ' |
                waitct1                     ' |

                test    ps2_data, #$FF  wc  ' append parity
                muxnc   ps2_data, #$100     ' |
                bith    ps2_data, #9        ' append stop bit

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ##_CLKFREQ / 10

                mov     ps2_bits, #10
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        'if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1
                shr     ps2_data, #1    wc  ' output data bit
                drvc    #PS2_DATA_PIN
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        'if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2
                djnz    ps2_bits, #.l1

                fltl    #PS2_DATA_PIN

.l3             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data low
        if_z    testpn  #PS2_DATA_PIN   wz
        'if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l3

.l4             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data high
        if_nz   testpn  #PS2_DATA_PIN   wz
        'if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l4

                ' Fall through to receive ack

ps2_receive     mov     ps2_bits, #11
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        'if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                testp   #PS2_DATA_PIN   wc  ' sample data
                rcr     ps2_data, #1
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        'if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit?

                shr     ps2_data, #22       ' align byte
                test    ps2_data, #$1FF wc  ' test parity
        if_nc   jmp     #ps2_reset
        _ret_   and     ps2_data, #$FF


ps2_us1         long    _CLKFREQ / 1000_000 * 1     ' 1 usec.
ps2_us4         long    _CLKFREQ / 1000_000 * 4     ' 4 usec.
ps2_us128       long    _CLKFREQ / 1000_000 * 128   ' 128 usec.

ps2_bits        long    0
ps2_code        long    0
ps2_state       long    0
ps2_shift       long    0
ps2_key         long    0

ps2_data        long    0
ps2_tout        long    0

ps2_ctrl        long    $FFFFFFFF

ps2_table       word    $0000   '00
                word    $0042   '01             F9
                word    $0000   '02
                word    $003E   '03             F5
                word    $003C   '04             F3
                word    $003A   '05             F1
                word    $003B   '06             F2
                word    $0045   '07             F12
                word    $0000   '08
                word    $0043   '09             F10
                word    $0041   '0A             F8
                word    $003F   '0B             F6
                word    $003D   '0C             F4
                word    $002B   '0D             Tab
                word    $0035   '0E             `
                word    $0000   '0F
                word    $0000   '10
                word    $E6E2   '11     Alt-R   Alt-L
                word    $00E1   '12             Shift-L
                word    $0000   '13
                word    $E4E0   '14     Ctrl-R  Ctrl-L
                word    $0014   '15             q
                word    $001E   '16             1
                word    $0000   '17
                word    $0000   '18
                word    $0000   '19
                word    $001D   '1A             z
                word    $0016   '1B             s
                word    $0004   '1C             a
                word    $001A   '1D             w
                word    $001F   '1E             2
                word    $E300   '1F     Win-L
                word    $0000   '20
                word    $0006   '21             c
                word    $001B   '22             x
                word    $0007   '23             d
                word    $0008   '24             e
                word    $0021   '25             4
                word    $0020   '26             3
                word    $E700   '27     Win-R
                word    $0000   '28
                word    $002C   '29             Space
                word    $0019   '2A             v
                word    $0009   '2B             f
                word    $0017   '2C             t
                word    $0015   '2D             r
                word    $0022   '2E             5
                word    $6500   '2F     Apps
                word    $0000   '30
                word    $0011   '31             n
                word    $0005   '32             b
                word    $000B   '33             h
                word    $000A   '34             g
                word    $001C   '35             y
                word    $0023   '36             6
                word    $0000   '37     Power
                word    $0000   '38
                word    $0000   '39
                word    $0010   '3A             m
                word    $000D   '3B             j
                word    $0018   '3C             u
                word    $0024   '3D             7
                word    $0025   '3E             8
                word    $0000   '3F     Sleep
                word    $0000   '40
                word    $0036   '41             ,
                word    $000E   '42             k
                word    $000C   '43             i
                word    $0012   '44             o
                word    $0027   '45             0
                word    $0026   '46             9
                word    $0000   '47
                word    $0000   '48
                word    $0037   '49             .
                word    $5438   '4A     (/)     /
                word    $000F   '4B             l
                word    $0033   '4C             ;
                word    $0013   '4D             p
                word    $002D   '4E             -
                word    $0000   '4F
                word    $0000   '50
                word    $0000   '51
                word    $0034   '52             '
                word    $0000   '53
                word    $002F   '54             [
                word    $002E   '55             =
                word    $0000   '56
                word    $0000   '57
                word    $0039   '58             CapsLock
                word    $00E5   '59             Shift-R
                word    $5828   '5A     (Enter) Enter
                word    $0030   '5B             ]
                word    $0000   '5C
                word    $0031   '5D             \
                word    $0000   '5E     WakeUp
                word    $0000   '5F
                word    $0000   '60
                word    $0064   '61
                word    $0000   '62
                word    $0000   '63
                word    $0000   '64
                word    $0000   '65
                word    $002A   '66             BackSpace
                word    $0000   '67
                word    $0000   '68
                word    $4D59   '69     End     (1)
                word    $0000   '6A
                word    $505C   '6B     Left    (4)
                word    $4A5F   '6C     Home    (7)
                word    $0000   '6D
                word    $0000   '6E
                word    $0000   '6F
                word    $4962   '70     Insert  (0)
                word    $4C63   '71     Delete  (.)
                word    $515A   '72     Down    (2)
                word    $005D   '73             (5)
                word    $4F5E   '74     Right   (6)
                word    $5260   '75     Up      (8)
                word    $0029   '76             Esc
                word    $0053   '77             NumLock
                word    $0044   '78             F11
                word    $0057   '79             (+)
                word    $4E5B   '7A     PageDn  (3)
                word    $0056   '7B             (-)
                word    $4655   '7C     PrScr   (*)
                word    $4B61   '7D     PageUp  (9)
                word    $0047   '7E             ScrLock
                word    $0000   '7F
                word    $0000   '80
                word    $0000   '81
                word    $0000   '82
                word    $0040   '83             F7

                fit     $1F0

CON

    LEFT_CTRL   = %0000_0001
    LEFT_SHIFT  = %0000_0010
    LEFT_ALT    = %0000_0100
    LEFT_GUI    = %0000_1000
    RIGHT_CTRL  = %0001_0000
    RIGHT_SHIFT = %0010_0000
    RIGHT_ALT   = %0100_0000
    RIGHT_GUI   = %1000_0000

DAT             org     $000

'
' Z80 CPU Emulator
'

zk_cogbase
                add     ptrb, ##@zk_lutbase - @zk_cogbase
                setq2   #511
                rdlong  0, ptrb

                mov     zk_pc, #0
                mov     zk_irqenable, #0
                mov     zk_irqhook, #0
                mov     zk_refresh, #0
                mov     zk_refreshhi, #0
                mov     zk_ivector, #0
                getct   zk_lastwait
                mov     zk_cycles, #1

zk_nextop
                jatn    zk_nmiptr
zk_irqhook      nop

                mul     zk_cycles, zk_cycletime
                add     zk_cycles, zk_lastwait
                getct   pa
                sub     zk_cycles, pa
                cmps    zk_cycles, #1   wc
        if_ae   waitx   zk_cycles
                getct   zk_lastwait

                mov     zk_cycles, #1

                mov     zk_temphl, zk_hl
                mov     zk_hlptr, #zk_hl
                mov     zk_tempidx, zk_hl
                mov     zk_prefix, #0
                incmod  zk_refresh, #127

                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                'debug(uhex_byte(zk_opcode))
                rdlut   zk_opimpl, zk_opcode
                'debug(uhex_long(zk_opimpl))
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
                push    #zk_nextop
                execf   zk_opimpl

zk_iyprefix
                mov     zk_hlptr, #zk_iy
zk_ixprefix
                mov     zk_hlptr, #zk_ix

                mov     zk_prefix, zk_opcode
                incmod  zk_refresh, #127
                add     zk_cycles, #1


                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                rdlut   zk_opimpl, zk_opcode
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc   jmp     #.nodisplace
                ' handle index displacement
                mov     zk_temphl, zk_hl
                alts    zk_hlptr
                mov     zk_tempidx, 0-0
                mov     zk_hlptr, #zk_hl
                call    #zk_readcode
                signx   zk_tmp8, #7
                add     zk_tempidx, zk_tmp8
                execf   zk_opimpl

.nodisplace
                alts    zk_hlptr
                mov     zk_temphl, 0-0
                mov     zk_tempidx, zk_temphl
                execf   zk_opimpl

zk_bitprefix
                call    #\zk_readcode
                mov     zk_opcode, zk_tmp8
                add     zk_cycles, #1
                incmod  zk_refresh, #127

                cmp     zk_prefix, #0 wz
        if_z    call    #zk_getrz
        if_nz   call    #zk_read8hl

                mov     pa, zk_opcode
                shr     pa, #3
                and     pa, #7

                testb   zk_opcode, #7 wc
                testb   zk_opcode, #6 wz
        if_00   jmp     #.shift
        if_01   jmp     #.bit
                bitz    zk_tmp8, pa
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix, #0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

.bit
                decod   pa
                and     pa, zk_tmp8 wz
                muxz    zk_flags, #(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
                bitl    zk_flags, #ZK_NMODE_BIT
                bith    zk_flags, #ZK_HALF_BIT
                setq    #1<<ZK_SIGN_BIT
                muxq    zk_flags, pa
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags, zk_tmp8

.shift
                push    #.shiftdone
                altd    pa, #zk_shift_impl_tbl
                execf   0-0

.shiftdone
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix,#0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

zk_shift_impl_tbl
                long    zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
                long    zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
                long    zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
                long    zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
                long    zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
                long    zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
                long    zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
                long    zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL

zk_extprefix
                call #\zk_readcode
                mov zk_opcode,zk_tmp8
                add zk_cycles,#1
                incmod zk_refresh,#127
                'debug("extend ",uhex_byte(zk_opcode))

                cmp zk_opcode,#$A0 wc
        if_ae   jmp #.blockop
                cmp zk_opcode,#$40 wc
        if_b    ret

                mov pa,zk_opcode
                and pa,#7
                altd pa,#zk_ext_impl_tbl
                execf 0-0

.blockop
                '' The undocumented flags on these are cursed.
                test    zk_opcode,#%0100_0100 wz
        if_nz   ret     ' NOP
                rczr    zk_opcode wcz ' get operation type into cz
        if_00   add     zk_cycles,#2
        if_01   add     zk_cycles,#5
        if_1x   add     zk_cycles,#1
        if_00   skipf   ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01   skipf   ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10   skipf   ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11   skipf   ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

                getbyte zk_ea,zk_debc,#0 ' IN
                call    #\zk_portin ' IN
                call    #\zk_read8hl ' everything else

                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
                bith    zk_flags,#ZK_NMODE_BIT ' CP
                testb   zk_tmp8,#7 wc ' IN/OUT
                bitc    zk_flags,#ZK_NMODE_BIT ' IN/OUT

                mov     zk_optmp0,zk_accu ' LD CP
                getbyte zk_optmp0,zk_hl,#0 ' OUT
                getbyte zk_optmp0,zk_debc,#0 ' IN
                testb   zk_opcode,#1 wc ' IN
                sumc    zk_optmp0,#1 ' IN
                mov     zk_optmp1,zk_tmp8 ' CP
                xor     zk_optmp1,zk_optmp0 ' CP

                sub     zk_optmp0,zk_tmp8 ' CP only
                add     zk_optmp0,zk_tmp8 ' LD,IN,OUT

                xor     zk_optmp1,zk_optmp0 ' CP
                and     zk_optmp0,#255 wz ' CP,IN,OUT
                bitz    zk_flags,#ZK_ZERO_BIT ' CP
                testb   zk_optmp0,#7 wc ' CP
                bitc    zk_flags,#ZK_SIGN_BIT ' CP

                testb   zk_optmp1,#4 wc   ' CP
                cmpr    zk_optmp0,#255 wc  ' IN/OUT
                bitc    zk_flags,#ZK_HALF_BIT ' CP
                muxc    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c    sub     zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

                skipf   ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
                skipf   ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
                skipf   ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
                skipf   ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


                testb   zk_optmp0,#1 wc ' LD,CP
                bitc    zk_flags,#5 'LD,CP (sets YF)
                testb   zk_optmp0,#3 wc ' LD,CP
                bitc    zk_flags,#3 'LD,CP (sets XF)

                getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
                and     zk_optmp0,#7 ' IN,OUT
                xor     zk_optmp0,zk_optmp1 wc ' IN,OUT
                bitnc   zk_flags,#ZK_OVER_BIT ' IN,OUT

                mov     zk_ea,zk_hl  ' IN
                getword zk_ea,zk_debc,#1 ' LD
                call    #\zk_write8 ' LD,IN
                getbyte zk_ea,zk_debc,#0 ' OUT
                call    #\zk_portout ' OUT

                getword zk_optmp1,zk_debc,#0 ' LD,CP
                decmod  zk_optmp1,zk_ffffh wz ' all
                setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
                setword zk_debc,zk_optmp1,#0 ' LD,CP
                bitnz   zk_flags,#ZK_OVER_BIT ' LD,CP
                bitz    zk_flags,#ZK_ZERO_BIT ' IN,OUT
                setq    #ZK_SIGNXYMASK ' IN,OUT
                muxq    zk_flags,zk_optmp1 ' IN,OUT

                testb   zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
                testb   zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc   incmod  zk_ea,zk_ffffh    ' LD
        if_c    decmod  zk_ea,zk_ffffh    ' LD
                setword zk_debc,zk_ea,#1 ' LD

        if_nc   incmod  zk_hl,zk_ffffh
        if_c    decmod  zk_hl,zk_ffffh

                testb   zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz    sub     zk_pc,#2
 if_c_and_nz    add     zk_cycles,#5
                'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
                ret

zk_ext_impl_tbl
                long    zk_cio + (%10_11_11_000000<<10) ' IN [BCDEHL0A],(C)
                long    zk_cio + (%00_01_11_000000<<10) ' OUT (C),[BCDEHL0A]
                long    zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
                long    zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
                long    zk_neg
                long    zk_irqret
                long    zk_imode
                long    zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7

                altd    pa,#zk_extmath16_impl_tbl
                altd    pa,#zk_extld16_impl_tbl
                altd    pa,#zk_extmisc_impl_tbl

                execf   0-0

zk_extmath16_impl_tbl
                long    zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
                long    zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
                long    zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
                long    zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
                long    zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
                long    zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
                long    zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
                long    zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
                long    zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
                long    zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
                long    zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
                long    zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
                long    zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
                long    zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
                long    zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
                long    zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
                long    zk_a2i                       ' LD I,A
                long    zk_a2r                       ' LD R,A
                long    zk_i2a                       ' LD A,I
                long    zk_r2a  + (%1_000<<10)       ' LD A,R
                long    zk_rxd + (%000_111_00<<10)   ' RRD
                long    zk_rxd + (%111_000_00<<10)   ' RLD
                long    zk_nextop                    ' NOP
                long    zk_nextop                    ' NOP

zk_rxd
                call    #\zk_read8hl
                add     zk_cycles,#4
                ' RLD
                rolnib  zk_tmp8,zk_accu,#0
                getnib  pa,zk_tmp8,#2
                setnib  zk_tmp8,#0,#2
                ' RRD
                setnib  zk_tmp8,zk_accu,#2
                getnib  pa,zk_tmp8,#0
                shr     zk_tmp8,#4

                setnib  zk_accu,pa,#0
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_accu
                jmp     #\zk_write8hl

zk_a2r
                mov     zk_refresh,zk_accu
                and     zk_refresh,#$7F
        _ret_   mov     zk_refreshhi,zk_accu

zk_a2i
        _ret_   mov     zk_ivector,zk_accu

zk_r2a
                mov     zk_accu,zk_refresh
                setq    #$80
                muxq    zk_accu,zk_refreshhi
zk_i2a
                mov     zk_accu,zk_ivector

                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_irqret       '' RETI/RETN
                '' These are literally the same
                testb   zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_irqenable,#ZK_IFF1_BIT
                call    #\zk_pop16
        _ret_   mov     zk_pc,zk_tmp16


zk_imode        ' Don't care, always assume IM1
                ret

zk_irqoff
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_   mov     zk_irqhook,#0
zk_irqon
                or      zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_   mov     zk_irqhook,##(%1111_1011110_010_000000100<<9)+zk_irqptr ' JSE1 zk_irqptr

zk_irqptr       long    zk_doirq
zk_doirq
                add     zk_cycles,#10
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)
                mov     zk_irqhook,#0
                mov     zk_tmp16,zk_pc
                call    #\zk_push16
                mov     zk_pc,#$38
                jmp     #\zk_nextop

zk_nmiptr       long    zk_donmi
zk_donmi
                add     zk_cycles,#10
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)
                mov     zk_tmp16,zk_pc
                call    #\zk_push16
                mov     zk_pc,#$66
                jmp     #\zk_nextop

zk_jump_indir
        _ret_   mov     zk_pc,zk_temphl
zk_hl_to_sp
                add     zk_cycles,#2
        _ret_   mov     zk_sp,zk_temphl

zk_jump
                call    #\zk_readcode16
zk_condret
                add     zk_cycles,#1 ' Extra cycle in conditional RET

                testb   zk_flags,#ZK_ZERO_BIT wc
                testb   zk_flags,#ZK_CARRY_BIT wc
                testb   zk_flags,#ZK_OVER_BIT wc
                testb   zk_flags,#ZK_SIGN_BIT wc

                modc    _nc wc
        if_c    call    #\zk_nextop
zk_ret
                call    #zk_pop16
                mov     zk_optmp0,zk_tmp16 ' For every op!
zk_rst
                mov     zk_optmp0,zk_opcode
                and     zk_optmp0,#%00111000
zk_pushjmp
                mov     zk_tmp16,zk_pc
                mov     zk_pc,zk_optmp0
                jmp     #\zk_push16
                ret

zk_getrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                'debug("in zk_getrz ",uhex_byte(pa))
                add     pa,#zk_getrpa-$-1
                jmprel  pa
zk_getry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
zk_getrpa
                jmprel  pa
        _ret_   getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_   getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_   getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_   getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_   getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_   getbyte zk_tmp8,zk_temphl,#0 ' L register
                jmp     #zk_read8hl              ' (HL)
        _ret_   getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                add     pa,#zk_setrpa-$-1
                jmprel  pa
zk_setry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
                'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa       jmprel  pa
        _ret_   setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_   setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_   setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_   setbyte zk_debc,zk_tmp8,#2   ' E register
                jmp     #.seth                   ' H register
                jmp     #.setl                   ' L register
                jmp     #zk_write8hl             ' (HL)
        _ret_   setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
                setbyte zk_temphl,zk_tmp8,#1
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl
.setl
                setbyte zk_temphl,zk_tmp8,#0
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_push16
                add     zk_cycles,#1
                sub     zk_sp,#2
                setword zk_sp,#0,#1
                mov     zk_ea,zk_sp
                jmp     #zk_write16
zk_pop16
                mov     zk_ea,zk_sp
                add     zk_sp,#2
                setword zk_sp,#0,#1
                jmp     #zk_read16

zk_read16hl
                getword zk_ea,zk_tempidx,#0
zk_read16
                call    #zk_read8
                getbyte zk_tmp16,zk_tmp8,#0
                add     zk_ea,#1
                call    #zk_read8
                setbyte zk_tmp16,zk_tmp8,#1
        _ret_   sub     zk_ea,#1

zk_read8hl
                getword zk_ea,zk_tempidx,#0
                jmp     #zk_read8
zk_readcode
                mov     zk_ea,zk_pc
                incmod  zk_pc,zk_ffffh
                'setword zk_pc,#0,#1
                ' fall through
zk_read8
                add     zk_cycles,#3
                mov     pa, zk_ea
                add     pa, zk_ram
                rdbyte  zk_tmp8, pa
                ret     wcz

zk_readcode16
                call    #zk_readcode
                getbyte zk_tmp16,zk_tmp8,#0
                call    #zk_readcode
        _ret_   setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
                getword zk_ea,zk_tempidx,#0
zk_write16
                getbyte zk_tmp8,zk_tmp16,#0
                call    #zk_write8
                add     zk_ea,#1
                getbyte zk_tmp8,zk_tmp16,#1
                call    #zk_write8
        _ret_   sub     zk_ea,#1

zk_write8hl
                getword zk_ea,zk_tempidx,#0
zk_write8
                add     zk_cycles, #3
                mov     pa, zk_ea
                zerox   pa, #16
                add     pa, zk_ram
                wrbyte  zk_tmp8, pa
                ret     wcz

zk_portout
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                cmp     zk_ea, #$80     wcz ' 00-7F = none
         if_c   ret
                cmp     zk_ea, #$A0     wcz ' 80-9F = set to keypad mode
         if_c   sets    _ctl0, #@coleco_ctrls+0
         if_c   sets    _ctl1, #@coleco_ctrls+2
         if_c   ret
                cmp     zk_ea, #$C0     wcz ' A0-BF = video
         if_c   jmp     #\tms_video_out
                cmp     zk_ea, #$E0     wcz ' C0-DF = set to joystick mode
         if_c   sets    _ctl0, #@coleco_ctrls+1
         if_c   sets    _ctl1, #@coleco_ctrls+3
                ret

zk_portin
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                mov     zk_tmp8, #$FF
                cmp     zk_ea, #$A0     wcz ' 00-9F = none
         if_c   ret
                cmp     zk_ea, #$C0     wcz ' A0-BF = video
         if_c   jmp     #\tms_video_in
                cmp     zk_ea, #$E0     wcz ' C0-DF = none
         if_c   ret
                testbn  zk_ea, #1       wz  ' E0-FF = controllers
_ctl0    if_z   rdbyte  zk_tmp8, #@coleco_ctrls+0
_ctl1    if_nz  rdbyte  zk_tmp8, #@coleco_ctrls+2
                ret

tms_video_out
                testbn  zk_ea, #0       wz
        if_z    jmp     #\tms_ram_wr
_setup  if_nz   jmp     #\tms_data_wr
                ret

tms_data_wr     sets    _setup, #tms_reg_wr
                getbyte tms_tmp0, zk_tmp8, #0
                ret     wcz

tms_reg_wr      sets    _setup, #tms_data_wr
                testbn  zk_tmp8, #7          wz
        if_z    jmp     #tms_addr_wr
                mov     tms_tmp1, zk_tmp8
                and     tms_tmp1, #$07
                add     tms_tmp1, ##@tms_regs
                wrbyte  tms_tmp0, tms_tmp1
                ret     wcz

tms_addr_wr     mov     tms_ramptr, zk_tmp8
                and     tms_ramptr, #$3F
                shl     tms_ramptr, #8
                or      tms_ramptr, tms_tmp0
                ret     wcz

tms_ramptr      long    0
tms_tmp0        long    0
tms_tmp1        long    0

zk_ffffh        long    $FFFF
zk_18000h       long    $18000
zk_bit31        long    negx

zk_cycles       long    0
zk_pc           long    $0100

zk_bankmask     long    $FF8000
zk_romstop      long    $4000000
zk_bankreg      long    0

zk_flags        long    0
zk_accu         long    0
zk_debc         long    0
zk_sp           long    0
zk_hl           long    0
zk_ix           long    0
zk_iy           long    0
zk_altflags     long    0
zk_altaccu      long    0
zk_altdebc      long    0
zk_althl        long    0
zk_refresh      long    0
zk_refreshhi    long    0
zk_ivector      long    0
zk_irqenable    long    0

zk_ram          long    @z80_ram

zk_cycletime    long    round(float(_CLKFREQ) / CPU_CLOCK)
zk_lastwait     res     1

zk_opcode       res     1
zk_opimpl       res     1
zk_prefix       res     1
zk_temphl       res     1
zk_tempidx      res     1
zk_hlptr        res     1
zk_tmp16        res     1

zk_optmp0       res     1
zk_optmp1       res     1

'zk_memtmp0      res     1
'zk_memtmp1      res     1
'zk_memtmp2      res     1
'zk_memtmp3      res     1
zk_tmp8         res     1 ' memory read/write value
zk_ea           res     1 ' remapped EA
'zk_ctl          res     1

                fit     $1F0

DAT             ' ZiKore Z80 LUT resident code
                org     $200
zk_lutbase
                '' Opcode table
                long    zk_nextop                                           ' $00: NOP
                long    zk_loadimm16 + (%0000_1_111_0<<10)                  ' $01: LD BC,imm16
                long    zk_a_and_ptr + (%001110<<10)                        ' $02: LD (BC),A
                long    zk_incdec16+(%0000_1_1111_10_1_11100<<10)           ' $03: INC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $04: INC B
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $05: DEC B
                long    zk_loadimm8                                         ' $06: LD B,imm8
                long    zk_rolla+(%0_010_110_01_11110_00<<10)               ' $07: RLCA
                long    zk_ex_af                                            ' $08: EX AF,AF'
                long    zk_math16+(%0010_111_00_1100_00_1110_1_0<<10)       ' $09: ADD HL,BC
                long    zk_a_and_ptr + (%000010<<10)                        ' $0A: LD A,(BC)
                long    zk_incdec16+(%0000_1_1111_01_1_11100<<10)           ' $0B: DEC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $0C: INC C
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $0D: DEC C
                long    zk_loadimm8                                         ' $0E: LD C,imm8
                long    zk_rolla+(%0_010_001_01_11011_00<<10)               ' $0F: RRCA
                long    zk_jr + (%01_11_0000_0<<10)                         ' $10: DJNZ
                long    zk_loadimm16 + (%0001_1_111_0<<10)                  ' $11: LD DE,imm16
                long    zk_a_and_ptr + (%00110 <<10)+1                      ' $12: LD (DE),A
                long    zk_incdec16+(%0001_1_1111_10_1_11010<<10)           ' $13: INC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $14: INC D
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $15: DEC D
                long    zk_loadimm8                                         ' $16: LD D,imm8
                long    zk_rolla+(%0_010_110_00_11110_00<<10)               ' $17: RLA
                long    zk_jr + (%11_11_1111_0<<10)                         ' $18: JR
                long    zk_math16+(%0010_111_00_1100_00_1101_1_0<<10)       ' $19: ADD HL,DE
                long    zk_a_and_ptr + (%00000 <<10)+1                      ' $1A: LD A,(DE)
                long    zk_incdec16+(%0001_1_1111_01_1_11010<<10)           ' $1B: DEC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $1C: INC E
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $1D: DEC E
                long    zk_loadimm8                                         ' $1E: LD E,imm8
                long    zk_rolla+(%0_010_001_00_11011_00<<10)               ' $1F: RRA
                long    zk_jr + (%01_10_1111_0<<10)                         ' $20: JR NZ
                long    zk_loadimm16 + (%0011_1_111_0<<10)                  ' $21: LD HL,imm16
                long    zk_ld_abs16 + (%01011_00<<10)                       ' $22: LD (imm16),HL
                long    zk_incdec16+(%0011_1_1111_10_1_10110<<10)           ' $23: INC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $24: INC H
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $25: DEC H
                long    zk_loadimm8                                         ' $26: LD H,imm8
                long    zk_daa                                              ' $27: DAA
                long    zk_jr + (%00_10_1111_0<<10)                         ' $28: JR Z
                long    zk_math16+(%0010_111_00_1100_00_1011_1_0<<10)       ' $29: ADD HL,HL
                long    zk_ld_abs16 + (%00110_11111_00<<10)                 ' $2A: LD HL,(imm16)
                long    zk_incdec16+(%0011_1_1111_01_1_10110<<10)           ' $2B: DEC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $2C: INC L
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $2D: DEC L
                long    zk_loadimm8                                         ' $2E: LD L,imm8
                long    zk_cpl                                              ' $2F: CPL
                long    zk_jr + (%01_01_1111_0<<10)                         ' $30: JR NC
                long    zk_loadimm16 + (%0111_1_111_0<<10)                              ' $31: LD SP,imm16
                long    zk_ld_abs + (%001111_00<<10)                                    ' $32: LD (imm16),A
                long    zk_incdec16+(%0111_1_1111_10_1_01110<<10)                       ' $33: INC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP       ' $34: INC (HL)
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP       ' $35: DEC (HL)
                long    zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
                long    zk_scf + (%10 << 10)                 ' $37: SCF
                long    zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
                long    zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
                long    zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
                long    zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
                long    zk_loadimm8                          ' $3E: LD A,imm8
                long    zk_ccf                               ' $3F: CCF
                long    zk_nextop                            ' $40: LD B,B (NOP)
                long    zk_regmove                           ' $41: LD B,C
                long    zk_regmove                           ' $42: LD B,D
                long    zk_regmove                           ' $43: LD B,E
                long    zk_regmove                           ' $44: LD B,H
                long    zk_regmove                           ' $45: LD B,L
                long    zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
                long    zk_regmove                           ' $47: LD B,A
                long    zk_regmove                           ' $48: LD C,B
                long    zk_nextop                            ' $49: LD C,C (NOP)
                long    zk_regmove                           ' $4A: LD C,D
                long    zk_regmove                           ' $4B: LD C,E
                long    zk_regmove                           ' $4C: LD C,H
                long    zk_regmove                           ' $4D: LD C,L
                long    zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
                long    zk_regmove                           ' $4F: LD C,A
                long    zk_regmove                           ' $50: LD D,B
                long    zk_regmove                           ' $51: LD D,C
                long    zk_nextop                            ' $52: LD D,D (NOP)
                long    zk_regmove                           ' $53: LD D,E
                long    zk_regmove                           ' $54: LD D,H
                long    zk_regmove                           ' $55: LD D,L
                long    zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
                long    zk_regmove                           ' $57: LD D,A
                long    zk_regmove                           ' $58: LD E,B
                long    zk_regmove                           ' $59: LD E,C
                long    zk_regmove                           ' $5A: LD E,D
                long    zk_nextop                            ' $5B: LD E,E (NOP)
                long    zk_regmove                           ' $5C: LD E,H
                long    zk_regmove                           ' $5D: LD E,L
                long    zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
                long    zk_regmove                           ' $5F: LD E,A
                long    zk_regmove                           ' $60: LD H,B
                long    zk_regmove                           ' $61: LD H,C
                long    zk_regmove                           ' $62: LD H,D
                long    zk_regmove                           ' $63: LD H,E
                long    zk_nextop                            ' $64: LD H,H (NOP)
                long    zk_regmove                           ' $65: LD H,L
                long    zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
                long    zk_regmove                           ' $67: LD H,A
                long    zk_regmove                           ' $68: LD L,B
                long    zk_regmove                           ' $69: LD L,C
                long    zk_regmove                           ' $6A: LD L,D
                long    zk_regmove                           ' $6B: LD L,E
                long    zk_regmove                           ' $6C: LD L,H
                long    zk_nextop                            ' $6D: LD L,L (NOP)
                long    zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
                long    zk_regmove                           ' $6F: LD L,A
                long    zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
                long    zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
                long    zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
                long    zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
                long    zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
                long    zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
                long    zk_halt                              ' $76: HALT
                long    zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
                long    zk_regmove                           ' $78: LD A,B
                long    zk_regmove                           ' $79: LD A,C
                long    zk_regmove                           ' $7A: LD A,D
                long    zk_regmove                           ' $7B: LD A,E
                long    zk_regmove                           ' $7C: LD A,H
                long    zk_regmove                           ' $7D: LD A,L
                long    zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
                long    zk_nextop                            ' $7F: LD A,A (NOP)
                long   (zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
                long   (zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
                long   (zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
                long   (zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
                long   (zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
                long    zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
                long    zk_logic + (%000000_110_0<<10)       ' $A7: AND A
                long   (zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
                long    zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
                long    zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
                long   (zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
                long    zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
                long    zk_logic + (%001000_101_0<<10)       ' $B7: OR A
                long   (zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
                long    zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
                long    zk_poppair+(%0_0<<10)                  ' $C1: POP BC
                long    zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
                long    zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
                long    zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
                long    zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
                long    zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
                long    zk_rst                               ' $C7: RST 00h
                long    zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
                long    zk_ret + (%0101_11_00<<10)           ' $C9: RET
                long    zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
                long    zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
                long    zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
                long    zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
                long    zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
                long    zk_rst                               ' $CF: RST 08h
                long    zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
                long    zk_poppair+(%01_0<<10)                 ' $D1: POP DE
                long    zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
                long    zk_immio + (%00_00<<10)                ' $D3: OUT (imm8),A
                long    zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
                long    zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
                long    zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
                long    zk_rst                               ' $D7: RST 10h
                long    zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
                long    zk_exx                               ' $D9: EXX
                long    zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
                long    zk_immio + (%00_11_00<<10)             ' $DB: IN A,(imm8)
                long    zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
                long    zk_ixprefix                          ' $DD: IX prefix
                long    zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
                long    zk_rst                               ' $DF: RST 18h
                long    zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
                long    zk_poppair+(%0011_0<<10)               ' $E1: POP HL
                long    zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
                long    zk_ex_hlstk                          ' $E3: EX (SP),HL
                long    zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
                long    zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
                long    zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
                long    zk_rst                               ' $E7: RST 20h
                long    zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
                long    zk_jump_indir                          ' $E9: JP (HL)
                long    zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
                long    zk_ex_dehl                           ' $EB: EX DE,HL
                long    zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
                long    zk_extprefix + ZK_HLOP               ' $ED: extension prefix
                long    zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
                long    zk_rst                               ' $EF: RST 28h
                long    zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
                long    zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
                long    zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
                long    zk_irqoff                              ' $F3: DI
                long    zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
                long    zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
                long    zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
                long    zk_rst                               ' $F7: RST 30h
                long    zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
                long    zk_hl_to_sp                            ' $F9: LD SP,(HL)
                long    zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
                long    zk_irqon                               ' $FB: EI
                long    zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
                long    zk_iyprefix + (%10<<10)              ' $FD: IY prefix
                long    zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
                long    zk_rst                               ' $FF: RST 38h

zk_rolla        mov     zk_tmp8,zk_accu
zk_shiftop
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

                bitl    zk_tmp8,#7 wcz  ' left + SRA
                bitz    zk_tmp8,#7 addbits 1 ' only SRA
                bitl    zk_tmp8,#0 wcz  ' right
                modc    _set wc ' only SLL
                modc    _clr wc ' only SLA

                testb   zk_flags,#ZK_CARRY_BIT wc' only RL/RR
                bitz    zk_flags,#ZK_CARRY_BIT

                rcl     zk_tmp8,#1 wz   ' left
                bitc    zk_tmp8,#8     ' right (not SRA/SRL)
                shr     zk_tmp8,#1 wz   ' right

                setq    #ZK_XYMASK
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

        _ret_   mov     zk_accu,zk_tmp8

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_tmp8,#$FF wc
        _ret_   bitnc   zk_flags,#ZK_OVER_BIT

zk_cio
                mov     zk_optmp1,zk_opcode
                and     zk_optmp1,#7<<3
                cmp     zk_optmp1,#6<<3 wz
                mov     zk_tmp8,#0
        if_nz   call    #\zk_getry
                getbyte zk_ea,zk_debc,#0
zk_immio
                call    #\zk_readcode
                mov     zk_ea,zk_tmp8

                mov     zk_tmp8,zk_accu
                jmp     #\zk_portout

                call    #\zk_portin
        _ret_   mov     zk_accu,zk_tmp8

                and     zk_tmp8,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

                cmp     zk_optmp1,#6<<3 wz
        if_z    ret
                jmp     #\zk_setry

zk_incdec8
                call    #\zk_getry
                mov     zk_optmp0,#1
zk_math8
                call    #\zk_getrz
zk_immmath
                call    #\zk_readcode
                mov     zk_optmp0,zk_tmp8
                mov     zk_tmp8,zk_accu

                modc    _clr wc
                testb   zk_flags,#ZK_CARRY_BIT wc

                ' Flag helper gunk
                mov     zk_optmp1,zk_tmp8

                addx    zk_tmp8,zk_optmp0
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_tmp8,zk_optmp0
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_tmp8
                test    zk_tmp8,#$100 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                and     zk_tmp8,#255 wz

                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8
                ' Special nonsense for CP
                setq    #ZK_XYMASK
                muxq    zk_flags,zk_optmp0

                mov     zk_accu,zk_tmp8
                call    #\zk_setry

                xor     zk_optmp1,zk_optmp0
                bitz    zk_flags,#ZK_ZERO_BIT
                testb   zk_optmp1,#4 wc
                bitc    zk_flags,#ZK_HALF_BIT
                test    zk_optmp1,#$180 wc
        _ret_   bitc    zk_flags,#ZK_OVER_BIT

zk_neg
                cmp     zk_accu,#$80 wz
                bitz    zk_flags,#ZK_OVER_BIT
                testb   zk_accu,#4 wz
                subr    zk_accu,#0 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                testb   zk_accu,#4 xorz
                bitz    zk_flags,#ZK_HALF_BIT
                and     zk_accu,#$FF wz
                bitz    zk_flags,#ZK_ZERO_BIT
                bith    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu


zk_cpl
                xor     zk_accu,#$FF
                or      zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_math16
                modc    _clr wc
zk_cmath16
                testb   zk_flags,#ZK_CARRY_BIT wc

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                mov     zk_optmp1,zk_temphl
                xor     zk_optmp1,zk_tmp16

                addx    zk_temphl,zk_tmp16
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_temphl,zk_tmp16
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_temphl
                and     zk_temphl,zk_ffffh wz

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_optmp1,zk_18000h wc
                bitc    zk_flags,#ZK_OVER_BIT

                getbyte pa,zk_temphl,#1
                setq    #ZK_SIGNXYMASK
                setq    #ZK_XYMASK
                muxq    zk_flags,pa

                testb   zk_optmp1,#12 wc
                bitc    zk_flags,#ZK_HALF_BIT
                testb   zk_optmp1,#16 wc
                bitc    zk_flags,#ZK_CARRY_BIT

                add     zk_cycles,#7

                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_daa
                mov     zk_optmp0,#$00
                mov     zk_tmp8,zk_accu
                cmpr    zk_tmp8,#$99 wc
                testb   zk_flags,#ZK_CARRY_BIT orc
        if_c    add     zk_optmp0,#$60
                bitc    zk_flags,#ZK_CARRY_BIT
                getnib  zk_optmp1,zk_tmp8,#0
                cmpr    zk_optmp1,#$9 wc
                testb   zk_flags,#ZK_HALF_BIT orc
        if_c    add     zk_optmp0,#$06
                testb   zk_flags,#ZK_NMODE_BIT wc
                sumc    zk_accu,zk_optmp0
                and     zk_accu,#255 wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT ' Parity?
                testb   zk_accu,#4 wc
                testb   zk_tmp8,#4 xorc
                bitc    zk_flags,#ZK_HALF_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_immlogic
                call    #\zk_readcode
zk_logic
                call    #\zk_getrz

                and     zk_accu,zk_tmp8 wcz
                or      zk_accu,zk_tmp8 wcz
                xor     zk_accu,zk_tmp8 wcz

                bitnc   zk_flags,#ZK_OVER_BIT ' parity
                bitz    zk_flags,#ZK_ZERO_BIT
                andn    zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                bith    zk_flags,#ZK_HALF_BIT ' Only for AND
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_pushaf
                getbyte zk_tmp16,zk_accu,#0
                rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
                add     zk_cycles,#2
zk_pushbc       getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde       getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl       mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                jmp     #\zk_push16

                add     zk_tmp16,#1
                sub     zk_tmp16,#1

zk_loadimm16
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16   ' for LDs with (imm16)
                call    #\zk_read16     ' ^^
                jmp     #\zk_write16     ' ^^
zk_poppair
                call    #\zk_pop16

        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

                getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_   getbyte zk_flags,zk_tmp16,#0  ' set F

zk_jr           '' JR and DJNZ
                call    #\zk_readcode

                getbyte pa,zk_debc,#1
                sub     pa,#1 wz
                setbyte zk_debc,pa,#1
                add     zk_cycles,#1

                testb   zk_flags,#ZK_ZERO_BIT wz
                testb   zk_flags,#ZK_CARRY_BIT wz

                modz    _nz wz
        if_z    call    #\zk_nextop
                ' branch taken
                add     zk_cycles,#5
                signx   zk_tmp8,#7
        _ret_   add     zk_pc,zk_tmp8

zk_exx          '' EXX
                xor     zk_debc,zk_altdebc
                xor     zk_altdebc,zk_debc
                xor     zk_debc,zk_altdebc
                ' Note: not affected by IX/IY substitution
                xor     zk_hl,zk_althl
                xor     zk_althl,zk_hl
        _ret_   xor     zk_hl,zk_althl

zk_ex_dehl      '' EX DE,HL
                ' Note: not affected by IX/IY substitution
                getword zk_optmp0,zk_debc,#1
                setword zk_debc,zk_hl,#1
        _ret_   mov     zk_hl,zk_optmp0


zk_ex_af        '' EX AF,AF'
                xor     zk_accu,zk_altaccu
                xor     zk_altaccu,zk_accu
                xor     zk_accu,zk_altaccu
                xor     zk_flags,zk_altflags
                xor     zk_altflags,zk_flags
        _ret_   xor     zk_flags,zk_altflags

zk_ex_hlstk     '' EX (SP),HL
                add     zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
                mov     zk_ea,zk_sp
                call    #\zk_read16
                altd    zk_hlptr
                mov     0-0,zk_tmp16
                mov     zk_tmp16,zk_temphl
                jmp     #\zk_write16

zk_ld_abs16     '' LD HL,(imm16) and LD (imm16),HL
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl ' get HL/I*
                mov     zk_tmp16,zk_sp ' get SP
                jmp     #\zk_write16

                call    #\zk_read16
        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   mov     zk_sp,zk_tmp16

zk_scf
                modc    _clr wc
zk_ccf
                testb   zk_flags,#ZK_CARRY_BIT wc
                bitnc   zk_flags,#ZK_CARRY_BIT
                bitc    zk_flags,#ZK_HALF_BIT
                bitl    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_ld_abs       '' LD A,(imm16) and LD (imm16),A
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16
zk_a_and_ptr    '' A and (BC)/(DE) ops
                getword zk_ea,zk_debc,#0 ' get BC
                getword zk_ea,zk_debc,#1 ' get DE
                call    #\zk_read8
        _ret_   mov     zk_accu,zk_tmp8
                mov     zk_tmp8,zk_accu
                jmp     #\zk_write8

zk_regmove
                push    #zk_setry
                jmp     #\zk_getrz

zk_loadimm8
                push    #zk_setry
                jmp     #\zk_readcode

zk_halt
                jatn    zk_nmiptr
                'incmod  zk_refresh, #127
                jmp     #zk_halt

                fit     $400


DAT             orgh

tms_video_in
                testbn  zk_ea, #0       wz
        if_z    jmp     #\tms_ram_rd
        if_nz   jmp     #\tms_status_rd

tms_ram_wr      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                wrbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_ram_rd      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                rdbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_status_rd   mov     tms_tmp0, ##@tms_status
                rdbyte  zk_tmp8, tms_tmp0
                mov     tms_tmp1, zk_tmp8
                bitl    tms_tmp1, #7      wcz
        if_c    wrbyte  tms_tmp1, tms_tmp0
                ret     wcz

CON

    ZK_CLOCK      = NTSC
    ZK_HLOP       = 1 << 10

    ZK_CARRY_BIT  = 0
    ZK_NMODE_BIT  = 1
    ZK_OVER_BIT   = 2 ' also parity
    ZK_HALF_BIT   = 4
    ZK_ZERO_BIT   = 6
    ZK_SIGN_BIT   = 7

    ZK_XYMASK     = %0010_1000
    ZK_SIGNXYMASK = %1010_1000

    ZK_IFF1_BIT   = 0
    ZK_IFF2_BIT   = 1

DAT             org     $000

'
' VGA Driver
'
tms_driver
                setq2   #$10 - 1                'load palette into lut
                rdlong  0, _tms_palette

                mov     _xf, ##_CLKFREQ         'calculate streamer frequency
                qfrac   ##VGA_FPIX, _xf
                getqx   _xf
                shr     _xf, #1

                setcmod #%01_0_000_0            'enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24   'r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16   'g
                setcq   ##VGA_INTENSITY << 08   'b
                setxfrq _xf                     'set transfer frequency

                cogid   cx                      'insert cogid into dac modes
                setnib  dacmode_s,cx,#2
                setnib  dacmode_c,cx,#2

                wrpin   dacmode_s,_pn           'enable 123-ohm 3.3V dac mode in pin +0

                xor     _pn,#2<<6|1             'enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c,_pn

                xor     _pn,#3<<6 ^(2<<6|1)     'make pins +0..3 outputs
                drvl    _pn

                xor     _pn,#4|(3<<6)           'leave av_base pointing to pin +4 (vertical sync)

                mov     ijmp1,#field            'set up streamer-empty interrupt
                setint1 #10

                mov     scol, #0
                xcont   #10,#0                  'do streamer instruction to start interrupt sequence
'
'
' Main program
'
loop
                cmp     _cl, scnt           wcz
    if_z        jmp     #loop

                mov     scol, scol+1
                mov     scnt, _cl

                setq    #1                      ' read registers into temp buffer
                rdlong  sbuf, #@tms_regs        ' |

                getnib  scol+1, sbuf+1, #6      ' border color for next line
                movbyts scol+1, #0

                cmp     _cl, _tms_first     wcz ' check if first visible line
    if_c        jmp     #loop
                cmp     _cl, _tms_last      wc  ' check if last visible line
    if_nc       jmp     #loop

    if_z        mov     loff, #0                ' if first line reset counters...
    if_z        mov     lcnt, #0
    if_z        mov     ptrv, _tms_bitmap       ' ...and pointers

                getbyte regs+0, sbuf, #0
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
                getbyte regs+1, sbuf, #1
                getbyte regs+2, sbuf, #2
                shl     regs+2, #10             ' name table base address * $400
                add     regs+2, _tms_vram
                getbyte regs+3, sbuf, #3
                shl     regs+3, #6              ' color table base address * $40
    if_nz       andn    regs+3, vdp_8k_mask     ' limit color table to 8k boundaries
                add     regs+3, _tms_vram
                getbyte regs+4, sbuf+1, #0
                shl     regs+4, #11             ' pattern generator base address * $800
    if_nz       andn    regs+4, vdp_8k_mask     ' limit pattern table to 8k boundaries
                add     regs+4, _tms_vram
                getbyte regs+5, sbuf+1, #1
                shl     regs+5, #7              ' sprite attribute table base address * $80
                add     regs+5, _tms_vram
                getbyte regs+6, sbuf+1, #2
                shl     regs+6, #11             ' sprite pattern generator base address * $800
                add     regs+6, _tms_vram
                getbyte regs+7, sbuf+1, #3

                setq    #32-1                   ' read all sprite attribute table
                rdlong  sbuf, regs+5

scanline
                mov     ptra, ptrv

                test    regs+1, #TMSBLANK   wz  ' blank
    if_z        jmp     #blank_line

                test    regs+1, #TMSMODE1   wz  ' text mode
                mov     a, lcnt
                andn    a, #$07                 ' divide and multiply by 8
                mov     b, a
                shl     a, #2                   ' multiply by 32
    if_nz       add     a, b                    ' multiply by 40
                add     regs+2, a
    if_nz       jmp     #text_mode

                test    regs+1, #TMSMODE2   wz  ' multicolor mode
    if_nz       jmp     #multicolor_mode

                jmp     #graphics_mode

text_mode
                getnib  ctmp, regs+7, #1        ' foreground color
                shl     ctmp, #8
                setnib  ctmp, regs+7, #0        ' background color

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                mov     ptrb, regs+2

                mov     ecnt, #40
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, loff
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                shr     a, #8
                mov     cbuf+1, ctmp
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++
                sub     ptra, #2

                djnz    ecnt, #.loop

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                jmp     #end_scanline

blank_line
                getnib  ctmp, regs+7, #0        ' background color
                movbyts ctmp, #0

                mov     ecnt, #256/4            ' fill line with background
.l1             wrlong  ctmp, ptra++
                djnz    ecnt, #.l1

                jmp     #end_scanline

multicolor_mode
                mov     a, lcnt
                shr     a, #2
                and     a, #$07

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3
                add     ptrc, regs+4            ' points to color table
                add     ptrc, a

                rdbyte  cbuf+0, ptrc            ' colors

                mov     cbuf+1, cbuf+0
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0
                shr     cbuf+0, #4          wz
    if_z        setnib  cbuf+0, regs+7, #0

                movbyts cbuf+0, #%%0000
                movbyts cbuf+1, #%%0000

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                jmp     #sprites

graphics_mode
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       mov     a, lcnt
    if_nz       shr     a, #6                   ' divide by 64 (8 rows by 8 pixels)
    if_nz       shl     a, #11                  ' multiply by 2048
                mov     b, loff                 ' offset into pattern table
    if_nz       add     b, a                    ' add mode II pattern table offset

                bitnz   .shlr, #21              ' patch shl(0)/shr(1)

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display

                mov     ptrd, ptrc
.shlr           shl     ptrd, #3
                add     ptrd, regs+3            ' points to color table
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       add     ptrd, b
                rdbyte  a, ptrd                 ' colors

                getnib  cbuf+0, a, #0
                and     cbuf+0, #$0F        wz
    if_z        setnib  cbuf+0, regs+7, #0
                getnib  cbuf+1, a, #1
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0

                setbyte cbuf+0, cbuf+1, #1
                mov     cbuf+1, cbuf+0

                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, b
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                movbyts cbuf+0, a
                shr     a, #8
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                ' fall through

sprites
                mov     b, #8
                test    regs+1, #TMSSPRSIZE wz
    if_nz       shl     b, #1
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shl     b, #1

                mov     ecnt, #14               ' clear buffers
.l1             altd    ecnt, #vbuf-1
                mov     0-0, #0
                djnz    ecnt, #.l1

                mov     stat, #0
                mov     vcnt, #0
                mov     ccnt, #0

.loop           alts    ccnt, #sbuf
                mov     sprt, 0-0

                mov     y, sprt
                shl     y, #24
                sar     y, #24                  ' sign-extend y
                cmps    y, neg_clip wc
    if_c        and     y, #$FF                 ' max -32
                cmp     y, #$D0 wz              ' end of sprites processing
    if_z        jmp     #.end

                mov     a, lcnt                 ' check sprite scanline visibility
                subs    a, y    wc
    if_c        jmp     #.next
                cmp     a, b    wc
    if_nc       jmp     #.next
                setbyte sprt, a, #0

                incmod  vcnt, #4    wc          ' limit sprites on scanline
    if_c        mov     stat, ccnt              ' set 5th sprite
    if_c        or      stat, #%010_00000
    if_c        jmp     #.end

                altd    vcnt, #vbuf-1
                mov     0-0, sprt

.next           incmod  ccnt, #TMSSPRITES-1 wc
    if_nc       jmp     #.loop
.end

                mov     sprt, vbuf+3    wz
    if_nz       calld   draw_sprite_ret, #draw_sprite
                mov     sprt, vbuf+2    wz
    if_nz       calld   draw_sprite_ret, #draw_sprite
                mov     sprt, vbuf+1    wz
    if_nz       calld   draw_sprite_ret, #draw_sprite
                mov     sprt, vbuf+0    wz
    if_nz       calld   draw_sprite_ret, #draw_sprite

                rdbyte  a, #@tms_status         ' update status byte
                test    stat, #%001_00000  wz
    if_nz       or      a, #%001_00000
                test    a, #%010_00000     wz
    if_z        or      a, stat
                wrbyte  a, #@tms_status

end_scanline
                add     ptrv, #256
                incmod  loff, #7
                incmod  lcnt, #192-1

                jmp     #loop

draw_sprite
                getbyte a, sprt, #0
                mov     ptrc, sprt
                shr     ptrc, #16
                and     ptrc, #$FF
                shl     ptrc, #3
                add     ptrc, regs+6
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shr     a, #1
                add     ptrc, a

                getnib  ctmp, sprt, #6          'set sprite color
                shl     ctmp, #8

                getbyte x, sprt, #1
                testbn  sprt, #31           wz  'TMSEARLYCLK
    if_nz       sub     x, #32
                mov     ptra, ptrv
                add     ptra, x

                test    regs+1, #TMSSPRSIZE wz
    if_z        mov     ecnt, #4
    if_nz       mov     ecnt, #8

                rdbyte  sprt, ptrc
                shl     sprt, #8
    if_nz       add     ptrc, #16
    if_nz       rdbyte  a, ptrc
    if_nz       or      sprt, a

                test    regs+1, #TMSSPRMAG  wz
    if_nz       setword sprt, sprt, #1
    if_nz       mergew  sprt
    if_z        shl     sprt, #16

                cmps    x, #0       wc          ' skip left offscreen pixels
    if_c        abs     x                       ' |
    if_c        add     ptra, x                 ' |
    if_c        sub     ecnt, x                 ' |
    if_c        cmps    x, #32      wz          ' |
    if_c_and_z  mov     sprt, #0                ' |
    if_c_and_nz shl     sprt, x                 ' |
    if_c        mov     x, #0                   ' |

                mov     cbuf, sprt
                mov     cbuf+1, cbuf

                mov     y, x                    ' check sprite collision
                sar     y, #5                   ' |
                add     y, #line                ' |
                setd    .c0, y                  ' |
                setd    .c0+1, y                ' |
                add     y, #1                   ' |
                setd    .c1, y                  ' |
                setd    .c1+1, y                ' |
                mov     a, x                    ' |
                and     a, #$1F     wz          ' |
    if_z        mov     cbuf+1, #0              ' |
                shr     cbuf, a                 ' |
.c0             test    0-0, cbuf   wz          ' |
                or      0-0, cbuf               ' |
                mov     y, #32                  ' |
                sub     y, a                    ' |
                shl     cbuf+1,y                ' |
.c1 if_z        test    0-0, cbuf+1 wz          ' |
                or      0-0, cbuf+1             ' |
    if_nz       or      stat, #%0010_0000       ' update collision flag
                mov     line+8, #0              ' clear right offscreen pixels

                rev     sprt

.draw           getnib  a, sprt, #0
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                wmlong  cbuf+0, ptra++
                add     x, #4
                cmp     x, #256     wc
                shr     sprt, #4    wz
    if_c_and_nz djnz    ecnt, #.draw

                jmp     draw_sprite_ret
draw_sprite_ret long    0
'
'
' Field loop
'
field
                mov     cy,#24                  'before-visible blank lines
                calld   border_ret, #border

                mov     _lb, _tms_bitmap

                mov     cy,#192                 'visible lines
.line           xcont   _as,#0                  'do before-visible part of scan line
                add     _cl, #1

                rdfast  #4, _lb                 'start reading pixels into fifo
                resi1
                xcont   _bv, scol
                resi1
                xcont   _dv, #0
                resi1
                xcont   _av, scol
                resi1
                xcont   _bs,#0                 'do before-sync part of scan line
                resi1
                xzero   _ds,#1                 'do sync part of scan line
                resi1

                ' duplicate line
                xcont   _as,#0                 'do before-visible part of scan line
                resi1
                xcont   _bv, scol
                resi1
                xcont   _dv, #0
                resi1
                xcont   _av, scol
                resi1
                xcont   _bs,#0                 'do before-sync part of scan line
                resi1
                xzero   _ds,#1                 'do sync part of scan line

                add     _lb, #256
                resi1
                djnz    cy,#.line

                mov     cy,#24                  'after-visible blank lines
                calld   border_ret, #border

                rdbyte  cy, #@tms_status        ' update status byte
                bith    cy, #7              wcz ' vsync flag
                wrbyte  cy, #@tms_status

                test    regs+1, #TMSINTEN   wz
    if_00       cogatn  #%00000010              'signal vertical sync to cog1

                mov     cy, #10
                calld   blank_ret, #blank

                drvnot  _pn                     'vertical sync on
                mov     cy, #2
                calld   blank_ret, #blank
                drvnot  _pn                     'vertical sync off

                mov     _cl, #0

                mov     cy, #33
                calld   blank_ret, #blank

                jmp     #field                  'loop
'
'
' Subroutines
'
blank           xcont   _as,#0                  'do before-visible part of scan line
                resi1
                xcont   _vi,#0                  'do visible part of scan line (blank)
                resi1
                xcont   _bs,#0                  'do before-sync part of scan line
                resi1
                xzero   _ds,#1                  'do sync part of scan line
                resi1
                djnz    cy,#blank               'loop if more blanks needed
                jmp     blank_ret
blank_ret       long    0

border          xcont   _as,#0                  'do before-visible part of scan line
                add     _cl, #1
                resi1
                xcont   _vi,scol                'do visible part of scan line (blank)
                resi1
                xcont   _bs,#0                  'do before-sync part of scan line
                resi1
                xzero   _ds,#1                  'do sync part of scan line
                resi1

                xcont   _as,#0                  'do before-visible part of scan line
                resi1
                xcont   _vi,scol                'do visible part of scan line (blank)
                resi1
                xcont   _bs,#0                  'do before-sync part of scan line
                resi1
                xzero   _ds,#1                  'do sync part of scan line
                resi1
                djnz    cy,#border
                jmp     border_ret
border_ret      long    0
'
'
' Data
'
dacmode_s       long    %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

cx              long    0
cy              long    0

_xf             long    0                       'streamer frequency setting
_bs             long    $7F010000+8             'streamer command: before-sync
_ds             long    $7F010000+48            'streamer command: during-sync
_as             long    $7F010000+24            'streamer command: after sync
_vi             long    $3F000000+320           'streamer command: visible
_bv             long    $3F000000+32            'streamer command: before visible
_dv             long    $7F080000+256           'streamer command: during visible
_av             long    $3F000000+32            'streamer command: after visible
_lb             long    0                       'line buffer pointer
_cl             long    0                       'current line
_pn             long    VGA_PIN & $38           'base pin

_tms_vram       long    @tms_vram
_tms_first      long    24
_tms_last       long    24 + 192
_tms_bitmap     long    @tms_bitmap
_tms_palette    long    @tms_palette

vdp_8k_mask     long    $1FFF
neg_clip        long    -32

a               res     1
b               res     1
x               res     1
y               res     1

scnt            res     1
scol            res     2                       'backdrop/border color

lcnt            res     1
loff            res     1
ccnt            res     1
vcnt            res     1
ecnt            res     1

ctmp            res     1
cbuf            res     2
sprt            res     1

ptrc            res     1
ptrd            res     1
ptrv            res     1

stat            res     1
regs            res     8
sbuf            res     32

vbuf            res     4
line            res     8
                res     1

                fit     $1F0

CON

    VGA_FPIX      = 12_500_000
    VGA_INTENSITY = 80    '0..128

    TMSMODE3   = %00000010      ' mode bit 3
    TMSEXTVID  = %00000001      ' external video

    ' register 1 control bits
    TMS4K16K   = %10000000      ' 4/16K RAM
    TMSBLANK   = %01000000      ' screen blank
    TMSINTEN   = %00100000      ' interrupt enable
    TMSMODE1   = %00010000      ' mode bit 1
    TMSMODE2   = %00001000      ' mode bit 2
    TMSSPRSIZE = %00000010      ' sprite size
    TMSSPRMAG  = %00000001      ' sprite magnification

    TMSVSYNC   = %10000000      ' framce sync

    TMSSPRITES = 32

' Runtime data area

DAT             orgh

tms_palette     long    $00_00_00_00
                long    $00_00_00_00
                long    $66_CC_66_00
                long    $88_EE_88_00
                long    $44_44_DD_00
                long    $77_77_FF_00
                long    $BB_55_55_00
                long    $77_DD_DD_00
                long    $DD_66_66_00
                long    $FF_77_77_00
                long    $CC_CC_55_00
                long    $EE_EE_88_00
                long    $55_AA_55_00
                long    $BB_55_BB_00
                long    $CC_CC_CC_00
                long    $EE_EE_EE_00

tms_vram        byte    0[16384]
tms_bitmap      byte    0[256 * 192]

z80_ram         file    "COLECO.ROM"
                orgh    z80_ram + $8000
                'byte    $00, $00
                'file    "Final Test Cartridge (19xx).col"
                'file    "BC's Quest for Tires (1983) (Sierravision).col"
                'file    "Choplifter (USA, Europe).col"
                'file    "Congo Bongo (USA, Europe).col"
                'file    "Bump 'N' Jump (USA, Europe).col"
                'file    "BurgerTime (USA, Europe).col"
                'file    "Lady Bug (USA, Europe).col"
                'file    "Donkey Kong (USA, Europe).col"
                file    "H.E.R.O (USA).col"
                'file    "Frogger (USA).col"
                'file    "Pitfall! (USA).col"
                'file    "River Raid (USA).col"
                'file    "Zaxxon (USA, Europe).col"
                orgh    z80_ram + $10000
